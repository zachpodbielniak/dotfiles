#!/usr/bin/bash
# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail

usage () {
	cat << 'EOF'
is_number - Validate if input is a number

USAGE:
	is_number [OPTIONS] [STRING]

ARGUMENTS:
	STRING          String to check (if omitted, reads from stdin)

OPTIONS:
	-h, --help      Show this help message
	--license       Show license information
	--strict        Only accept integers (reject floats)
	--positive      Only accept positive numbers (reject negatives)
	--quiet         No output, just exit code

EXAMPLES:
	echo "42" | is_number && echo "Valid number"
	is_number "42" && echo "Valid number"
	is_number "3.14" --strict || echo "Not integer"
	is_number "-5" --positive || echo "Negative rejected"

DESCRIPTION:
	Validates that input is a valid number.
	Exit code 0 if input is a valid number.
	Exit code 1 if input is not a valid number.

EOF
}

# Parse options
strict=false
positive=false
quiet=false
input_string=""

while [[ $# -gt 0 ]]; do
	case "$1" in
		-h|--help)
			usage
			exit 0
			;;
		--license)
			echo "AGPLv3"
			exit 0
			;;
		--strict)
			strict=true
			shift
			;;
		--positive)
			positive=true
			shift
			;;
		--quiet)
			quiet=true
			shift
			;;
		*)
			# Assume this is the input string (positional argument)
			if [[ -z "$input_string" ]]; then
				input_string="$1"
				shift
			else
				if [[ ! "$quiet" == "true" ]]; then
					echo "is_number: unknown option: $1" >&2
				fi
				exit 1
			fi
			;;
	esac
done

# Regex patterns for number validation
# Basic float pattern: optional sign, digits, optional decimal part, optional exponent
float_pattern='^[+-]?([0-9]+\.?[0-9]*|\.[0-9]+)([eE][+-]?[0-9]+)?$'
# Integer pattern: optional sign, digits only
int_pattern='^[+-]?[0-9]+$'
# Positive integer pattern
positive_int_pattern='^[+]?[0-9]+$'
# Positive float pattern
positive_float_pattern='^[+]?([0-9]+\.?[0-9]*|\.[0-9]+)([eE][+]?[0-9]+)?$'

# Determine input source
if [[ -n "$input_string" ]]; then
	# String argument provided
	lines=("$input_string")
else
	# Read from stdin
	readarray -t lines
fi

# Validate each line
all_valid=true

for line in "${lines[@]}"; do
	# Skip empty lines
	[[ -z "$line" ]] && continue

	is_valid=false

	if [[ "$strict" == "true" ]]; then
		# Strict mode: integers only
		if [[ "$positive" == "true" ]]; then
			[[ "$line" =~ $positive_int_pattern ]] && is_valid=true
		else
			[[ "$line" =~ $int_pattern ]] && is_valid=true
		fi
	else
		# Regular mode: floats and integers
		if [[ "$positive" == "true" ]]; then
			[[ "$line" =~ $positive_float_pattern ]] && is_valid=true
		else
			[[ "$line" =~ $float_pattern ]] && is_valid=true
		fi
	fi

	if [[ "$is_valid" == "false" ]]; then
		all_valid=false
		if [[ ! "$quiet" == "true" ]]; then
			echo "is_number: invalid number: $line" >&2
		fi
	fi
done

if [[ "$all_valid" == "true" ]]; then
	exit 0
else
	exit 1
fi
