#!/usr/bin/bash
# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail

usage () {
	cat << 'EOF'
is_number - Validate if lines are numbers

USAGE:
	is_number [OPTIONS]

OPTIONS:
	-h, --help      Show this help message
	--license       Show license information
	--strict        Only accept integers (reject floats)
	--positive      Only accept positive numbers (reject negatives)
	--quiet         No output, just exit code

EXAMPLES:
	echo "42" | is_number && echo "Valid number"
	echo "3.14" | is_number --strict && echo "Integer"
	echo "-5" | is_number --positive || echo "Negative rejected"

DESCRIPTION:
	Validates that each line of stdin is a valid number.
	Exit code 0 if ALL lines are valid numbers.
	Exit code 1 if ANY line is not a valid number.

EOF
}

# Parse options
strict=false
positive=false
quiet=false

while [[ $# -gt 0 ]]; do
	case "$1" in
		-h|--help)
			usage
			exit 0
			;;
		--license)
			echo "AGPLv3"
			exit 0
			;;
		--strict)
			strict=true
			shift
			;;
		--positive)
			positive=true
			shift
			;;
		--quiet)
			quiet=true
			shift
			;;
		*)
			if [[ ! "$quiet" == "true" ]]; then
				echo "is_number: unknown option: $1" >&2
			fi
			exit 1
			;;
	esac
done

# Regex patterns for number validation
# Basic float pattern: optional sign, digits, optional decimal part, optional exponent
float_pattern='^[+-]?([0-9]+\.?[0-9]*|\.[0-9]+)([eE][+-]?[0-9]+)?$'
# Integer pattern: optional sign, digits only
int_pattern='^[+-]?[0-9]+$'
# Positive integer pattern
positive_int_pattern='^[+]?[0-9]+$'
# Positive float pattern
positive_float_pattern='^[+]?([0-9]+\.?[0-9]*|\.[0-9]+)([eE][+]?[0-9]+)?$'

# Read stdin and validate
all_valid=true

while IFS= read -r line || [[ -n "$line" ]]; do
	# Skip empty lines
	[[ -z "$line" ]] && continue

	is_valid=false

	if [[ "$strict" == "true" ]]; then
		# Strict mode: integers only
		if [[ "$positive" == "true" ]]; then
			[[ "$line" =~ $positive_int_pattern ]] && is_valid=true
		else
			[[ "$line" =~ $int_pattern ]] && is_valid=true
		fi
	else
		# Regular mode: floats and integers
		if [[ "$positive" == "true" ]]; then
			[[ "$line" =~ $positive_float_pattern ]] && is_valid=true
		else
			[[ "$line" =~ $float_pattern ]] && is_valid=true
		fi
	fi

	if [[ "$is_valid" == "false" ]]; then
		all_valid=false
		if [[ ! "$quiet" == "true" ]]; then
			echo "is_number: invalid number: $line" >&2
		fi
	fi
done

if [[ "$all_valid" == "true" ]]; then
	exit 0
else
	exit 1
fi
