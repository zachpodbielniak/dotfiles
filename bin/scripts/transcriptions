#!/usr/bin/python3

import os
import sys
import subprocess

# Container check for distrobox - do this BEFORE any other imports
ctr_id = os.environ.get("CONTAINER_ID", "")
if ctr_id != "dev":
    cmd = ["distrobox", "enter", "dev", "--", *sys.argv]
    subprocess.run(cmd)
    sys.exit(0)

# Now import everything else inside the dev container
try:
    import argparse
    import json
    import psycopg2
    from psycopg2.extras import RealDictCursor
    from datetime import datetime
    from typing import Optional, List, Dict, Any
    from tabulate import tabulate
    from colorama import init, Fore, Style, Back
    import yaml
except ImportError as e:
    # We're inside dev container but missing dependencies
    print(f"Error: Missing required Python module: {e}", file=sys.stderr)
    print("Please install the required dependencies:", file=sys.stderr)
    print("  pip install psycopg2-binary tabulate colorama pyyaml", file=sys.stderr)
    sys.exit(1)

# Initialize colorama for cross-platform color support
init(autoreset=True)

# Configuration with environment variables
DB_CONFIG = {
    'host': os.environ.get('TRANSCRIPTION_DB_HOST', '127.0.0.1'),
    'port': int(os.environ.get('TRANSCRIPTION_DB_PORT', '5432')),
    'database': os.environ.get('TRANSCRIPTION_DB_NAME', 'transcriptions'),
    'user': os.environ.get('TRANSCRIPTION_DB_USER', 'postgres'),
    'password': os.environ.get('TRANSCRIPTION_DB_PASSWORD', '')
}

class TranscriptionManager:
    def __init__(self, no_color: bool = False):
        self.no_color = no_color
        self.conn = None
        self.cursor = None
        self._connect()
    
    def _connect(self):
        """Establish persistent database connection"""
        try:
            self.conn = psycopg2.connect(**DB_CONFIG)
            self.cursor = self.conn.cursor(cursor_factory=RealDictCursor)
        except psycopg2.Error as e:
            self._error(f"Database connection failed: {e}")
            sys.exit(1)
    
    def __del__(self):
        """Clean up database connection"""
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()
    
    def _color(self, text: str, color: str) -> str:
        """Apply color to text unless no_color is set"""
        if self.no_color:
            return text
        return f"{color}{text}{Style.RESET_ALL}"
    
    def _error(self, message: str):
        """Print error message"""
        print(self._color(f"Error: {message}", Fore.RED), file=sys.stderr)
    
    def _success(self, message: str):
        """Print success message"""
        print(self._color(message, Fore.GREEN))
    
    def _info(self, message: str):
        """Print info message"""
        print(self._color(message, Fore.CYAN))
    
    def _format_date(self, dt: datetime) -> str:
        """Format datetime for display"""
        return dt.strftime("%Y-%m-%d %H:%M:%S")
    
    def search(self, query: str, limit: int = 10, type_filter: Optional[str] = None,
               tags_filter: Optional[List[str]] = None, output_format: str = 'text',
               verbose: bool = False) -> None:
        """Search transcriptions using full-text search"""
        
        # Build WHERE clauses
        where_clauses = ["tc.content_vector @@ plainto_tsquery('english', %s)"]
        params = [query]
        
        if type_filter:
            where_clauses.append("t.metadata->>'type' = %s")
            params.append(type_filter)
        
        if tags_filter:
            tag_conditions = []
            for tag in tags_filter:
                tag_conditions.append("t.metadata->'tags' ? %s")
                params.append(tag.strip())
            if tag_conditions:
                where_clauses.append(f"({' OR '.join(tag_conditions)})")
        
        where_clause = " AND ".join(where_clauses)
        
        # Main search query
        sql = f"""
        SELECT DISTINCT ON (t.id)
            t.id,
            t.filename,
            t.file_path,
            t.metadata,
            t.transcribed_at,
            ts_rank(tc.content_vector, plainto_tsquery('english', %s)) as rank,
            ts_headline('english', tc.content, plainto_tsquery('english', %s),
                'StartSel=**, StopSel=**, MaxWords=50, MinWords=20') as snippet
        FROM transcriptions t
        JOIN transcription_chunks tc ON t.id = tc.transcription_id
        WHERE {where_clause}
        ORDER BY t.id, rank DESC
        LIMIT %s
        """
        
        params.extend([query, query, limit])
        
        if verbose:
            print(f"DEBUG: SQL Query: {sql}")
            print(f"DEBUG: Params: {params}")
        
        try:
            self.cursor.execute(sql, params)
            results = self.cursor.fetchall()
            
            if output_format == 'json':
                print(json.dumps([dict(r) for r in results], default=str, indent=2))
            elif output_format == 'yaml':
                yaml_data = {'results': []}
                for r in results:
                    item = {
                        'id': str(r['id']),
                        'filename': r['filename'],
                        'transcribed_at': self._format_date(r['transcribed_at']),
                        'rank': float(r['rank']),
                        'snippet': r['snippet'].replace("''", "'")
                    }
                    if r['file_path']:
                        item['file_path'] = r['file_path']
                    if r['metadata']:
                        if r['metadata'].get('type'):
                            item['type'] = r['metadata']['type']
                        if r['metadata'].get('tags'):
                            item['tags'] = r['metadata']['tags']
                    yaml_data['results'].append(item)
                print(yaml.dump(yaml_data, default_flow_style=False))
            elif output_format == 'simple':
                for r in results:
                    print(r['filename'])
            else:  # text format with nice table
                if not results:
                    self._info("No results found.")
                    return
                
                print(self._color(f"\nSearch results for: \"{query}\"", Fore.YELLOW))
                print(self._color("=" * 50, Fore.YELLOW))
                
                table_data = []
                for i, r in enumerate(results, 1):
                    metadata_info = []
                    if r['metadata']:
                        if r['metadata'].get('type'):
                            metadata_info.append(f"Type: {self._color(r['metadata']['type'], Fore.MAGENTA)}")
                        if r['metadata'].get('tags'):
                            tags_colored = [self._color(tag, Fore.BLUE) for tag in r['metadata']['tags']]
                            metadata_info.append(f"Tags: {', '.join(tags_colored)}")
                    
                    snippet = r['snippet'].replace("''", "'")
                    # Highlight matched terms in snippet
                    if not self.no_color:
                        snippet = snippet.replace("**", f"{Fore.YELLOW}{Style.BRIGHT}")
                        snippet = snippet.replace("**", f"{Style.RESET_ALL}")
                    
                    table_data.append([
                        self._color(str(i), Fore.WHITE + Style.BRIGHT),
                        self._color(r['filename'], Fore.CYAN),  # Filename in cyan
                        self._color(self._format_date(r['transcribed_at']), Fore.WHITE),
                        '\n'.join(metadata_info) if metadata_info else self._color('None', Fore.LIGHTBLACK_EX),
                        snippet[:100] + '...' if len(snippet) > 100 else snippet
                    ])
                
                headers = [
                    self._color('#', Fore.WHITE + Style.BRIGHT),
                    self._color('Filename', Fore.CYAN + Style.BRIGHT),
                    self._color('Transcribed', Fore.WHITE + Style.BRIGHT),
                    self._color('Metadata', Fore.YELLOW + Style.BRIGHT),
                    self._color('Snippet', Fore.YELLOW + Style.BRIGHT)
                ]
                print(tabulate(table_data, headers=headers, tablefmt='grid'))
                print(f"\nFound {len(results)} results.")
                
        except psycopg2.Error as e:
            self._error(f"Search failed: {e}")
    
    def view(self, identifier: str, show_metadata: bool = False, 
             output_format: str = 'text', no_timestamps: bool = False) -> None:
        """View full transcription content"""
        
        # Determine if identifier is UUID or filename
        try:
            # Try to parse as UUID
            import uuid
            uuid.UUID(identifier)
            is_uuid = True
        except ValueError:
            is_uuid = False
        
        # Always aggregate chunks in order to get the full content
        # Use newline separator to properly join chunks
        if is_uuid:
            sql = """
            SELECT t.*, 
                   string_agg(tc.content, E'\n' ORDER BY tc.chunk_number) as full_content
            FROM transcriptions t
            LEFT JOIN transcription_chunks tc ON t.id = tc.transcription_id
            WHERE t.id = %s::uuid
            GROUP BY t.id
            """
            params = [identifier]
        else:
            sql = """
            SELECT t.*, 
                   string_agg(tc.content, E'\n' ORDER BY tc.chunk_number) as full_content
            FROM transcriptions t
            LEFT JOIN transcription_chunks tc ON t.id = tc.transcription_id
            WHERE t.filename = %s
            GROUP BY t.id
            ORDER BY t.transcribed_at DESC
            LIMIT 1
            """
            params = [identifier]
        
        try:
            self.cursor.execute(sql, params)
            result = self.cursor.fetchone()
            
            if not result:
                self._error(f"No transcription found for: {identifier}")
                return
            
            if output_format == 'json':
                output = dict(result)
                print(json.dumps(output, default=str, indent=2))
            elif output_format == 'yaml':
                output = {
                    'transcription': {
                        'id': str(result['id']),
                        'filename': result['filename'],
                        'transcribed_at': self._format_date(result['transcribed_at']),
                        'content': result['full_content']
                    }
                }
                if result['file_path']:
                    output['transcription']['file_path'] = result['file_path']
                if result['model_used']:
                    output['transcription']['model_used'] = result['model_used']
                if result['duration_seconds']:
                    output['transcription']['duration_seconds'] = result['duration_seconds']
                if result['metadata']:
                    if result['metadata'].get('type'):
                        output['transcription']['type'] = result['metadata']['type']
                    if result['metadata'].get('tags'):
                        output['transcription']['tags'] = result['metadata']['tags']
                print(yaml.dump(output, default_flow_style=False))
            elif output_format == 'simple':
                content = result['full_content']
                if content:
                    lines = content.split('\n')
                    if no_timestamps:
                        # Show only lines without timestamps
                        filtered_lines = [line for line in lines 
                                        if not (line.strip().startswith('[') and '-->' in line)]
                    else:
                        # Check if there are any timestamped lines
                        timestamped_lines = [line for line in lines 
                                           if line.strip().startswith('[') and '-->' in line]
                        if timestamped_lines:
                            # Show only timestamped lines if they exist
                            filtered_lines = timestamped_lines
                        else:
                            # No timestamps found, show all content
                            filtered_lines = lines
                    
                    print('\n'.join(filtered_lines))
            else:  # text format
                if show_metadata:
                    print(self._color("=== METADATA ===", Fore.CYAN))
                    metadata_table = [
                        ['ID', str(result['id'])],
                        ['Filename', result['filename']],
                        ['Path', result['file_path'] or 'N/A'],
                        ['Transcribed', self._format_date(result['transcribed_at'])],
                        ['Model', result['model_used'] or 'unknown'],
                        ['Duration', f"{result['duration_seconds']} seconds" if result['duration_seconds'] else 'unknown']
                    ]
                    
                    if result['metadata']:
                        if result['metadata'].get('type'):
                            metadata_table.append(['Type', result['metadata']['type']])
                        if result['metadata'].get('tags'):
                            metadata_table.append(['Tags', ', '.join(result['metadata']['tags'])])
                    
                    print(tabulate(metadata_table, tablefmt='plain'))
                    print(self._color("\n=== TRANSCRIPTION ===", Fore.CYAN))
                
                # Filter content based on timestamps preference
                content = result['full_content']
                if content:
                    lines = content.split('\n')
                    if no_timestamps:
                        # Show only lines without timestamps
                        filtered_lines = [line for line in lines 
                                        if not (line.strip().startswith('[') and '-->' in line)]
                    else:
                        # Check if there are any timestamped lines
                        timestamped_lines = [line for line in lines 
                                           if line.strip().startswith('[') and '-->' in line]
                        if timestamped_lines:
                            # Show only timestamped lines if they exist
                            filtered_lines = timestamped_lines
                        else:
                            # No timestamps found, show all content
                            filtered_lines = lines
                    
                    print('\n'.join(filtered_lines))
                
        except psycopg2.Error as e:
            self._error(f"View failed: {e}")
    
    def list(self, limit: int = 10, type_filter: Optional[str] = None,
             tags_filter: Optional[List[str]] = None, output_format: str = 'text') -> None:
        """List recent transcriptions"""
        
        # Build WHERE clause
        where_clauses = []
        params = []
        
        if type_filter:
            where_clauses.append("metadata->>'type' = %s")
            params.append(type_filter)
        
        if tags_filter:
            tag_conditions = []
            for tag in tags_filter:
                tag_conditions.append("metadata->'tags' ? %s")
                params.append(tag.strip())
            if tag_conditions:
                where_clauses.append(f"({' OR '.join(tag_conditions)})")
        
        where_clause = "WHERE " + " AND ".join(where_clauses) if where_clauses else ""
        
        sql = f"""
        SELECT id, filename, file_path, transcribed_at, metadata
        FROM transcriptions
        {where_clause}
        ORDER BY transcribed_at DESC
        LIMIT %s
        """
        params.append(limit)
        
        try:
            self.cursor.execute(sql, params)
            results = self.cursor.fetchall()
            
            if output_format == 'json':
                print(json.dumps([dict(r) for r in results], default=str, indent=2))
            elif output_format == 'yaml':
                yaml_data = {'transcriptions': []}
                for r in results:
                    item = {
                        'id': str(r['id']),
                        'filename': r['filename'],
                        'transcribed_at': self._format_date(r['transcribed_at'])
                    }
                    if r['file_path']:
                        item['file_path'] = r['file_path']
                    if r['metadata']:
                        if r['metadata'].get('type'):
                            item['type'] = r['metadata']['type']
                        if r['metadata'].get('tags'):
                            item['tags'] = r['metadata']['tags']
                    yaml_data['transcriptions'].append(item)
                print(yaml.dump(yaml_data, default_flow_style=False))
            elif output_format == 'simple':
                for r in results:
                    print(r['filename'])
            else:  # text format with nice table
                if not results:
                    self._info("No transcriptions found.")
                    return
                
                print(self._color("\nRecent transcriptions:", Fore.YELLOW))
                print(self._color("=" * 80, Fore.YELLOW))
                
                table_data = []
                for r in results:
                    metadata_info = []
                    if r['metadata']:
                        if r['metadata'].get('type'):
                            metadata_info.append(self._color(r['metadata']['type'], Fore.MAGENTA))
                        if r['metadata'].get('tags'):
                            tags_colored = [self._color(tag, Fore.BLUE) for tag in r['metadata']['tags']]
                            metadata_info.append(', '.join(tags_colored))
                    
                    table_data.append([
                        self._color(str(r['id']), Fore.GREEN),  # UUID in green
                        self._color(r['filename'], Fore.CYAN),   # Filename in cyan
                        self._color(self._format_date(r['transcribed_at']), Fore.WHITE),
                        ' | '.join(metadata_info) if metadata_info else self._color('None', Fore.LIGHTBLACK_EX)
                    ])
                
                headers = [
                    self._color('ID', Fore.GREEN + Style.BRIGHT),
                    self._color('Filename', Fore.CYAN + Style.BRIGHT),
                    self._color('Transcribed', Fore.WHITE + Style.BRIGHT),
                    self._color('Type/Tags', Fore.YELLOW + Style.BRIGHT)
                ]
                print(tabulate(table_data, headers=headers, tablefmt='grid'))
                
        except psycopg2.Error as e:
            self._error(f"List failed: {e}")
    
    def delete(self, identifier: str, confirm: bool = False) -> None:
        """Delete a transcription and its chunks"""
        
        # Determine if identifier is UUID or filename
        try:
            import uuid
            uuid.UUID(identifier)
            is_uuid = True
        except ValueError:
            is_uuid = False
        
        # First, get the transcription details
        if is_uuid:
            sql = "SELECT id, filename FROM transcriptions WHERE id = %s::uuid"
            params = [identifier]
        else:
            sql = """
            SELECT id, filename FROM transcriptions 
            WHERE filename = %s 
            ORDER BY transcribed_at DESC 
            LIMIT 1
            """
            params = [identifier]
        
        try:
            self.cursor.execute(sql, params)
            result = self.cursor.fetchone()
            
            if not result:
                self._error(f"No transcription found for: {identifier}")
                return
            
            # Confirm deletion
            if not confirm:
                print(self._color("About to delete transcription:", Fore.YELLOW))
                print(f"  ID: {result['id']}")
                print(f"  Filename: {result['filename']}")
                response = input(self._color("Are you sure? (y/N): ", Fore.YELLOW))
                if response.lower() != 'y':
                    print("Deletion cancelled.")
                    return
            
            # Delete transcription (chunks are cascade deleted)
            self.cursor.execute("DELETE FROM transcriptions WHERE id = %s::uuid", [result['id']])
            self.conn.commit()
            self._success("Transcription deleted successfully.")
            
        except psycopg2.Error as e:
            self.conn.rollback()
            self._error(f"Delete failed: {e}")
    
    def stats(self) -> None:
        """Show database statistics"""
        
        print(self._color("\nTranscription Database Statistics", Fore.YELLOW))
        print(self._color("=" * 50, Fore.YELLOW))
        
        try:
            # Overall statistics
            self.cursor.execute("""
                SELECT 
                    COUNT(DISTINCT t.id) as total_transcriptions,
                    COUNT(tc.id) as total_chunks,
                    COALESCE(SUM(tc.character_count), 0) as total_characters,
                    COALESCE(AVG(tc.character_count), 0)::integer as avg_chunk_size
                FROM transcriptions t
                LEFT JOIN transcription_chunks tc ON t.id = tc.transcription_id
            """)
            stats = self.cursor.fetchone()
            
            stats_table = [
                [self._color('Total Transcriptions', Fore.CYAN), self._color(f"{stats['total_transcriptions']:,}", Fore.GREEN)],
                [self._color('Total Chunks', Fore.CYAN), self._color(f"{stats['total_chunks']:,}", Fore.GREEN)],
                [self._color('Total Characters', Fore.CYAN), self._color(f"{stats['total_characters']:,}", Fore.GREEN)],
                [self._color('Average Chunk Size', Fore.CYAN), self._color(f"{stats['avg_chunk_size']:,}", Fore.GREEN)]
            ]
            print(tabulate(stats_table, tablefmt='plain'))
            
            # Top types
            print(self._color("\nTop 5 Types:", Fore.CYAN))
            self.cursor.execute("""
                SELECT 
                    COALESCE(metadata->>'type', 'none') as type,
                    COUNT(*) as count
                FROM transcriptions
                GROUP BY metadata->>'type'
                ORDER BY count DESC
                LIMIT 5
            """)
            types = self.cursor.fetchall()
            if types:
                type_table = [[self._color(t['type'], Fore.MAGENTA), self._color(f"{t['count']:,}", Fore.GREEN)] for t in types]
                headers = [self._color('Type', Fore.MAGENTA + Style.BRIGHT), self._color('Count', Fore.GREEN + Style.BRIGHT)]
                print(tabulate(type_table, headers=headers, tablefmt='simple'))
            
            # Top tags
            print(self._color("\nTop 10 Tags:", Fore.CYAN))
            self.cursor.execute("""
                SELECT 
                    tag,
                    COUNT(*) as count
                FROM (
                    SELECT jsonb_array_elements_text(metadata->'tags') as tag
                    FROM transcriptions
                    WHERE metadata->'tags' IS NOT NULL
                ) t
                GROUP BY tag
                ORDER BY count DESC
                LIMIT 10
            """)
            tags = self.cursor.fetchall()
            if tags:
                tag_table = [[self._color(t['tag'], Fore.BLUE), self._color(f"{t['count']:,}", Fore.GREEN)] for t in tags]
                headers = [self._color('Tag', Fore.BLUE + Style.BRIGHT), self._color('Count', Fore.GREEN + Style.BRIGHT)]
                print(tabulate(tag_table, headers=headers, tablefmt='simple'))
                
        except psycopg2.Error as e:
            self._error(f"Stats failed: {e}")


def main():
    parser = argparse.ArgumentParser(
        description='Unified management tool for transcriptions stored in PostgreSQL',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
EXAMPLES:
    # Search for content
    transcriptions-ng search "action items"
    transcriptions-ng search --type meeting --limit 5 "budget"
    
    # View transcription
    transcriptions-ng view 75647fb6-5a16-44a5-9155-2bc0aab58b0f
    transcriptions-ng view recording.mp3
    transcriptions-ng view -m recording.mp3  # With metadata
    
    # List recent transcriptions
    transcriptions-ng list
    transcriptions-ng list --limit 20 --type meeting
    
    # Delete transcription
    transcriptions-ng delete recording.mp3
    transcriptions-ng delete -y 75647fb6-5a16-44a5-9155-2bc0aab58b0f
    
    # Show statistics
    transcriptions-ng stats

ENVIRONMENT VARIABLES:
    TRANSCRIPTION_DB_HOST     Database host (default: 127.0.0.1)
    TRANSCRIPTION_DB_PORT     Database port (default: 5432)
    TRANSCRIPTION_DB_NAME     Database name (default: transcriptions)
    TRANSCRIPTION_DB_USER     Database user (default: postgres)
    TRANSCRIPTION_DB_PASSWORD Database password (default: none)
"""
    )
    
    # Subcommands
    subparsers = parser.add_subparsers(dest='action', help='Action to perform')
    
    # Search command
    search_parser = subparsers.add_parser('search', help='Search transcriptions using full-text search')
    search_parser.add_argument('query', help='Search query')
    search_parser.add_argument('-l', '--limit', type=int, default=10, help='Number of results to show (default: 10)')
    search_parser.add_argument('-t', '--type', help='Filter by transcription type')
    search_parser.add_argument('-T', '--tags', help='Filter by tags (comma-separated)')
    search_parser.add_argument('-f', '--format', choices=['text', 'simple', 'json', 'yaml'], 
                              default='text', help='Output format')
    search_parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    
    # View command
    view_parser = subparsers.add_parser('view', help='View full transcription content')
    view_parser.add_argument('identifier', help='UUID or filename')
    view_parser.add_argument('-m', '--metadata', action='store_true', help='Include metadata in output')
    view_parser.add_argument('-f', '--format', choices=['text', 'simple', 'json', 'yaml'], 
                            default='text', help='Output format')
    view_parser.add_argument('--no-timestamps', action='store_true', 
                            help='Show content without timestamps (default: show only timestamped lines)')
    
    # List command
    list_parser = subparsers.add_parser('list', help='List recent transcriptions')
    list_parser.add_argument('-l', '--limit', type=int, default=10, help='Number of results to show (default: 10)')
    list_parser.add_argument('-t', '--type', help='Filter by transcription type')
    list_parser.add_argument('-T', '--tags', help='Filter by tags (comma-separated)')
    list_parser.add_argument('-f', '--format', choices=['text', 'simple', 'json', 'yaml'], 
                            default='text', help='Output format')
    
    # Delete command
    delete_parser = subparsers.add_parser('delete', help='Delete a transcription and its chunks')
    delete_parser.add_argument('identifier', help='UUID or filename')
    delete_parser.add_argument('-y', '--yes', action='store_true', help='Skip confirmation prompt')
    
    # Stats command
    stats_parser = subparsers.add_parser('stats', help='Show database statistics')
    
    # Global options
    parser.add_argument('--no-color', action='store_true', help='Disable colored output')
    
    args = parser.parse_args()
    
    if not args.action:
        parser.print_help()
        sys.exit(0)
    
    # Create manager instance
    manager = TranscriptionManager(no_color=args.no_color)
    
    # Execute action
    try:
        if args.action == 'search':
            tags = args.tags.split(',') if args.tags else None
            manager.search(args.query, limit=args.limit, type_filter=args.type,
                          tags_filter=tags, output_format=args.format,
                          verbose=args.verbose)
        elif args.action == 'view':
            manager.view(args.identifier, show_metadata=args.metadata,
                        output_format=args.format, no_timestamps=args.no_timestamps)
        elif args.action == 'list':
            tags = args.tags.split(',') if args.tags else None
            manager.list(limit=args.limit, type_filter=args.type,
                        tags_filter=tags, output_format=args.format)
        elif args.action == 'delete':
            manager.delete(args.identifier, confirm=args.yes)
        elif args.action == 'stats':
            manager.stats()
    except KeyboardInterrupt:
        print("\nOperation cancelled.")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()