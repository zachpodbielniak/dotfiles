#!/usr/bin/python3

import sys
import re
import argparse
import csv
from pathlib import Path
from io import StringIO
from typing import Dict, List, Tuple, Optional

class MarkdownTangler:
    def __init__(self):
        self.language_extensions = {
            'bash': '.sh',
            'sh': '.sh',
            'shell': '.sh',
            'python': '.py',
            'python3': '.py',
            'py': '.py',
            'javascript': '.js',
            'js': '.js',
            'typescript': '.ts',
            'ts': '.ts',
            'java': '.java',
            'c': '.c',
            'cpp': '.cpp',
            'c++': '.cpp',
            'cxx': '.cpp',
            'cc': '.cpp',
            'rust': '.rs',
            'go': '.go',
            'haskell': '.hs',
            'hs': '.hs',
            'ruby': '.rb',
            'rb': '.rb',
            'php': '.php',
            'perl': '.pl',
            'r': '.R',
            'sql': '.sql',
            'html': '.html',
            'css': '.css',
            'scss': '.scss',
            'sass': '.sass',
            'yaml': '.yml',
            'yml': '.yml',
            'json': '.json',
            'xml': '.xml',
            'dockerfile': '.dockerfile',
            'makefile': '.mk',
            'make': '.mk',
            'vim': '.vim',
            'lua': '.lua',
            'swift': '.swift',
            'kotlin': '.kt',
            'scala': '.scala',
            'clojure': '.clj',
            'elisp': '.el',
            'lisp': '.lisp',
            'scheme': '.scm',
            'tex': '.tex',
            'latex': '.tex',
            'markdown': '.md',
            'md': '.md',
            'toml': '.toml',
            'ini': '.ini',
            'conf': '.conf',
            'config': '.conf',
        }
        self.tangled_files = {}  # Track which files have been written to
        
    def parse_code_block_header(self, header_line: str) -> Tuple[str, Dict[str, str]]:
        """Parse code block header to extract language and parameters."""
        # Remove the ``` prefix
        content = header_line.strip()[3:].strip()
        
        if not content:
            return '', {}
            
        # Split by space to separate language from parameters
        parts = content.split(' ', 1)
        language = parts[0].lower()
        
        params = {}
        if len(parts) > 1:
            # Parse parameters as CSV key=value pairs
            param_string = parts[1].strip()
            if param_string:
                # Use CSV reader to handle quoted values properly
                csv_reader = csv.reader(StringIO(param_string))
                try:
                    for row in csv_reader:
                        for item in row:
                            if '=' in item:
                                key, value = item.split('=', 1)
                                params[key.strip()] = value.strip()
                except csv.Error:
                    # Fallback to simple parsing if CSV fails
                    for item in param_string.split(','):
                        if '=' in item:
                            key, value = item.split('=', 1)
                            params[key.strip()] = value.strip()
        
        return language, params
    
    def get_output_filename(self, language: str, params: Dict[str, str], input_file: str) -> Optional[str]:
        """Determine output filename based on tangle parameter or language."""
        if 'tangle' in params:
            tangle_value = params['tangle'].lower()
            if tangle_value in ('no', 'false', '0'):
                return None  # Don't tangle this block
            return params['tangle']
        
        # Generate filename from input file basename + language extension
        input_path = Path(input_file)
        base_name = input_path.stem
        extension = self.language_extensions.get(language, '.txt')
        return f"{base_name}{extension}"
    
    def extract_code_blocks(self, content: str) -> List[Tuple[str, str, Dict[str, str]]]:
        """Extract code blocks from markdown content."""
        blocks = []
        lines = content.split('\n')
        i = 0
        
        while i < len(lines):
            line = lines[i].strip()
            
            # Look for code block start
            if line.startswith('```') and len(line) > 3:
                language, params = self.parse_code_block_header(line)
                
                # Collect code block content
                code_lines = []
                i += 1
                while i < len(lines):
                    if lines[i].strip() == '```':
                        break
                    code_lines.append(lines[i])
                    i += 1
                
                code_content = '\n'.join(code_lines)
                blocks.append((language, code_content, params))
            
            i += 1
        
        return blocks
    
    def write_code_block(self, filename: str, content: str, params: Dict[str, str]):
        """Write code block to file, handling append logic."""
        # Determine if this is the first write to this file
        if filename in self.tangled_files:
            mode = 'a'  # Append mode for subsequent writes
        else:
            mode = 'w'  # Write mode for first write
            self.tangled_files[filename] = True
        
        # Ensure directory exists
        Path(filename).parent.mkdir(parents=True, exist_ok=True)
        
        with open(filename, mode, encoding='utf-8') as f:
            # Add shebang if specified
            if mode == 'w' and 'shebang' in params:
                f.write(f"{params['shebang']}\n")
            
            # Add separator comment if appending
            if mode == 'a' and 'comment' in params:
                f.write(f"\n{params['comment']}\n")
            elif mode == 'a':
                f.write(f"\n# Tangled from code block\n")
            
            # Write the actual code content
            f.write(content)
            if not content.endswith('\n'):
                f.write('\n')
        
        # Set executable permissions if shebang is present
        if 'shebang' in params:
            Path(filename).chmod(0o755)
    
    def tangle_file(self, input_file: str, output_dir: str = '.') -> Dict[str, int]:
        """Tangle a markdown file, extracting code blocks to separate files."""
        try:
            with open(input_file, 'r', encoding='utf-8') as f:
                content = f.read()
        except FileNotFoundError:
            print(f"Error: Input file '{input_file}' not found", file=sys.stderr)
            return {}
        except Exception as e:
            print(f"Error reading file '{input_file}': {e}", file=sys.stderr)
            return {}
        
        blocks = self.extract_code_blocks(content)
        tangled_files = {}
        
        for language, code_content, params in blocks:
            output_filename = self.get_output_filename(language, params, input_file)
            
            if output_filename is None:
                continue  # Skip blocks marked with tangle=no
            
            # Handle relative paths relative to output directory
            if not Path(output_filename).is_absolute():
                output_filename = str(Path(output_dir) / output_filename)
            
            try:
                self.write_code_block(output_filename, code_content, params)
                if output_filename in tangled_files:
                    tangled_files[output_filename] += 1
                else:
                    tangled_files[output_filename] = 1
            except Exception as e:
                print(f"Error writing to '{output_filename}': {e}", file=sys.stderr)
        
        return tangled_files
    
    def tangle_content(self, content: str, base_name: str = 'untitled', output_dir: str = '.') -> Dict[str, int]:
        """Tangle markdown content directly."""
        blocks = self.extract_code_blocks(content)
        tangled_files = {}
        
        for language, code_content, params in blocks:
            # Use base_name for filename generation
            fake_input = f"{base_name}.md"
            output_filename = self.get_output_filename(language, params, fake_input)
            
            if output_filename is None:
                continue  # Skip blocks marked with tangle=no
            
            # Handle relative paths relative to output directory
            if not Path(output_filename).is_absolute():
                output_filename = str(Path(output_dir) / output_filename)
            
            try:
                self.write_code_block(output_filename, code_content, params)
                if output_filename in tangled_files:
                    tangled_files[output_filename] += 1
                else:
                    tangled_files[output_filename] = 1
            except Exception as e:
                print(f"Error writing to '{output_filename}': {e}", file=sys.stderr)
        
        return tangled_files

def main():
    parser = argparse.ArgumentParser(
        description='Extract code blocks from markdown files into separate source files',
        epilog='''
Examples:
  md_tangle document.md                    # Tangle to current directory
  md_tangle -o src/ document.md           # Tangle to src/ directory
  cat document.md | md_tangle             # Tangle from stdin
  md_tangle -v document.md                # Verbose output
  
Code Block Syntax:
  ```python tangle=script.py
  print("Hello, world!")
  ```
  
  ```bash shebang="#!/bin/bash", tangle=run.sh
  echo "Executable script"
  ```
  
  ```python tangle=no
  # This block won't be tangled
  ```
        ''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('input', nargs='?', help='Input markdown file (default: stdin)')
    parser.add_argument('-o', '--output-dir', default='.', 
                       help='Output directory for tangled files (default: current directory)')
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Verbose output showing tangled files')
    parser.add_argument('--dry-run', action='store_true',
                       help='Show what would be tangled without writing files')
    
    args = parser.parse_args()
    
    tangler = MarkdownTangler()
    
    try:
        if args.input:
            # Tangle from file
            if args.dry_run:
                with open(args.input, 'r', encoding='utf-8') as f:
                    content = f.read()
                blocks = tangler.extract_code_blocks(content)
                print(f"Would tangle {len(blocks)} code blocks from '{args.input}':")
                for language, code_content, params in blocks:
                    output_filename = tangler.get_output_filename(language, params, args.input)
                    if output_filename:
                        if not Path(output_filename).is_absolute():
                            output_filename = str(Path(args.output_dir) / output_filename)
                        print(f"  {language} -> {output_filename} ({len(code_content.splitlines())} lines)")
                    else:
                        print(f"  {language} -> (skipped - tangle=no)")
            else:
                tangled_files = tangler.tangle_file(args.input, args.output_dir)
                
                if args.verbose or not tangled_files:
                    if tangled_files:
                        print(f"Tangled {len(tangled_files)} files from '{args.input}':")
                        for filename, count in tangled_files.items():
                            blocks_text = "block" if count == 1 else "blocks" 
                            print(f"  {filename} ({count} {blocks_text})")
                    else:
                        print(f"No code blocks found to tangle in '{args.input}'")
        else:
            # Tangle from stdin
            content = sys.stdin.read()
            if not content.strip():
                print("Error: No input provided", file=sys.stderr)
                sys.exit(1)
            
            if args.dry_run:
                blocks = tangler.extract_code_blocks(content)
                print(f"Would tangle {len(blocks)} code blocks from stdin:")
                for language, code_content, params in blocks:
                    output_filename = tangler.get_output_filename(language, params, 'stdin.md')
                    if output_filename:
                        if not Path(output_filename).is_absolute():
                            output_filename = str(Path(args.output_dir) / output_filename)
                        print(f"  {language} -> {output_filename} ({len(code_content.splitlines())} lines)")
                    else:
                        print(f"  {language} -> (skipped - tangle=no)")
            else:
                tangled_files = tangler.tangle_content(content, 'stdin', args.output_dir)
                
                if args.verbose or not tangled_files:
                    if tangled_files:
                        print(f"Tangled {len(tangled_files)} files from stdin:")
                        for filename, count in tangled_files.items():
                            blocks_text = "block" if count == 1 else "blocks"
                            print(f"  {filename} ({count} {blocks_text})")
                    else:
                        print("No code blocks found to tangle in input")
    
    except KeyboardInterrupt:
        print("\nTangling interrupted", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()