#!/bin/bash
set -euo pipefail

# safe_name: Sanitizes filenames by replacing spaces/hyphens with underscore
# and removing any non-alphanumeric, non-underscore characters

function show_help() {
    echo "Usage: safe_name [options] <filename> [<filename> ...]"
    echo "       <command> | safe_name [options]"
    echo
    echo "Sanitizes filenames by:"
    echo "  - Replacing whitespace and hyphens with underscores"
    echo "  - Removing any non-alphanumeric, non-underscore characters"
    echo "  - Preserving file extensions (unless --remove-extension is used)"
    echo
    echo "By default, returns the sanitized filenames to stdout"
    echo
    echo "If no filenames are provided as arguments, reads from stdin (one file per line)"
    echo
    echo "Options:"
    echo "  -r, --rename           Rename the files to the sanitized names (using mv)"
    echo "  -c, --cp               Copy the files to the sanitized names (using cp)"
    echo "  -o, --output-dir       Directory where renamed/copied files should be placed"
    echo "  --remove-extension     Remove file extension from the sanitized filename"
    echo "  -h, --help             Display this help message and exit"
}

# Default options
rename_file=false
copy_mode=false
output_dir=""
remove_extension=false
files=()

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -r|--rename)
            rename_file=true
            copy_mode=false # Ensure we don't have both set
            shift
            ;;
        -c|--cp)
            copy_mode=true
            rename_file=false # Ensure we don't have both set
            shift
            ;;
        -o|--output-dir)
            if [[ -z ${2:-} ]]; then
                echo "Error: --output-dir requires a directory path" >&2
                exit 1
            fi
            output_dir="$2"
            shift 2
            ;;
        --remove-extension)
            remove_extension=true
            shift
            ;;
        *)
            # Add to list of files
            files+=("$1")
            shift
            ;;
    esac
done

# Check if we have any files from command line
if [[ ${#files[@]} -eq 0 ]]; then
    # No files from command line, check stdin
    if [[ -t 0 ]]; then
        # stdin is a terminal (not piped)
        echo "Error: No files provided" >&2
        show_help
        exit 1
    else
        # Read files from stdin
        while IFS= read -r line; do
            # Skip empty lines
            if [[ -n "$line" ]]; then
                files+=("$line")
            fi
        done
    fi
    
    # Check again if we got any files from stdin
    if [[ ${#files[@]} -eq 0 ]]; then
        echo "Error: No files provided via stdin" >&2
        exit 1
    fi
fi

# Check if output directory is specified but doesn't exist
if [[ -n "$output_dir" ]]; then
    if [[ ! -d "$output_dir" ]]; then
        echo "Error: Output directory '$output_dir' does not exist" >&2
        exit 1
    fi
    
    # Make sure output_dir ends with a slash
    if [[ "$output_dir" != */ ]]; then
        output_dir="${output_dir}/"
    fi
    
    # Check if output directory is only used with rename/copy
    if [[ "$rename_file" == false && "$copy_mode" == false ]]; then
        echo "Error: --output-dir option can only be used with --rename or --cp" >&2
        show_help
        exit 1
    fi
fi

# Determine if we need to actually modify files or just print
modify_files=$([[ "$rename_file" == true || "$copy_mode" == true ]] && echo true || echo false)

# Process each file
for filename in "${files[@]}"; do
    # Check if file exists when we need to modify it
    if [[ "$modify_files" == true && ! -f "$filename" ]]; then
        echo "Error: File '$filename' does not exist, skipping" >&2
        continue
    fi

    # Extract the filename without path
    file_basename=$(basename "$filename")
    
    # Extract the file extension (if any)
    extension=""
    if [[ "$file_basename" == *.* && "$remove_extension" == false ]]; then
        extension=".${file_basename##*.}"
        name_part="${file_basename%.*}"
    else
        # Either no extension or we're removing it
        name_part="$file_basename"
        if [[ "$remove_extension" == true && "$file_basename" == *.* ]]; then
            name_part="${file_basename%.*}"
        fi
    fi

    # Sanitize the basename:
    # 1. Replace spaces and hyphens with underscores
    # 2. Remove any non-alphanumeric, non-underscore characters
    sanitized_name_part=$(echo "$name_part" | tr ' -' '_' | tr -cd 'a-zA-Z0-9_')

    # Combine sanitized basename with original extension (if keeping extension)
    sanitized_filename="${sanitized_name_part}${extension}"

    # Compare against appropriate original name
    original_for_comparison="$file_basename"
    if [[ "$remove_extension" == true && "$file_basename" == *.* ]]; then
        original_for_comparison="${file_basename%.*}"
    fi
    
    # Check if the sanitized name is effectively the same as the original
    if [[ "$original_for_comparison" == "${sanitized_filename%.*}" && "$extension" == "" && "$remove_extension" == true ]] || 
       [[ "$file_basename" == "$sanitized_filename" && "$remove_extension" == false ]]; then
        if [[ "$modify_files" == true ]]; then
            echo "File already has a safe name: '$file_basename'" >&2
        else
            echo "$filename -> $sanitized_filename"
        fi
        continue
    fi

    # Handle file modification (rename or copy)
    if [[ "$modify_files" == true ]]; then
        # Determine the target path
        if [[ -n "$output_dir" ]]; then
            # Use the output directory specified
            new_path="${output_dir}${sanitized_filename}"
        else
            # Use the original directory
            dir=$(dirname "$filename")
            new_path="${dir}/${sanitized_filename}"
        fi
        
        # Perform the rename or copy operation
        if [[ "$copy_mode" == true ]]; then
            # Copy file
            cp -v "$filename" "$new_path"
        else
            # Move file
            mv -v "$filename" "$new_path"
        fi
    else
        # Just output the sanitized filename
        echo "$filename -> $sanitized_filename"
    fi
done