#!/bin/bash
set -euo pipefail

# safe_name: Sanitizes filenames by replacing spaces/hyphens with underscore
# and removing any non-alphanumeric, non-underscore characters

function show_help() {
    echo "Usage: safe_name [options] <filename> [<filename> ...]"
    echo "       <command> | safe_name [options]"
    echo
    echo "Sanitizes filenames by:"
    echo "  - Replacing whitespace and hyphens with underscores"
    echo "  - Removing any non-alphanumeric, non-underscore characters"
    echo "  - Preserving file extensions (unless --remove-extension is used)"
    echo "  - Optionally converting to lowercase (--lower) or uppercase (--upper)"
    echo
    echo "By default, returns the sanitized filenames to stdout"
    echo
    echo "If no filenames are provided as arguments, reads from stdin (one file per line)"
    echo
    echo "Options:"
    echo "  -r, --rename           Rename the files to the sanitized names (using mv)"
    echo "  -c, --cp               Copy the files to the sanitized names (using cp)"
    echo "  -o, --output-dir       Directory where renamed/copied files should be placed"
    echo "  --remove-extension     Remove file extension from the sanitized filename"
    echo "  --lower                Convert filenames to all lowercase"
    echo "  --upper                Convert filenames to all uppercase"
    echo "  --confirm              Ask for confirmation before each rename/copy operation"
    echo "  --prepend <str>        Prepend string to the beginning of sanitized filename"
    echo "  --append <str>         Append string to the end of filename (before extension)"
    echo "  --verbose              Explain each step of the sanitization process"
    echo "  --dry-run              Show commands that would be executed without running them"
    echo "  -h, --help             Display this help message and exit"
}

# Default options
rename_file=false
copy_mode=false
output_dir=""
remove_extension=false
use_lower=false
use_upper=false
confirm_mode=false
prepend_str=""
append_str=""
verbose=false
dry_run=false
files=()

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -r|--rename)
            rename_file=true
            copy_mode=false # Ensure we don't have both set
            shift
            ;;
        -c|--cp)
            copy_mode=true
            rename_file=false # Ensure we don't have both set
            shift
            ;;
        -o|--output-dir)
            if [[ -z ${2:-} ]]; then
                echo "Error: --output-dir requires a directory path" >&2
                exit 1
            fi
            output_dir="$2"
            shift 2
            ;;
        --remove-extension)
            remove_extension=true
            shift
            ;;
        --lower)
            use_lower=true
            use_upper=false # Ensure we don't have both set
            shift
            ;;
        --upper)
            use_upper=true
            use_lower=false # Ensure we don't have both set
            shift
            ;;
        --confirm)
            confirm_mode=true
            shift
            ;;
        --prepend)
            if [[ -z ${2:-} ]]; then
                echo "Error: --prepend requires a string argument" >&2
                exit 1
            fi
            prepend_str="$2"
            shift 2
            ;;
        --append)
            if [[ -z ${2:-} ]]; then
                echo "Error: --append requires a string argument" >&2
                exit 1
            fi
            append_str="$2"
            shift 2
            ;;
        --verbose)
            verbose=true
            shift
            ;;
        --dry-run)
            dry_run=true
            shift
            ;;
        *)
            # Add to list of files
            files+=("$1")
            shift
            ;;
    esac
done

# Check if we have any files from command line
if [[ ${#files[@]} -eq 0 ]]; then
    # No files from command line, check stdin
    if [[ -t 0 ]]; then
        # stdin is a terminal (not piped)
        echo "Error: No files provided" >&2
        show_help
        exit 1
    else
        # Read files from stdin
        while IFS= read -r line; do
            # Skip empty lines
            if [[ -n "$line" ]]; then
                files+=("$line")
            fi
        done
    fi
    
    # Check again if we got any files from stdin
    if [[ ${#files[@]} -eq 0 ]]; then
        echo "Error: No files provided via stdin" >&2
        exit 1
    fi
fi

# Check if output directory is specified but doesn't exist
if [[ -n "$output_dir" ]]; then
    if [[ ! -d "$output_dir" ]]; then
        echo "Error: Output directory '$output_dir' does not exist" >&2
        exit 1
    fi
    
    # Make sure output_dir ends with a slash
    if [[ "$output_dir" != */ ]]; then
        output_dir="${output_dir}/"
    fi
    
    # Check if output directory is only used with rename/copy
    if [[ "$rename_file" == false && "$copy_mode" == false ]]; then
        echo "Error: --output-dir option can only be used with --rename or --cp" >&2
        show_help
        exit 1
    fi
fi

# Determine if we need to actually modify files or just print
modify_files=$([[ "$rename_file" == true || "$copy_mode" == true ]] && echo true || echo false)

# Process each file
for filename in "${files[@]}"; do
    [[ "$verbose" == true ]] && echo "Processing: $filename"
    
    # Check if file exists when we need to modify it
    if [[ "$modify_files" == true && ! -f "$filename" ]]; then
        echo "Error: File '$filename' does not exist, skipping" >&2
        continue
    fi

    # Extract the filename without path
    file_basename=$(basename "$filename")
    [[ "$verbose" == true ]] && echo "  Basename: $file_basename"
    
    # Extract the file extension (if any)
    extension=""
    if [[ "$file_basename" == *.* && "$remove_extension" == false ]]; then
        extension=".${file_basename##*.}"
        name_part="${file_basename%.*}"
        [[ "$verbose" == true ]] && echo "  Extension: $extension"
        [[ "$verbose" == true ]] && echo "  Name part: $name_part"
    else
        # Either no extension or we're removing it
        name_part="$file_basename"
        if [[ "$remove_extension" == true && "$file_basename" == *.* ]]; then
            name_part="${file_basename%.*}"
            [[ "$verbose" == true ]] && echo "  Removing extension from: $file_basename"
        fi
        [[ "$verbose" == true ]] && echo "  Name part: $name_part"
    fi

    # Sanitize the basename:
    # 1. Replace spaces and hyphens with underscores
    # 2. Remove any non-alphanumeric, non-underscore characters
    sanitized_name_part=$(echo "$name_part" | tr ' -' '_' | tr -cd 'a-zA-Z0-9_')
    [[ "$verbose" == true ]] && echo "  After sanitization: $sanitized_name_part"

    # Apply case conversion if requested
    if [[ "$use_lower" == true ]]; then
        sanitized_name_part=$(echo "$sanitized_name_part" | tr '[:upper:]' '[:lower:]')
        extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')
        [[ "$verbose" == true ]] && echo "  After lowercase: $sanitized_name_part$extension"
    elif [[ "$use_upper" == true ]]; then
        sanitized_name_part=$(echo "$sanitized_name_part" | tr '[:lower:]' '[:upper:]')
        extension=$(echo "$extension" | tr '[:lower:]' '[:upper:]')
        [[ "$verbose" == true ]] && echo "  After uppercase: $sanitized_name_part$extension"
    fi

    # Apply prepend string if specified
    if [[ -n "$prepend_str" ]]; then
        sanitized_name_part="${prepend_str}${sanitized_name_part}"
        [[ "$verbose" == true ]] && echo "  After prepend: $sanitized_name_part"
    fi

    # Apply append string if specified (before extension)
    if [[ -n "$append_str" ]]; then
        sanitized_name_part="${sanitized_name_part}${append_str}"
        [[ "$verbose" == true ]] && echo "  After append: $sanitized_name_part"
    fi

    # Combine sanitized basename with original extension (if keeping extension)
    sanitized_filename="${sanitized_name_part}${extension}"
    [[ "$verbose" == true ]] && echo "  Final filename: $sanitized_filename"

    # Compare against appropriate original name
    original_for_comparison="$file_basename"
    if [[ "$remove_extension" == true && "$file_basename" == *.* ]]; then
        original_for_comparison="${file_basename%.*}"
    fi
    
    # Check if the sanitized name is effectively the same as the original
    if [[ "$original_for_comparison" == "${sanitized_filename%.*}" && "$extension" == "" && "$remove_extension" == true ]] || 
       [[ "$file_basename" == "$sanitized_filename" && "$remove_extension" == false ]]; then
        [[ "$verbose" == true ]] && echo "  No changes needed - name is already safe"
        if [[ "$modify_files" == true ]]; then
            echo "File already has a safe name: '$file_basename'" >&2
        else
            echo "$filename -> $sanitized_filename"
        fi
        continue
    fi

    # Handle file modification (rename or copy)
    if [[ "$modify_files" == true ]]; then
        # Determine the target path
        if [[ -n "$output_dir" ]]; then
            # Use the output directory specified
            new_path="${output_dir}${sanitized_filename}"
        else
            # Use the original directory
            dir=$(dirname "$filename")
            new_path="${dir}/${sanitized_filename}"
        fi
        
        # Check if confirmation is needed
        if [[ "$confirm_mode" == true ]]; then
            # Show what will happen and ask for confirmation
            if [[ "$copy_mode" == true ]]; then
                echo -n "Copy '$filename' to '$new_path'? [y/N] "
            else
                echo -n "Rename '$filename' to '$new_path'? [y/N] "
            fi
            
            read -r response
            if [[ ! "$response" =~ ^[Yy]$ ]]; then
                echo "Skipped: $filename"
                continue
            fi
        fi
        
        # Perform the rename or copy operation
        if [[ "$dry_run" == true ]]; then
            # Just show the command that would be executed
            if [[ "$copy_mode" == true ]]; then
                echo "cp -v \"$filename\" \"$new_path\""
            else
                echo "mv -v \"$filename\" \"$new_path\""
            fi
        else
            # Actually perform the operation
            if [[ "$copy_mode" == true ]]; then
                # Copy file
                cp -v "$filename" "$new_path"
            else
                # Move file
                mv -v "$filename" "$new_path"
            fi
        fi
    else
        # Just output the sanitized filename
        echo "$filename -> $sanitized_filename"
    fi
done