#!/bin/bash

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail

# Screen recording script using FFmpeg with X11 grab
# Supports full screen, window recording, and audio capture

# Check if running under Wayland
if [[ "${XDG_SESSION_TYPE}" == "wayland" ]] || [[ -n "${WAYLAND_DISPLAY:-}" ]]; then
    echo "Error: This script requires X11. It does not support Wayland."
    echo "Please run this script in an X11 session."
    exit 1
fi

# Default values
OUTPUT_DIR="."
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
OUTPUT_FILE=""
FRAMERATE=30
AUDIO_DEVICE=""
RECORD_AUDIO=false
VIDEO_CODEC="h265"
AUDIO_CODEC="vorbis"
CAMERA_DEVICE=""
SHOW_CAMERA=false
MPV_PID=""

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to display usage
usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

Screen recording utility using FFmpeg with X11 grab

OPTIONS:
    --screen <monitor>         Record a specific monitor (e.g., eDP-1, HDMI-1)
                              (default: primary display if not specified)
    --window                   Select a window to record by clicking on it
    --window-id <id>           Record a specific window by its ID
    --audio <device>           Record audio from specified PulseAudio device
    --camera <device>          Show camera preview during recording (e.g., /dev/video0)
    --preview-camera <device>  Preview camera without recording (standalone mode)
    --video-codec <codec>      Video codec: h265 (default), h264, vp9, av1, gif
    --audio-codec <codec>      Audio codec: vorbis (default), mp3, aac, opus
    --list-displays            List available displays
    --list-windows             List all windows with their IDs
    --list-audio               List available audio input devices
    --list-cameras             List available camera devices
    --output <path>            Specify output file path (default: ./screen-recording-<timestamp>.mkv)
    --framerate <fps>          Set recording framerate (default: 30)
    -h, --help                 Show this help message

EXAMPLES:
    # Record primary display (default)
    $(basename "$0")

    # Record specific monitor
    $(basename "$0") --screen HDMI-1

    # Record a window (click to select)
    $(basename "$0") --window

    # Record with audio
    $(basename "$0") --screen eDP-1 --audio alsa_input.pci-0000_00_1f.3.analog-stereo

    # Record with H.264 video and MP3 audio
    $(basename "$0") --video-codec h264 --audio-codec mp3 --audio default

    # Record as animated GIF
    $(basename "$0") --video-codec gif --framerate 10

    # Record with camera preview
    $(basename "$0") --screen eDP-1 --camera /dev/video0 --audio default

    # Preview camera before recording
    $(basename "$0") --preview-camera /dev/video0

    # List available displays
    $(basename "$0") --list-displays

EOF
}

# Function to list available displays
list_displays() {
    echo -e "${GREEN}Available displays:${NC}"
    xrandr --query | grep " connected" | awk '{print "  " $1 " - " $3}'
}

# Function to list audio devices
list_audio() {
    echo -e "${GREEN}Available audio input devices:${NC}"
    pactl list sources short | grep -E '(input|monitor)' | awk '{print "  " $2}'
}

# Function to list windows
list_windows() {
    echo -e "${GREEN}Available windows:${NC}"
    # Get all windows with their names
    wmctrl -l | while read -r line; do
        window_id=$(echo "$line" | awk '{print $1}')
        window_name=$(echo "$line" | cut -d' ' -f5-)
        echo "  Window ID: $window_id - $window_name"
    done
}

# Function to list camera devices
list_cameras() {
    echo -e "${GREEN}Available camera devices:${NC}"
    # List v4l2 devices
    for device in /dev/video*; do
        if [[ -e "$device" ]]; then
            # Try to get device name
            local name=$(v4l2-ctl --device="$device" --info 2>/dev/null | grep "Card type" | cut -d: -f2 | xargs)
            if [[ -n "$name" ]]; then
                echo "  $device - $name"
            else
                echo "  $device"
            fi
        fi
    done
    
    if ! ls /dev/video* &>/dev/null; then
        echo "  No camera devices found"
    fi
}

# Function to get display geometry
get_display_geometry() {
    local display="$1"
    xrandr --query | grep "^${display} " | grep -oP '\d+x\d+\+\d+\+\d+' | head -1
}

# Function to get window info using xwininfo
get_window_info() {
    echo -e "${YELLOW}Click on the window you want to record...${NC}" >&2
    local info=$(xwininfo)
    local id=$(echo "$info" | grep "Window id:" | awk '{print $3}')
    local x=$(echo "$info" | grep "Absolute upper-left X:" | awk '{print $NF}')
    local y=$(echo "$info" | grep "Absolute upper-left Y:" | awk '{print $NF}')
    local w=$(echo "$info" | grep "Width:" | awk '{print $NF}')
    local h=$(echo "$info" | grep "Height:" | awk '{print $NF}')
    echo "$id $x $y $w $h"
}

# Function to start camera preview
start_camera_preview() {
    local camera="$1"
    local standalone="${2:-false}"
    echo -e "${GREEN}Starting camera preview: $camera${NC}"
    
    # Start mpv with camera feed
    # Use different settings for standalone vs recording mode
    if [[ "$standalone" == "true" ]]; then
        # Standalone preview - larger window, centered, with controls
        mpv --demuxer-lavf-format=video4linux2 \
            --demuxer-lavf-o-set=input_format=mjpeg \
            "av://v4l2:$camera" \
            --profile=low-latency \
            --untimed \
            --no-cache \
            --title="Camera Preview - $camera" \
            --geometry=640x480 \
            --osc=yes
    else
        # Recording mode - small window, top-left, minimal UI
        mpv --demuxer-lavf-format=video4linux2 \
            --demuxer-lavf-o-set=input_format=mjpeg \
            "av://v4l2:$camera" \
            --profile=low-latency \
            --untimed \
            --no-cache \
            --title="Camera Preview" \
            --geometry=320x240+10+10 \
            --ontop \
            --no-osc \
            --no-input-default-bindings \
            --input-ipc-server=/tmp/mpv-camera-$$ \
            > /dev/null 2>&1 &
        
        MPV_PID=$!
        
        # Give mpv a moment to start
        sleep 0.5
        
        # Check if mpv started successfully
        if ! kill -0 $MPV_PID 2>/dev/null; then
            echo -e "${RED}Warning: Failed to start camera preview${NC}"
            MPV_PID=""
        fi
    fi
}

# Function to stop camera preview
stop_camera_preview() {
    if [[ -n "$MPV_PID" ]] && kill -0 $MPV_PID 2>/dev/null; then
        echo -e "${YELLOW}Stopping camera preview...${NC}"
        kill $MPV_PID 2>/dev/null
        wait $MPV_PID 2>/dev/null
    fi
}

# Cleanup function
cleanup() {
    stop_camera_preview
    exit 0
}

# Set up signal handlers
trap cleanup EXIT INT TERM

# Function to record screen
record_screen() {
    local ffmpeg_cmd="ffmpeg"
    local video_input=""
    local audio_input=""
    local target_display=""
    
    # Determine which display to record
    if [[ -n "${SCREEN:-}" ]]; then
        # User specified a display
        target_display="$SCREEN"
    elif [[ -z "${WINDOW_MODE:-}" ]] && [[ -z "${WINDOW_ID:-}" ]]; then
        # No window mode and no screen specified - use primary display
        target_display=$(xrandr --query | grep " connected primary" | awk '{print $1}')
        if [[ -z "$target_display" ]]; then
            target_display=$(xrandr --query | grep " connected" | head -1 | awk '{print $1}')
        fi
        echo -e "${GREEN}Recording primary display: ${target_display}${NC}"
    fi
    
    # Build video input based on mode
    if [[ -n "$target_display" ]]; then
        # Screen recording (either specified or default primary)
        local geometry=$(get_display_geometry "$target_display")
        if [[ -z "$geometry" ]]; then
            echo -e "${RED}Error: Display '$target_display' not found${NC}"
            exit 1
        fi
        
        # Parse geometry (WIDTHxHEIGHT+X+Y)
        local resolution=$(echo "$geometry" | cut -d'+' -f1)
        local x_offset=$(echo "$geometry" | cut -d'+' -f2)
        local y_offset=$(echo "$geometry" | cut -d'+' -f3)
        
        video_input="-f x11grab -framerate ${FRAMERATE} -video_size ${resolution} -i :0.0+${x_offset},${y_offset}"
        
    elif [[ -n "${WINDOW_MODE:-}" ]] || [[ -n "${WINDOW_ID:-}" ]]; then
        # Window recording
        local window_info
        
        if [[ -n "${WINDOW_ID:-}" ]]; then
            # Get window info from ID
            window_info=$(xwininfo -id "$WINDOW_ID" 2>/dev/null | grep -E "Absolute upper-left X:|Absolute upper-left Y:|Width:|Height:" | \
                awk '
                    /Absolute upper-left X:/ {x=$4}
                    /Absolute upper-left Y:/ {y=$4}
                    /Width:/ {w=$2}
                    /Height:/ {h=$2}
                    END {print x " " y " " w " " h}
                ')
            if [[ -z "$window_info" ]]; then
                echo -e "${RED}Error: Window ID '$WINDOW_ID' not found${NC}"
                exit 1
            fi
            window_info="${WINDOW_ID} ${window_info}"
        else
            # Interactive window selection
            window_info=$(get_window_info)
        fi
        
        # Parse window info
        local win_id=$(echo "$window_info" | awk '{print $1}')
        local x=$(echo "$window_info" | awk '{print $2}')
        local y=$(echo "$window_info" | awk '{print $3}')
        local w=$(echo "$window_info" | awk '{print $4}')
        local h=$(echo "$window_info" | awk '{print $5}')
        
        echo -e "${GREEN}Recording window: ${win_id}${NC}"
        echo "  Position: ${x},${y}"
        echo "  Size: ${w}x${h}"
        
        video_input="-f x11grab -framerate ${FRAMERATE} -video_size ${w}x${h} -i :0.0+${x},${y}"
    fi
    
    # Build audio input if specified
    if [[ "$RECORD_AUDIO" == true ]] && [[ -n "$AUDIO_DEVICE" ]]; then
        audio_input="-f pulse -i ${AUDIO_DEVICE}"
    fi
    
    # Determine video codec settings
    local video_codec_options=""
    case "$VIDEO_CODEC" in
        h265)
            video_codec_options="-c:v libx265 -crf 23 -preset medium"
            ;;
        h264)
            video_codec_options="-c:v libx264 -crf 23 -preset medium"
            ;;
        vp9)
            video_codec_options="-c:v libvpx-vp9 -crf 30 -b:v 0"
            ;;
        av1)
            video_codec_options="-c:v libaom-av1 -crf 30 -b:v 0 -strict experimental"
            ;;
        gif)
            # For GIF output, we need special processing
            video_codec_options="-vf \"fps=${FRAMERATE},scale=640:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse\" -loop 0"
            ;;
        *)
            echo -e "${RED}Error: Invalid video codec '$VIDEO_CODEC'${NC}"
            echo "Valid options: h265, h264, vp9, av1, gif"
            exit 1
            ;;
    esac
    
    # Build complete FFmpeg command
    local ffmpeg_full_cmd="${ffmpeg_cmd} ${video_input} ${audio_input} ${video_codec_options}"
    
    # Add audio codec if recording audio (but not for GIF)
    if [[ "$RECORD_AUDIO" == true ]] && [[ "$VIDEO_CODEC" != "gif" ]]; then
        local audio_codec_options=""
        case "$AUDIO_CODEC" in
            vorbis)
                audio_codec_options="-c:a libvorbis -q:a 5"
                ;;
            mp3)
                audio_codec_options="-c:a libmp3lame -b:a 192k"
                ;;
            aac)
                audio_codec_options="-c:a aac -b:a 192k"
                ;;
            opus)
                audio_codec_options="-c:a libopus -b:a 128k"
                ;;
            *)
                echo -e "${RED}Error: Invalid audio codec '$AUDIO_CODEC'${NC}"
                echo "Valid options: vorbis, mp3, aac, opus"
                exit 1
                ;;
        esac
        ffmpeg_full_cmd="${ffmpeg_full_cmd} ${audio_codec_options}"
    fi
    
    # Set default output filename based on codec
    if [[ -z "$OUTPUT_FILE" ]]; then
        if [[ "$VIDEO_CODEC" == "gif" ]]; then
            OUTPUT_FILE="${OUTPUT_DIR}/screen-recording-${TIMESTAMP}.gif"
        else
            OUTPUT_FILE="${OUTPUT_DIR}/screen-recording-${TIMESTAMP}.mkv"
        fi
    fi
    
    ffmpeg_full_cmd="${ffmpeg_full_cmd} \"${OUTPUT_FILE}\""
    
    # Start camera preview if requested
    if [[ "$SHOW_CAMERA" == true ]] && [[ -n "$CAMERA_DEVICE" ]]; then
        start_camera_preview "$CAMERA_DEVICE"
    fi
    
    echo -e "${GREEN}Starting recording...${NC}"
    echo "Output file: ${OUTPUT_FILE}"
    echo "Press Ctrl+C to stop recording"
    echo
    echo "Command: ${ffmpeg_full_cmd}"
    echo
    
    # Execute FFmpeg command
    eval "${ffmpeg_full_cmd}"
    
    # Stop camera preview when recording ends
    stop_camera_preview
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --screen)
            SCREEN="$2"
            shift 2
            ;;
        --window)
            WINDOW_MODE=true
            shift
            ;;
        --window-id)
            WINDOW_ID="$2"
            shift 2
            ;;
        --audio)
            RECORD_AUDIO=true
            AUDIO_DEVICE="$2"
            shift 2
            ;;
        --camera)
            SHOW_CAMERA=true
            CAMERA_DEVICE="$2"
            shift 2
            ;;
        --video-codec)
            VIDEO_CODEC="$2"
            shift 2
            ;;
        --audio-codec)
            AUDIO_CODEC="$2"
            shift 2
            ;;
        --list-displays)
            list_displays
            exit 0
            ;;
        --list-windows)
            list_windows
            exit 0
            ;;
        --list-audio)
            list_audio
            exit 0
            ;;
        --list-cameras)
            list_cameras
            exit 0
            ;;
        --preview-camera)
            if [[ -z "$2" ]] || [[ "$2" == --* ]]; then
                echo -e "${RED}Error: --preview-camera requires a device argument${NC}"
                exit 1
            fi
            # Check for mpv
            if ! command -v mpv &> /dev/null; then
                echo -e "${RED}Error: mpv is not installed (needed for camera preview)${NC}"
                exit 1
            fi
            start_camera_preview "$2" true
            exit 0
            ;;
        --output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        --framerate)
            FRAMERATE="$2"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            usage
            exit 1
            ;;
    esac
done

# Check dependencies
for cmd in ffmpeg xrandr xwininfo; do
    if ! command -v "$cmd" &> /dev/null; then
        echo -e "${RED}Error: $cmd is not installed${NC}"
        exit 1
    fi
done

# Check for pactl if audio recording is requested
if [[ "$RECORD_AUDIO" == true ]] && ! command -v pactl &> /dev/null; then
    echo -e "${RED}Error: pactl is not installed (needed for audio recording)${NC}"
    exit 1
fi

# Check for wmctrl if listing windows
if [[ "${LIST_WINDOWS:-}" == true ]] && ! command -v wmctrl &> /dev/null; then
    echo -e "${RED}Warning: wmctrl is not installed (needed for listing windows)${NC}"
fi

# Check for mpv if camera preview is requested
if [[ "$SHOW_CAMERA" == true ]] && ! command -v mpv &> /dev/null; then
    echo -e "${RED}Error: mpv is not installed (needed for camera preview)${NC}"
    exit 1
fi

# Start recording
record_screen