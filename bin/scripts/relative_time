#!/usr/bin/env python3
# dotfiles - Personal configuration files and scripts
# Copyright (C) 2024  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""Convert timestamp to relative description (e.g., '2 hours ago')."""

import sys
import argparse
from datetime import datetime, timezone


def relative_time(timestamp_str: str, precise: bool = False) -> str:
	"""Convert timestamp to relative time string."""
	try:
		# Try parsing as ISO format first
		try:
			if "T" in timestamp_str or " " in timestamp_str:
				timestamp = datetime.fromisoformat(timestamp_str.replace("Z", "+00:00"))
			else:
				# Assume YYYY-MM-DD format
				timestamp = datetime.strptime(timestamp_str, "%Y-%m-%d")
				timestamp = timestamp.replace(tzinfo=timezone.utc)
		except ValueError:
			# Try parsing as epoch timestamp
			timestamp = datetime.fromtimestamp(float(timestamp_str), tz=timezone.utc)

		now = datetime.now(timezone.utc)
		delta = now - timestamp

		if delta.total_seconds() < 0:
			# Future time
			delta = timestamp - now
			future = True
		else:
			future = False

		seconds = int(delta.total_seconds())

		if seconds < 60:
			result = f"{seconds} second{'s' if seconds != 1 else ''}"
		elif seconds < 3600:
			minutes = seconds // 60
			result = f"{minutes} minute{'s' if minutes != 1 else ''}"
		elif seconds < 86400:
			hours = seconds // 3600
			if precise:
				minutes = (seconds % 3600) // 60
				result = f"{hours} hour{'s' if hours != 1 else ''}, {minutes} minute{'s' if minutes != 1 else ''}"
			else:
				result = f"{hours} hour{'s' if hours != 1 else ''}"
		elif seconds < 2592000:  # 30 days
			days = seconds // 86400
			if precise:
				hours = (seconds % 86400) // 3600
				result = f"{days} day{'s' if days != 1 else ''}, {hours} hour{'s' if hours != 1 else ''}"
			else:
				result = f"{days} day{'s' if days != 1 else ''}"
		elif seconds < 31536000:  # 365 days
			months = seconds // 2592000
			result = f"{months} month{'s' if months != 1 else ''}"
		else:
			years = seconds // 31536000
			result = f"{years} year{'s' if years != 1 else ''}"

		if future:
			return f"in {result}"
		else:
			return f"{result} ago"

	except (ValueError, OverflowError) as e:
		return f"Error: invalid timestamp format"


def main() -> int:
	parser = argparse.ArgumentParser(description="Convert timestamp to relative time")
	parser.add_argument(
		"--epoch",
		action="store_true",
		help="Input is Unix timestamp"
	)
	parser.add_argument(
		"--precise",
		action="store_true",
		help="More detail (e.g., '2 hours, 34 minutes ago')"
	)
	args = parser.parse_args()

	for line in sys.stdin:
		line = line.rstrip("\n")
		if line:
			print(relative_time(line, precise=args.precise))

	return 0


if __name__ == "__main__":
	sys.exit(main())
