#!/usr/bin/python3

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
md_table_split - Split markdown tables by criteria or row count

Usage:
  md_table_split --by column_name --output-dir ./split_tables/
  md_table_split --rows 100 --prefix chunk_
  cat table.md | md_table_split --by category --output-dir ./categories/
  
Split methods:
  --by column_name        Split by unique values in specified column
  --rows N               Split into chunks of N rows each
  --values val1,val2      Split by specific values in column (with --by)
  
Options:
  --output-dir DIR       Directory to save split files (default: current)
  --prefix PREFIX        Prefix for output filenames (default: table_)
  --no-header           Don't include header in each split file
  --dry-run             Show what would be created without writing files

Examples:
  md_table_split --by category --output-dir ./split_tables/
  md_table_split --rows 100 --prefix chunk_ --output-dir ./chunks/
  md_table_split --by status --values active,inactive
  md_table_split --by region --prefix sales_ --no-header
"""

from os import environ
from subprocess import run
from sys import argv, exit

ctr_id: str|None = ""
if ("CONTAINER_ID" in environ):
    ctr_id = environ.get("CONTAINER_ID")

# Check if distrobox check should be skipped
no_dbox_check = environ.get("NO_DBOX_CHECK", "").lower() in ("1", "true")

# if we are not in the 'dev' distrobox re-exec the script
# inside of the 'dev' distrobox
if not no_dbox_check and ("dev" != ctr_id):
    cmd: list[str] = [
        "distrobox",
        "enter",
        "dev",
        "--",
        *argv
    ]
    run(cmd)
    exit(0)

import argparse
import re
import sys
from pathlib import Path
from typing import List, Dict, Any, Optional

# Try to import pandas with helpful error message
try:
    import pandas as pd
except ImportError:
    print("Error: Required dependencies not installed.", file=sys.stderr)
    print("Install with: pip install pandas", file=sys.stderr)
    print("Or in distrobox: distrobox enter dev -- pip install pandas", file=sys.stderr)
    sys.exit(1)

def parse_markdown_table(content: str) -> Optional[pd.DataFrame]:
    """Parse markdown table content into pandas DataFrame"""
    lines = [line.strip() for line in content.split('\n') if line.strip()]
    
    if not lines:
        return None
    
    # Find table lines (start with |)
    table_lines = [line for line in lines if line.startswith('|') and line.endswith('|')]
    
    if len(table_lines) < 2:
        return None
    
    # Parse header row
    header_line = table_lines[0]
    headers = [cell.strip() for cell in header_line.split('|')[1:-1]]  # Remove first/last empty
    
    # Find separator row (contains dashes)
    separator_idx = None
    for i, line in enumerate(table_lines[1:], 1):
        if re.match(r'^\|[\s\-\|]+\|$', line):
            separator_idx = i
            break
    
    if separator_idx is None:
        # No separator found, treat first row as data
        data_lines = table_lines
        headers = [f"Column{i+1}" for i in range(len(headers))]
        data_start = 0
    else:
        # Skip separator row
        data_lines = table_lines[separator_idx + 1:]
        data_start = separator_idx + 1
    
    if not data_lines:
        # Only headers, create empty DataFrame
        return pd.DataFrame(columns=headers)
    
    # Parse data rows
    data = []
    for line in data_lines:
        cells = [cell.strip() for cell in line.split('|')[1:-1]]  # Remove first/last empty
        
        # Pad or trim cells to match header count
        while len(cells) < len(headers):
            cells.append('')
        cells = cells[:len(headers)]
        
        # Unescape pipes in cell content
        cells = [cell.replace('\\|', '|') for cell in cells]
        
        data.append(cells)
    
    # Create DataFrame
    df = pd.DataFrame(data, columns=headers)
    return df

def dataframe_to_markdown(df: pd.DataFrame, include_header: bool = True) -> str:
    """Convert pandas DataFrame to markdown table"""
    if df.empty:
        return "| (empty table) |\n|----------------|\n"
    
    lines = []
    
    # Add header row if requested
    if include_header:
        headers = [str(col) for col in df.columns]
        lines.append("| " + " | ".join(headers) + " |")
        lines.append("|" + "|".join(["-" * (len(h) + 2) for h in headers]) + "|")
    
    # Add data rows
    for _, row in df.iterrows():
        row_data = []
        for val in row:
            # Handle different data types
            if pd.isna(val):
                row_data.append("")
            elif isinstance(val, (int, float)):
                if pd.isna(val):
                    row_data.append("")
                elif isinstance(val, float) and val.is_integer():
                    row_data.append(str(int(val)))
                else:
                    row_data.append(str(val))
            else:
                # Escape pipes in cell content
                cell_content = str(val).replace("|", "\\|")
                row_data.append(cell_content)
        
        lines.append("| " + " | ".join(row_data) + " |")
    
    return "\n".join(lines) + "\n"

def clean_filename(name: str) -> str:
    """Clean a string to make it safe for use as filename"""
    # Replace problematic characters with underscores
    clean = re.sub(r'[<>:"/\\|?*]', '_', str(name))
    # Remove or replace other special characters
    clean = re.sub(r'[^\w\-_\.]', '_', clean)
    # Collapse multiple underscores
    clean = re.sub(r'_+', '_', clean)
    # Remove leading/trailing underscores
    clean = clean.strip('_')
    # Ensure it's not empty
    if not clean:
        clean = "unnamed"
    return clean

def split_by_column(df: pd.DataFrame, column: str, values: Optional[List[str]] = None) -> Dict[str, pd.DataFrame]:
    """Split DataFrame by unique values in specified column"""
    if column not in df.columns:
        raise ValueError(f"Column '{column}' not found in table. Available columns: {list(df.columns)}")
    
    splits = {}
    
    if values:
        # Split by specific values
        for value in values:
            mask = df[column] == value
            subset = df[mask].copy()
            if not subset.empty:
                splits[str(value)] = subset
    else:
        # Split by all unique values
        unique_values = df[column].unique()
        for value in unique_values:
            if pd.notna(value):  # Skip NaN values
                mask = df[column] == value
                subset = df[mask].copy()
                if not subset.empty:
                    splits[str(value)] = subset
    
    return splits

def split_by_rows(df: pd.DataFrame, chunk_size: int) -> Dict[str, pd.DataFrame]:
    """Split DataFrame into chunks of specified row count"""
    splits = {}
    
    for i in range(0, len(df), chunk_size):
        chunk_num = (i // chunk_size) + 1
        chunk = df.iloc[i:i + chunk_size].copy()
        splits[str(chunk_num)] = chunk
    
    return splits

def write_splits(splits: Dict[str, pd.DataFrame], output_dir: Path, prefix: str, 
                include_header: bool, dry_run: bool = False) -> None:
    """Write split DataFrames to files"""
    
    if not dry_run:
        output_dir.mkdir(parents=True, exist_ok=True)
    
    for name, df in splits.items():
        safe_name = clean_filename(name)
        filename = f"{prefix}{safe_name}.md"
        filepath = output_dir / filename
        
        markdown_content = dataframe_to_markdown(df, include_header)
        
        if dry_run:
            print(f"Would create: {filepath} ({len(df)} rows)")
        else:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(markdown_content)
            print(f"Created: {filepath} ({len(df)} rows)")

def main():
    parser = argparse.ArgumentParser(
        description='Split markdown tables by criteria or row count',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Split by column values
  md_table_split --by category --output-dir ./split_tables/
  
  # Split into chunks of 100 rows
  md_table_split --rows 100 --prefix chunk_ --output-dir ./chunks/
  
  # Split by specific values
  md_table_split --by status --values active,inactive --prefix status_
  
  # Dry run to see what would be created
  md_table_split --by region --dry-run
  
  # Read from file and split
  md_table_split --input data.md --by department --output-dir ./by_dept/
        """
    )
    
    # Input/output options
    parser.add_argument('--input', '-i', help='Input markdown file (default: stdin)')
    parser.add_argument('--output-dir', '-o', default='.', 
                       help='Directory to save split files (default: current directory)')
    parser.add_argument('--prefix', '-p', default='table_', 
                       help='Prefix for output filenames (default: table_)')
    
    # Split method (mutually exclusive)
    split_group = parser.add_mutually_exclusive_group(required=True)
    split_group.add_argument('--by', '-b', 
                           help='Column name to split by (creates file for each unique value)')
    split_group.add_argument('--rows', '-r', type=int, 
                           help='Split into chunks of N rows each')
    
    # Additional options
    parser.add_argument('--values', '-v', 
                       help='Comma-separated list of specific values to split by (use with --by)')
    parser.add_argument('--no-header', action='store_true', 
                       help='Don\'t include header row in each split file')
    parser.add_argument('--dry-run', action='store_true', 
                       help='Show what would be created without writing files')
    
    args = parser.parse_args()
    
    # Validate arguments
    if args.values and not args.by:
        parser.error("--values can only be used with --by")
    
    try:
        # Read input
        if args.input:
            with open(args.input, 'r', encoding='utf-8') as f:
                content = f.read()
        else:
            content = sys.stdin.read()
        
        if not content.strip():
            print("Error: No input data provided", file=sys.stderr)
            sys.exit(1)
        
        # Parse markdown table
        df = parse_markdown_table(content)
        
        if df is None or df.empty:
            print("Error: No valid markdown table found in input", file=sys.stderr)
            sys.exit(1)
        
        print(f"Loaded table with {len(df)} rows and {len(df.columns)} columns", file=sys.stderr)
        
        # Perform split
        if args.by:
            # Parse values if provided
            values = None
            if args.values:
                values = [v.strip() for v in args.values.split(',')]
            
            splits = split_by_column(df, args.by, values)
            print(f"Split by column '{args.by}' into {len(splits)} groups", file=sys.stderr)
        else:
            # Split by rows
            splits = split_by_rows(df, args.rows)
            print(f"Split into {len(splits)} chunks of up to {args.rows} rows each", file=sys.stderr)
        
        # Write splits
        output_dir = Path(args.output_dir)
        include_header = not args.no_header
        
        write_splits(splits, output_dir, args.prefix, include_header, args.dry_run)
        
        if not args.dry_run:
            print(f"Split complete. Files written to: {output_dir.absolute()}", file=sys.stderr)
        
    except KeyboardInterrupt:
        sys.exit(1)
    except FileNotFoundError as e:
        print(f"Error: File not found: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()