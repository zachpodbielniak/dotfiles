#!/usr/bin/python3

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
md_table_pretty - Pretty print and align markdown tables

Usage:
  md_table_pretty < table.md
  md_table_pretty --input table.md --output pretty.md
  md_table_pretty --render < table.md
  cat table.md | md_table_pretty --alignment left,center,right
  
Features:
  - Automatically aligns table columns for better readability
  - Preserves table content while fixing formatting
  - Optional rich library rendering for CLI display
  - Customizable column alignment
  - Handles escaped pipes and special characters
  
Options:
  --render             Use rich library to render table in CLI
  --alignment LIST     Column alignments: left,center,right (comma-separated)
  --padding N          Cell padding spaces (default: 1)
  --output FILE        Write output to file instead of stdout
  --input FILE         Read input from file instead of stdin

Examples:
  md_table_pretty < messy_table.md > clean_table.md
  md_table_pretty --render --alignment left,center,right < data.md
  md_table_pretty --padding 2 --output formatted.md < input.md
"""

from os import environ
from subprocess import run
from sys import argv, exit

ctr_id: str|None = ""
if ("CONTAINER_ID" in environ):
    ctr_id = environ.get("CONTAINER_ID")

# Check if distrobox check should be skipped
no_dbox_check = environ.get("NO_DBOX_CHECK", "").lower() in ("1", "true")

# if we are not in the 'dev' distrobox re-exec the script
# inside of the 'dev' distrobox
if not no_dbox_check and ("dev" != ctr_id):
    cmd: list[str] = [
        "distrobox",
        "enter",
        "dev",
        "--",
        *argv
    ]
    run(cmd)
    exit(0)

import argparse
import re
import sys
from typing import List, Dict, Optional, Tuple
from textwrap import wrap

def parse_markdown_table(content: str) -> Optional[Tuple[List[str], List[List[str]]]]:
    """Parse markdown table content into headers and data rows"""
    lines = [line.strip() for line in content.split('\n') if line.strip()]
    
    if not lines:
        return None
    
    # Find table lines (start with |)
    table_lines = [line for line in lines if line.startswith('|') and line.endswith('|')]
    
    if len(table_lines) < 2:
        return None
    
    # Parse header row
    header_line = table_lines[0]
    headers = [cell.strip() for cell in header_line.split('|')[1:-1]]  # Remove first/last empty
    
    # Find separator row (contains dashes)
    separator_idx = None
    alignments = []
    for i, line in enumerate(table_lines[1:], 1):
        if re.match(r'^\|[\s\-\|:]+\|$', line):
            separator_idx = i
            # Parse alignment from separator
            separator_cells = [cell.strip() for cell in line.split('|')[1:-1]]
            for cell in separator_cells:
                if cell.startswith(':') and cell.endswith(':'):
                    alignments.append('center')
                elif cell.endswith(':'):
                    alignments.append('right')
                else:
                    alignments.append('left')
            break
    
    if separator_idx is None:
        # No separator found, treat first row as data and create default headers
        data_lines = table_lines
        headers = [f"Column{i+1}" for i in range(len(headers))]
        data_start = 0
        alignments = ['left'] * len(headers)
    else:
        # Skip separator row
        data_lines = table_lines[separator_idx + 1:]
        data_start = separator_idx + 1
    
    if not data_lines:
        # Only headers, create empty data
        return headers, [], alignments
    
    # Parse data rows
    data = []
    for line in data_lines:
        cells = [cell.strip() for cell in line.split('|')[1:-1]]  # Remove first/last empty
        
        # Pad or trim cells to match header count
        while len(cells) < len(headers):
            cells.append('')
        cells = cells[:len(headers)]
        
        # Unescape pipes in cell content
        cells = [cell.replace('\\|', '|') for cell in cells]
        
        data.append(cells)
    
    # Ensure alignments match header count
    while len(alignments) < len(headers):
        alignments.append('left')
    alignments = alignments[:len(headers)]
    
    return headers, data, alignments

def calculate_column_widths(headers: List[str], data: List[List[str]], padding: int = 1) -> List[int]:
    """Calculate the width needed for each column"""
    if not headers:
        return []
    
    # Start with header widths
    widths = [len(header) for header in headers]
    
    # Check data row widths
    for row in data:
        for i, cell in enumerate(row):
            if i < len(widths):
                widths[i] = max(widths[i], len(str(cell)))
    
    # Add padding
    widths = [w + (padding * 2) for w in widths]
    
    return widths

def format_cell(content: str, width: int, alignment: str, padding: int = 1) -> str:
    """Format a single cell with proper alignment and padding"""
    content = str(content)
    available_width = width - (padding * 2)
    
    if len(content) > available_width:
        # Truncate if too long
        content = content[:available_width-3] + "..."
    
    if alignment == 'center':
        content = content.center(available_width)
    elif alignment == 'right':
        content = content.rjust(available_width)
    else:  # left
        content = content.ljust(available_width)
    
    return ' ' * padding + content + ' ' * padding

def create_separator_row(widths: List[int], alignments: List[str]) -> str:
    """Create the separator row with proper alignment indicators"""
    separator_cells = []
    
    for width, alignment in zip(widths, alignments):
        dashes = '-' * (width - 2)  # Account for potential colons
        
        if alignment == 'center':
            cell = f":{dashes}:"
        elif alignment == 'right':
            cell = f"{dashes}:"
        else:  # left
            cell = f"{dashes}"
        
        # Pad to full width
        cell = cell.ljust(width, '-')
        separator_cells.append(cell)
    
    return '|' + '|'.join(separator_cells) + '|'

def prettify_table(headers: List[str], data: List[List[str]], alignments: List[str], 
                  custom_alignments: Optional[List[str]] = None, padding: int = 1) -> str:
    """Create a prettified markdown table"""
    if not headers:
        return ""
    
    # Use custom alignments if provided
    if custom_alignments:
        # Pad or trim to match header count
        alignments = custom_alignments[:len(headers)]
        while len(alignments) < len(headers):
            alignments.append('left')
    
    # Calculate column widths
    widths = calculate_column_widths(headers, data, padding)
    
    lines = []
    
    # Header row
    header_cells = [format_cell(header, width, alignment, padding) 
                   for header, width, alignment in zip(headers, widths, alignments)]
    lines.append('|' + '|'.join(header_cells) + '|')
    
    # Separator row
    lines.append(create_separator_row(widths, alignments))
    
    # Data rows
    for row in data:
        data_cells = [format_cell(cell, width, alignment, padding) 
                     for cell, width, alignment in zip(row, widths, alignments)]
        lines.append('|' + '|'.join(data_cells) + '|')
    
    return '\n'.join(lines)

def render_with_rich(headers: List[str], data: List[List[str]], alignments: List[str],
                    custom_alignments: Optional[List[str]] = None) -> None:
    """Render table using rich library"""
    try:
        from rich.console import Console
        from rich.table import Table
        from rich import box
    except ImportError:
        print("Error: rich library not installed.", file=sys.stderr)
        print("Install with: pip install rich", file=sys.stderr)
        print("Or in distrobox: distrobox enter dev -- pip install rich", file=sys.stderr)
        sys.exit(1)
    
    # Use custom alignments if provided
    if custom_alignments:
        alignments = custom_alignments[:len(headers)]
        while len(alignments) < len(headers):
            alignments.append('left')
    
    console = Console()
    table = Table(box=box.MARKDOWN)
    
    # Add columns with proper alignment
    for header, alignment in zip(headers, alignments):
        justify = alignment if alignment in ['left', 'center', 'right'] else 'left'
        table.add_column(header, justify=justify)
    
    # Add data rows
    for row in data:
        # Ensure row has same number of cells as headers
        padded_row = row[:len(headers)]
        while len(padded_row) < len(headers):
            padded_row.append('')
        table.add_row(*[str(cell) for cell in padded_row])
    
    console.print(table)

def main():
    parser = argparse.ArgumentParser(
        description='Pretty print and align markdown tables',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic table prettification
  md_table_pretty < messy_table.md > clean_table.md
  
  # Render with rich library
  md_table_pretty --render < data.md
  
  # Custom column alignments
  md_table_pretty --alignment left,center,right < table.md
  
  # Custom padding and output file
  md_table_pretty --padding 2 --output formatted.md < input.md
        """
    )
    
    # Input/output options
    parser.add_argument('--input', '-i', help='Input markdown file (default: stdin)')
    parser.add_argument('--output', '-o', help='Output file (default: stdout)')
    parser.add_argument('--render', '-r', action='store_true', 
                       help='Use rich library to render table in CLI')
    
    # Formatting options
    parser.add_argument('--alignment', '-a', 
                       help='Column alignments: left,center,right (comma-separated)')
    parser.add_argument('--padding', '-p', type=int, default=1,
                       help='Cell padding spaces (default: 1)')
    
    args = parser.parse_args()
    
    try:
        # Read input
        if args.input:
            with open(args.input, 'r', encoding='utf-8') as f:
                content = f.read()
        else:
            content = sys.stdin.read()
        
        if not content.strip():
            print("Error: No input data provided", file=sys.stderr)
            sys.exit(1)
        
        # Parse markdown table
        result = parse_markdown_table(content)
        
        if result is None:
            print("Error: No valid markdown table found in input", file=sys.stderr)
            sys.exit(1)
        
        headers, data, alignments = result
        
        if not headers:
            print("Error: Empty table found", file=sys.stderr)
            sys.exit(1)
        
        # Parse custom alignments
        custom_alignments = None
        if args.alignment:
            try:
                custom_alignments = [align.strip().lower() for align in args.alignment.split(',')]
                # Validate alignments
                valid_alignments = ['left', 'center', 'right']
                for align in custom_alignments:
                    if align not in valid_alignments:
                        print(f"Error: Invalid alignment '{align}'. Use: left, center, or right", file=sys.stderr)
                        sys.exit(1)
            except ValueError:
                print("Error: Invalid alignment format. Use comma-separated values (e.g., left,center,right)", file=sys.stderr)
                sys.exit(1)
        
        # Render or format output
        if args.render:
            render_with_rich(headers, data, alignments, custom_alignments)
        else:
            output = prettify_table(headers, data, alignments, custom_alignments, args.padding)
            
            # Write output
            if args.output:
                with open(args.output, 'w', encoding='utf-8') as f:
                    f.write(output)
                    f.write('\n')
                print(f"Prettified table written to: {args.output}", file=sys.stderr)
            else:
                print(output)
        
    except KeyboardInterrupt:
        sys.exit(1)
    except FileNotFoundError as e:
        print(f"Error: File not found: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()