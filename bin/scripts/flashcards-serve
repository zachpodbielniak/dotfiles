#!/usr/bin/python3

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
flashcards-serve - Web UI for flashcard review and administration

Provides a web interface for:
- Reviewing flashcards with flip animation
- Generating flashcards from notes or pasted content
- Managing cards (edit, delete, bulk operations)
- Viewing statistics
"""

import os
import subprocess
import sys

# Container check for distrobox - do this BEFORE any other imports
ctr_id = os.environ.get("CONTAINER_ID", "")
no_dbox_check = os.environ.get("NO_DBOX_CHECK", "").lower() in ("1", "true")

if not no_dbox_check and ctr_id != "dev":
	cmd = ["distrobox", "enter", "dev", "--", *sys.argv]
	subprocess.run(cmd)
	sys.exit(0)

# Now import everything else inside the dev container
import argparse
import asyncio
import json
import random
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any

try:
	from quart import Quart, request, jsonify, redirect, url_for, make_response
except ImportError:
	print("Error: quart required. Install with: pip install quart", file=sys.stderr)
	sys.exit(1)

try:
	import psycopg2
	from psycopg2.extras import RealDictCursor
except ImportError:
	print("Error: psycopg2 required. Install with: pip install psycopg2-binary", file=sys.stderr)
	sys.exit(1)

try:
	import markdown
except ImportError:
	markdown = None


# ============================================================================
# CONFIGURATION
# ============================================================================

DB_HOST: str = os.environ.get("FLASHCARDS_DB_HOST", "127.0.0.1")
DB_PORT: int = int(os.environ.get("FLASHCARDS_DB_PORT", "5432"))
DB_NAME: str = os.environ.get("FLASHCARDS_DB_NAME", "flashcards")
DB_USER: str = os.environ.get("FLASHCARDS_DB_USER", "postgres")
DB_PASSWORD: str = os.environ.get("FLASHCARDS_DB_PASSWORD", "")

NOTES_DB_HOST: str = os.environ.get("NOTES_DB_HOST", "127.0.0.1")
NOTES_DB_PORT: int = int(os.environ.get("NOTES_DB_PORT", "5432"))
NOTES_DB_NAME: str = os.environ.get("NOTES_DB_NAME", "notes")
NOTES_DB_USER: str = os.environ.get("NOTES_DB_USER", "postgres")
NOTES_DB_PASSWORD: str = os.environ.get("NOTES_DB_PASSWORD", "")


# ============================================================================
# DATA CLASSES
# ============================================================================

@dataclass
class Flashcard:
	"""Represents a flashcard."""
	id: str
	note_path: str
	question: str
	answer: str
	topic: Optional[str] = None
	note_uuid: Optional[str] = None
	difficulty: int = 2
	times_reviewed: int = 0
	times_correct: int = 0
	last_reviewed: Optional[datetime] = None
	next_review: Optional[datetime] = None
	note_mtime: Optional[datetime] = None
	created_at: Optional[datetime] = None
	updated_at: Optional[datetime] = None


@dataclass
class ReviewSession:
	"""Represents an active review session."""
	session_id: str
	card_ids: List[str]
	current_index: int = 0
	ratings: Dict[str, int] = field(default_factory=dict)
	started_at: datetime = field(default_factory=datetime.now)
	difficulty_filter: Optional[int] = None
	topic_filter: Optional[str] = None
	due_only: bool = False


# In-memory session store
REVIEW_SESSIONS: Dict[str, ReviewSession] = {}


# ============================================================================
# DATABASE LAYER
# ============================================================================

def get_flashcards_connection():
	"""Get connection to flashcards database."""
	conn_params: Dict[str, Any] = {
		"host": DB_HOST,
		"port": DB_PORT,
		"dbname": DB_NAME,
		"user": DB_USER,
	}
	if DB_PASSWORD:
		conn_params["password"] = DB_PASSWORD
	return psycopg2.connect(**conn_params)


def get_notes_connection():
	"""Get connection to notes database."""
	conn_params: Dict[str, Any] = {
		"host": NOTES_DB_HOST,
		"port": NOTES_DB_PORT,
		"dbname": NOTES_DB_NAME,
		"user": NOTES_DB_USER,
	}
	if NOTES_DB_PASSWORD:
		conn_params["password"] = NOTES_DB_PASSWORD
	return psycopg2.connect(**conn_params)


def db_get_cards(
	limit: int = 50,
	offset: int = 0,
	difficulty: Optional[int] = None,
	topic: Optional[str] = None,
	note_path: Optional[str] = None,
	search: Optional[str] = None,
) -> List[Dict[str, Any]]:
	"""Get flashcards with optional filters."""
	conditions: List[str] = []
	params: List[Any] = []

	if difficulty is not None:
		conditions.append("difficulty = %s")
		params.append(difficulty)

	if topic:
		conditions.append("topic ILIKE %s")
		params.append(f"%{topic}%")

	if note_path:
		conditions.append("note_path ILIKE %s")
		params.append(f"%{note_path}%")

	if search:
		conditions.append("(question ILIKE %s OR answer ILIKE %s)")
		params.extend([f"%{search}%", f"%{search}%"])

	where_clause: str = ""
	if conditions:
		where_clause = "WHERE " + " AND ".join(conditions)

	query: str = f"""
		SELECT id::text, note_path, note_uuid::text, question, answer, topic,
		       difficulty, times_reviewed, times_correct, last_reviewed,
		       next_review, note_mtime, created_at, updated_at
		FROM flashcards
		{where_clause}
		ORDER BY updated_at DESC
		LIMIT %s OFFSET %s
	"""
	params.extend([limit, offset])

	cards: List[Dict[str, Any]] = []
	with get_flashcards_connection() as conn:
		with conn.cursor(cursor_factory=RealDictCursor) as cur:
			cur.execute(query, params)
			cards = [dict(row) for row in cur.fetchall()]

	return cards


def db_get_card(card_id: str) -> Optional[Dict[str, Any]]:
	"""Get a single card by ID."""
	query: str = """
		SELECT id::text, note_path, note_uuid::text, question, answer, topic,
		       difficulty, times_reviewed, times_correct, last_reviewed,
		       next_review, note_mtime, created_at, updated_at
		FROM flashcards
		WHERE id::text LIKE %s
		LIMIT 1
	"""
	with get_flashcards_connection() as conn:
		with conn.cursor(cursor_factory=RealDictCursor) as cur:
			cur.execute(query, (f"{card_id}%",))
			row = cur.fetchone()
			if row:
				return dict(row)
	return None


def db_update_card(card_id: str, updates: Dict[str, Any]) -> bool:
	"""Update a card's fields."""
	if not updates:
		return False

	set_parts: List[str] = []
	params: List[Any] = []

	for key, value in updates.items():
		if key in ["question", "answer", "topic", "difficulty"]:
			set_parts.append(f"{key} = %s")
			params.append(value)

	if not set_parts:
		return False

	params.append(f"{card_id}%")
	query: str = f"UPDATE flashcards SET {', '.join(set_parts)} WHERE id::text LIKE %s"

	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			cur.execute(query, params)
			count: int = cur.rowcount
		conn.commit()

	return count > 0


def db_delete_card(card_id: str) -> bool:
	"""Delete a single card."""
	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			cur.execute("DELETE FROM flashcards WHERE id::text LIKE %s", (f"{card_id}%",))
			count: int = cur.rowcount
		conn.commit()
	return count > 0


def db_delete_cards_bulk(card_ids: List[str]) -> int:
	"""Delete multiple cards. Returns count deleted."""
	if not card_ids:
		return 0

	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			cur.execute(
				"DELETE FROM flashcards WHERE id::text = ANY(%s)",
				(card_ids,)
			)
			count: int = cur.rowcount
		conn.commit()
	return count


def db_update_cards_bulk(card_ids: List[str], updates: Dict[str, Any]) -> int:
	"""Update multiple cards. Returns count updated."""
	if not card_ids or not updates:
		return 0

	set_parts: List[str] = []
	params: List[Any] = []

	for key, value in updates.items():
		if key in ["difficulty"]:
			set_parts.append(f"{key} = %s")
			params.append(value)

	if not set_parts:
		return 0

	params.append(card_ids)
	query: str = f"UPDATE flashcards SET {', '.join(set_parts)} WHERE id::text = ANY(%s)"

	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			cur.execute(query, params)
			count: int = cur.rowcount
		conn.commit()

	return count


def db_get_stats() -> Dict[str, Any]:
	"""Get flashcard statistics."""
	stats: Dict[str, Any] = {}

	with get_flashcards_connection() as conn:
		with conn.cursor(cursor_factory=RealDictCursor) as cur:
			cur.execute("SELECT COUNT(*) as total FROM flashcards")
			stats["total_cards"] = cur.fetchone()["total"]

			cur.execute("""
				SELECT difficulty, COUNT(*) as count
				FROM flashcards
				GROUP BY difficulty
				ORDER BY difficulty
			""")
			stats["by_difficulty"] = {
				row["difficulty"]: row["count"] for row in cur.fetchall()
			}

			cur.execute("""
				SELECT COUNT(*) as due
				FROM flashcards
				WHERE next_review IS NULL OR next_review <= NOW()
			""")
			stats["due_for_review"] = cur.fetchone()["due"]

			cur.execute("SELECT SUM(times_reviewed) as total FROM flashcards")
			result = cur.fetchone()["total"]
			stats["total_reviews"] = result or 0

			cur.execute("SELECT COUNT(DISTINCT note_path) as notes FROM flashcards")
			stats["notes_with_cards"] = cur.fetchone()["notes"]

			# Topics breakdown
			cur.execute("""
				SELECT topic, COUNT(*) as count
				FROM flashcards
				WHERE topic IS NOT NULL AND topic != ''
				GROUP BY topic
				ORDER BY count DESC
				LIMIT 10
			""")
			stats["top_topics"] = [
				{"topic": row["topic"], "count": row["count"]}
				for row in cur.fetchall()
			]

	return stats


def db_get_review_cards(
	max_cards: int = 20,
	difficulty: Optional[int] = None,
	topic: Optional[str] = None,
	due_only: bool = False,
) -> List[str]:
	"""Get card IDs for review session."""
	conditions: List[str] = []
	params: List[Any] = []

	if difficulty is not None:
		conditions.append("difficulty = %s")
		params.append(difficulty)

	if topic:
		conditions.append("topic ILIKE %s")
		params.append(f"%{topic}%")

	if due_only:
		conditions.append("(next_review IS NULL OR next_review <= NOW())")

	where_clause: str = ""
	if conditions:
		where_clause = "WHERE " + " AND ".join(conditions)

	query: str = f"SELECT id::text FROM flashcards {where_clause}"

	card_ids: List[str] = []
	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			cur.execute(query, params)
			card_ids = [row[0] for row in cur.fetchall()]

	random.shuffle(card_ids)
	return card_ids[:max_cards]


def db_update_after_review(card_id: str, rating: int) -> None:
	"""Update card after review."""
	with get_flashcards_connection() as conn:
		with conn.cursor(cursor_factory=RealDictCursor) as cur:
			cur.execute(
				"SELECT times_reviewed, times_correct FROM flashcards WHERE id = %s",
				(card_id,)
			)
			row = cur.fetchone()
			if not row:
				return

			times_reviewed: int = row["times_reviewed"] + 1
			times_correct: int = row["times_correct"] + (1 if rating == 1 else 0)

			# Calculate next review
			base_intervals: Dict[int, List[int]] = {
				1: [1, 3, 7, 14, 30, 60, 120],
				2: [1, 2, 4, 8, 16, 32, 64],
				3: [1, 1, 2, 4, 8, 16, 32],
			}
			intervals: List[int] = base_intervals.get(rating, base_intervals[2])
			idx: int = min(times_correct, len(intervals) - 1)
			days: int = intervals[idx]
			next_review: datetime = datetime.now() + timedelta(days=days)

			cur.execute("""
				UPDATE flashcards
				SET times_reviewed = %s,
				    times_correct = %s,
				    difficulty = %s,
				    last_reviewed = NOW(),
				    next_review = %s
				WHERE id = %s
			""", (times_reviewed, times_correct, rating, next_review, card_id))

		conn.commit()


def db_get_recent_notes(days: int = 7, para: Optional[str] = None) -> List[Dict[str, Any]]:
	"""Get recent notes from notes database."""
	query: str = """
		SELECT id::text, path, para, category, content, last_modified
		FROM notes
		WHERE last_modified > NOW() - INTERVAL '1 day' * %s
	"""
	params: List[Any] = [days]

	if para:
		query += " AND para = %s"
		params.append(para)

	query += " ORDER BY last_modified DESC LIMIT 100"

	notes: List[Dict[str, Any]] = []
	try:
		with get_notes_connection() as conn:
			with conn.cursor(cursor_factory=RealDictCursor) as cur:
				cur.execute(query, params)
				notes = [dict(row) for row in cur.fetchall()]
	except Exception as e:
		print(f"Error fetching notes: {e}", file=sys.stderr)

	return notes


def db_insert_cards(cards: List[Dict[str, str]], note_path: str, note_uuid: Optional[str], note_mtime: datetime) -> int:
	"""Insert generated cards into database."""
	if not cards:
		return 0

	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			for card in cards:
				cur.execute("""
					INSERT INTO flashcards (note_path, note_uuid, note_mtime, topic, question, answer)
					VALUES (%s, %s, %s, %s, %s, %s)
				""", (
					note_path,
					note_uuid,
					note_mtime,
					card.get("topic"),
					card["question"],
					card["answer"],
				))
		conn.commit()

	return len(cards)


# ============================================================================
# AI GENERATION
# ============================================================================

async def run_flashcards_command(args: List[str], timeout: int = 120) -> Dict[str, Any]:
	"""Run flashcards CLI command asynchronously."""
	proc = await asyncio.create_subprocess_exec(
		"flashcards", *args,
		stdout=asyncio.subprocess.PIPE,
		stderr=asyncio.subprocess.PIPE,
		env={**os.environ, "NO_DBOX_CHECK": "1"},
	)
	try:
		stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=timeout)
		return {
			"returncode": proc.returncode,
			"stdout": stdout.decode("utf-8"),
			"stderr": stderr.decode("utf-8"),
		}
	except asyncio.TimeoutError:
		proc.kill()
		return {
			"returncode": -1,
			"stdout": "",
			"stderr": "Command timed out",
		}


# ============================================================================
# TEMPLATES: SHARED CSS
# ============================================================================

BASE_CSS: str = '''
:root {
	--bg-primary: #1e1e2e;
	--bg-secondary: #313244;
	--bg-tertiary: #45475a;
	--text-primary: #cdd6f4;
	--text-secondary: #a6adc8;
	--text-muted: #6c7086;
	--accent: #89b4fa;
	--accent-hover: #b4befe;
	--success: #a6e3a1;
	--warning: #f9e2af;
	--error: #f38ba8;
	--border: #585b70;
	--shadow: rgba(0, 0, 0, 0.3);
}

:root[data-theme="light"] {
	--bg-primary: #eff1f5;
	--bg-secondary: #e6e9ef;
	--bg-tertiary: #dce0e8;
	--text-primary: #4c4f69;
	--text-secondary: #5c5f77;
	--text-muted: #9ca0b0;
	--accent: #1e66f5;
	--accent-hover: #7287fd;
	--success: #40a02b;
	--warning: #df8e1d;
	--error: #d20f39;
	--border: #bcc0cc;
	--shadow: rgba(0, 0, 0, 0.1);
}

* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

body {
	font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
	background: var(--bg-primary);
	color: var(--text-primary);
	line-height: 1.6;
	min-height: 100vh;
}

a {
	color: var(--accent);
	text-decoration: none;
}

a:hover {
	color: var(--accent-hover);
	text-decoration: underline;
}

.container {
	max-width: 1200px;
	margin: 0 auto;
	padding: 20px;
}

.header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 16px 24px;
	background: var(--bg-secondary);
	border-bottom: 1px solid var(--border);
	margin-bottom: 24px;
}

.header h1 {
	font-size: 1.5rem;
	display: flex;
	align-items: center;
	gap: 10px;
}

.header nav {
	display: flex;
	gap: 16px;
	align-items: center;
}

.header nav a {
	padding: 8px 16px;
	border-radius: 6px;
	transition: background 0.2s;
}

.header nav a:hover {
	background: var(--bg-tertiary);
	text-decoration: none;
}

.btn {
	display: inline-flex;
	align-items: center;
	gap: 8px;
	padding: 10px 20px;
	border: none;
	border-radius: 8px;
	font-size: 14px;
	font-weight: 500;
	cursor: pointer;
	transition: all 0.2s;
}

.btn-primary {
	background: var(--accent);
	color: var(--bg-primary);
}

.btn-primary:hover {
	background: var(--accent-hover);
}

.btn-secondary {
	background: var(--bg-tertiary);
	color: var(--text-primary);
}

.btn-secondary:hover {
	background: var(--border);
}

.btn-danger {
	background: var(--error);
	color: white;
}

.btn-danger:hover {
	opacity: 0.9;
}

.btn-success {
	background: var(--success);
	color: var(--bg-primary);
}

.btn-warning {
	background: var(--warning);
	color: var(--bg-primary);
}

.btn-sm {
	padding: 6px 12px;
	font-size: 12px;
}

.card {
	background: var(--bg-secondary);
	border-radius: 12px;
	padding: 20px;
	margin-bottom: 16px;
	border: 1px solid var(--border);
}

.card-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 16px;
	padding-bottom: 12px;
	border-bottom: 1px solid var(--border);
}

.form-group {
	margin-bottom: 16px;
}

.form-group label {
	display: block;
	margin-bottom: 6px;
	font-weight: 500;
	color: var(--text-secondary);
}

.form-control {
	width: 100%;
	padding: 10px 14px;
	border: 1px solid var(--border);
	border-radius: 8px;
	background: var(--bg-primary);
	color: var(--text-primary);
	font-size: 14px;
	transition: border-color 0.2s;
}

.form-control:focus {
	outline: none;
	border-color: var(--accent);
}

textarea.form-control {
	min-height: 100px;
	resize: vertical;
}

select.form-control {
	cursor: pointer;
}

.badge {
	display: inline-block;
	padding: 4px 10px;
	border-radius: 20px;
	font-size: 12px;
	font-weight: 500;
}

.badge-easy {
	background: var(--success);
	color: var(--bg-primary);
}

.badge-medium {
	background: var(--warning);
	color: var(--bg-primary);
}

.badge-hard {
	background: var(--error);
	color: white;
}

.stats-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
	gap: 16px;
	margin-bottom: 24px;
}

.stat-card {
	background: var(--bg-secondary);
	border-radius: 12px;
	padding: 20px;
	text-align: center;
	border: 1px solid var(--border);
}

.stat-value {
	font-size: 2.5rem;
	font-weight: 700;
	color: var(--accent);
}

.stat-label {
	color: var(--text-secondary);
	font-size: 14px;
	margin-top: 4px;
}

.table-container {
	overflow-x: auto;
}

table {
	width: 100%;
	border-collapse: collapse;
}

th, td {
	padding: 12px 16px;
	text-align: left;
	border-bottom: 1px solid var(--border);
}

th {
	background: var(--bg-tertiary);
	font-weight: 600;
	color: var(--text-secondary);
}

tr:hover {
	background: var(--bg-tertiary);
}

.checkbox-cell {
	width: 40px;
}

.theme-toggle {
	background: var(--bg-tertiary);
	border: none;
	padding: 8px 12px;
	border-radius: 6px;
	cursor: pointer;
	color: var(--text-primary);
	font-size: 16px;
}

.hidden {
	display: none !important;
}

.bulk-actions {
	position: fixed;
	bottom: 20px;
	left: 50%;
	transform: translateX(-50%);
	background: var(--bg-secondary);
	padding: 16px 24px;
	border-radius: 12px;
	box-shadow: 0 4px 20px var(--shadow);
	display: flex;
	gap: 12px;
	align-items: center;
	border: 1px solid var(--border);
	z-index: 100;
}

.selected-count {
	font-weight: 600;
	color: var(--accent);
}

.tabs {
	display: flex;
	gap: 4px;
	margin-bottom: 20px;
	background: var(--bg-tertiary);
	padding: 4px;
	border-radius: 10px;
	width: fit-content;
}

.tab {
	padding: 10px 20px;
	border: none;
	background: transparent;
	color: var(--text-secondary);
	cursor: pointer;
	border-radius: 8px;
	font-weight: 500;
	transition: all 0.2s;
}

.tab.active {
	background: var(--bg-secondary);
	color: var(--text-primary);
}

.tab:hover:not(.active) {
	color: var(--text-primary);
}

.progress-bar {
	width: 100%;
	height: 8px;
	background: var(--bg-tertiary);
	border-radius: 4px;
	overflow: hidden;
	margin-bottom: 16px;
}

.progress-fill {
	height: 100%;
	background: var(--accent);
	transition: width 0.3s ease;
}

.empty-state {
	text-align: center;
	padding: 60px 20px;
	color: var(--text-muted);
}

.empty-state h3 {
	margin-bottom: 8px;
	color: var(--text-secondary);
}

.alert {
	padding: 12px 16px;
	border-radius: 8px;
	margin-bottom: 16px;
}

.alert-success {
	background: rgba(166, 227, 161, 0.2);
	border: 1px solid var(--success);
	color: var(--success);
}

.alert-error {
	background: rgba(243, 139, 168, 0.2);
	border: 1px solid var(--error);
	color: var(--error);
}

.loading {
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 40px;
}

.spinner {
	width: 40px;
	height: 40px;
	border: 3px solid var(--bg-tertiary);
	border-top-color: var(--accent);
	border-radius: 50%;
	animation: spin 0.8s linear infinite;
}

@keyframes spin {
	to { transform: rotate(360deg); }
}

@media (max-width: 768px) {
	.header {
		flex-direction: column;
		gap: 16px;
	}

	.header nav {
		flex-wrap: wrap;
		justify-content: center;
	}

	.stats-grid {
		grid-template-columns: repeat(2, 1fr);
	}
}
'''

# ============================================================================
# TEMPLATES: FLASHCARD CSS
# ============================================================================

FLASHCARD_CSS: str = '''
.flashcard-container {
	perspective: 1000px;
	width: 100%;
	max-width: 700px;
	height: 450px;
	margin: 0 auto 24px;
}

.flashcard {
	position: relative;
	width: 100%;
	height: 100%;
	transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
	transform-style: preserve-3d;
	cursor: pointer;
}

.flashcard.flipped {
	transform: rotateY(180deg);
}

.flashcard-face {
	position: absolute;
	width: 100%;
	height: 100%;
	backface-visibility: hidden;
	-webkit-backface-visibility: hidden;
	border-radius: 16px;
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	padding: 32px;
	background: var(--bg-secondary);
	border: 2px solid var(--border);
	box-shadow: 0 10px 40px var(--shadow);
}

.flashcard-front {
	background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
}

.flashcard-back {
	transform: rotateY(180deg);
	background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
}

.flashcard-label {
	position: absolute;
	top: 16px;
	left: 16px;
	font-size: 12px;
	font-weight: 600;
	color: var(--text-muted);
	text-transform: uppercase;
	letter-spacing: 1px;
}

.flashcard-content {
	font-size: 1.4rem;
	text-align: center;
	line-height: 1.6;
	max-height: 100%;
	overflow-y: auto;
}

.flashcard-meta {
	position: absolute;
	bottom: 16px;
	display: flex;
	gap: 12px;
	font-size: 12px;
	color: var(--text-muted);
}

.review-controls {
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 16px;
}

.flip-hint {
	color: var(--text-muted);
	font-size: 14px;
}

.rating-buttons {
	display: flex;
	gap: 12px;
	flex-wrap: wrap;
	justify-content: center;
}

.rating-btn {
	padding: 14px 28px;
	border: 2px solid transparent;
	border-radius: 10px;
	font-size: 16px;
	font-weight: 600;
	cursor: pointer;
	transition: all 0.2s;
}

.rating-btn:hover {
	transform: translateY(-2px);
}

.rating-easy {
	background: var(--success);
	color: var(--bg-primary);
}

.rating-easy:hover {
	box-shadow: 0 4px 20px rgba(166, 227, 161, 0.4);
}

.rating-medium {
	background: var(--warning);
	color: var(--bg-primary);
}

.rating-medium:hover {
	box-shadow: 0 4px 20px rgba(249, 226, 175, 0.4);
}

.rating-hard {
	background: var(--error);
	color: white;
}

.rating-hard:hover {
	box-shadow: 0 4px 20px rgba(243, 139, 168, 0.4);
}

.rating-skip {
	background: var(--bg-tertiary);
	color: var(--text-primary);
}

.review-progress {
	text-align: center;
	margin-bottom: 20px;
}

.review-progress-text {
	font-size: 14px;
	color: var(--text-secondary);
	margin-bottom: 8px;
}

.session-summary {
	max-width: 500px;
	margin: 0 auto;
	text-align: center;
}

.session-summary h2 {
	margin-bottom: 24px;
}

.summary-stats {
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	gap: 16px;
	margin-bottom: 24px;
}

.summary-stat {
	padding: 16px;
	background: var(--bg-tertiary);
	border-radius: 10px;
}

.summary-stat-value {
	font-size: 2rem;
	font-weight: 700;
}

.summary-stat-label {
	font-size: 12px;
	color: var(--text-muted);
}

.keyboard-shortcuts {
	display: flex;
	justify-content: center;
	gap: 20px;
	margin-top: 20px;
	font-size: 13px;
	color: var(--text-muted);
}

.keyboard-shortcuts kbd {
	display: inline-block;
	padding: 2px 8px;
	background: var(--bg-tertiary);
	border-radius: 4px;
	font-family: monospace;
	margin-right: 4px;
}
'''

# ============================================================================
# TEMPLATES: SHARED JAVASCRIPT
# ============================================================================

BASE_JS: str = '''
function toggleTheme() {
	const html = document.documentElement;
	const current = html.getAttribute('data-theme') || 'dark';
	const next = current === 'dark' ? 'light' : 'dark';
	html.setAttribute('data-theme', next);
	localStorage.setItem('theme', next);
}

// Initialize theme from localStorage
(function() {
	const saved = localStorage.getItem('theme');
	if (saved) {
		document.documentElement.setAttribute('data-theme', saved);
	}
})();

// Bulk selection
let selectedCards = new Set();

function toggleCardSelection(cardId, checkbox) {
	if (checkbox.checked) {
		selectedCards.add(cardId);
	} else {
		selectedCards.delete(cardId);
	}
	updateBulkActionsUI();
}

function selectAllCards(checkbox) {
	document.querySelectorAll('.card-checkbox').forEach(cb => {
		cb.checked = checkbox.checked;
		if (checkbox.checked) {
			selectedCards.add(cb.dataset.cardId);
		} else {
			selectedCards.delete(cb.dataset.cardId);
		}
	});
	updateBulkActionsUI();
}

function updateBulkActionsUI() {
	const bulkActions = document.getElementById('bulk-actions');
	const count = document.getElementById('selected-count');

	if (bulkActions) {
		if (selectedCards.size > 0) {
			bulkActions.classList.remove('hidden');
			count.textContent = selectedCards.size;
		} else {
			bulkActions.classList.add('hidden');
		}
	}
}

async function bulkDelete() {
	if (!confirm(`Delete ${selectedCards.size} cards?`)) return;

	const response = await fetch('/api/cards/bulk', {
		method: 'DELETE',
		headers: {'Content-Type': 'application/json'},
		body: JSON.stringify({card_ids: Array.from(selectedCards)})
	});

	if (response.ok) {
		location.reload();
	} else {
		alert('Failed to delete cards');
	}
}

async function bulkChangeDifficulty(difficulty) {
	const response = await fetch('/api/cards/bulk', {
		method: 'PUT',
		headers: {'Content-Type': 'application/json'},
		body: JSON.stringify({
			card_ids: Array.from(selectedCards),
			updates: {difficulty: difficulty}
		})
	});

	if (response.ok) {
		location.reload();
	} else {
		alert('Failed to update cards');
	}
}

function cancelBulkSelection() {
	selectedCards.clear();
	document.querySelectorAll('.card-checkbox').forEach(cb => cb.checked = false);
	document.getElementById('select-all-checkbox').checked = false;
	updateBulkActionsUI();
}
'''

# ============================================================================
# TEMPLATES: PAGE BUILDER
# ============================================================================

def build_page(title: str, content: str, extra_css: str = "", extra_js: str = "") -> str:
	"""Build a complete HTML page."""
	return f'''<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>{title} - Flashcards</title>
	<style>{BASE_CSS}{extra_css}</style>
</head>
<body>
	<header class="header">
		<h1><a href="/" style="color: inherit; text-decoration: none;">Flashcards</a></h1>
		<nav>
			<a href="/">Dashboard</a>
			<a href="/review">Review</a>
			<a href="/cards">Cards</a>
			<a href="/generate">Generate</a>
			<a href="/stats">Stats</a>
			<button class="theme-toggle" onclick="toggleTheme()">Theme</button>
		</nav>
	</header>
	<main class="container">
		{content}
	</main>
	<script>{BASE_JS}{extra_js}</script>
</body>
</html>'''


def render_markdown(text: str) -> str:
	"""Render markdown to HTML if available."""
	if markdown:
		return markdown.markdown(text, extensions=['fenced_code', 'tables'])
	return f"<p>{text}</p>"


# ============================================================================
# ROUTE HANDLERS
# ============================================================================

def create_app(debug: bool = False) -> Quart:
	"""Create and configure the Quart application."""
	app = Quart(__name__)
	app.config['DEBUG'] = debug

	# ---- Dashboard ----
	@app.route('/')
	async def index():
		stats = db_get_stats()

		content = f'''
		<h2>Dashboard</h2>

		<div class="stats-grid">
			<div class="stat-card">
				<div class="stat-value">{stats["total_cards"]}</div>
				<div class="stat-label">Total Cards</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["due_for_review"]}</div>
				<div class="stat-label">Due for Review</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["notes_with_cards"]}</div>
				<div class="stat-label">Notes</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["total_reviews"]}</div>
				<div class="stat-label">Total Reviews</div>
			</div>
		</div>

		<div style="display: flex; gap: 16px; margin-bottom: 24px;">
			<a href="/review" class="btn btn-primary">Start Review Session</a>
			<a href="/generate" class="btn btn-secondary">Generate Cards</a>
		</div>

		<div class="card">
			<h3 style="margin-bottom: 16px;">Cards by Difficulty</h3>
			<div style="display: flex; gap: 24px;">
				<div><span class="badge badge-easy">Easy</span> {stats["by_difficulty"].get(1, 0)}</div>
				<div><span class="badge badge-medium">Medium</span> {stats["by_difficulty"].get(2, 0)}</div>
				<div><span class="badge badge-hard">Hard</span> {stats["by_difficulty"].get(3, 0)}</div>
			</div>
		</div>
		'''

		if stats["top_topics"]:
			topics_html = "".join([
				f'<div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border);"><span>{t["topic"]}</span><span>{t["count"]}</span></div>'
				for t in stats["top_topics"]
			])
			content += f'''
			<div class="card">
				<h3 style="margin-bottom: 16px;">Top Topics</h3>
				{topics_html}
			</div>
			'''

		return build_page("Dashboard", content)

	# ---- Cards List ----
	@app.route('/cards')
	async def cards_list():
		difficulty = request.args.get('difficulty', type=int)
		topic = request.args.get('topic')
		note = request.args.get('note')
		search = request.args.get('search')

		cards = db_get_cards(
			limit=100,
			difficulty=difficulty,
			topic=topic,
			note_path=note,
			search=search,
		)

		diff_names = {1: "Easy", 2: "Medium", 3: "Hard"}
		diff_badges = {1: "badge-easy", 2: "badge-medium", 3: "badge-hard"}

		rows = ""
		for card in cards:
			question_preview = card["question"][:60] + "..." if len(card["question"]) > 60 else card["question"]
			diff = card["difficulty"]
			rows += f'''
			<tr>
				<td class="checkbox-cell">
					<input type="checkbox" class="card-checkbox" data-card-id="{card["id"]}"
					       onchange="toggleCardSelection('{card["id"]}', this)">
				</td>
				<td><a href="/cards/{card["id"]}">{question_preview}</a></td>
				<td>{card["topic"] or "-"}</td>
				<td><span class="badge {diff_badges.get(diff, "")}">{diff_names.get(diff, "?")}</span></td>
				<td>{card["times_reviewed"]}</td>
				<td>
					<a href="/cards/{card["id"]}/edit" class="btn btn-sm btn-secondary">Edit</a>
				</td>
			</tr>
			'''

		if not cards:
			rows = '<tr><td colspan="6" class="empty-state">No cards found</td></tr>'

		content = f'''
		<div class="card-header">
			<h2>Flashcards</h2>
			<a href="/generate" class="btn btn-primary">Generate New</a>
		</div>

		<div class="card" style="margin-bottom: 20px;">
			<form method="get" style="display: flex; gap: 12px; flex-wrap: wrap; align-items: end;">
				<div class="form-group" style="margin-bottom: 0;">
					<label>Search</label>
					<input type="text" name="search" class="form-control" value="{search or ""}" placeholder="Search questions...">
				</div>
				<div class="form-group" style="margin-bottom: 0;">
					<label>Difficulty</label>
					<select name="difficulty" class="form-control">
						<option value="">All</option>
						<option value="1" {"selected" if difficulty == 1 else ""}>Easy</option>
						<option value="2" {"selected" if difficulty == 2 else ""}>Medium</option>
						<option value="3" {"selected" if difficulty == 3 else ""}>Hard</option>
					</select>
				</div>
				<div class="form-group" style="margin-bottom: 0;">
					<label>Topic</label>
					<input type="text" name="topic" class="form-control" value="{topic or ""}" placeholder="Topic...">
				</div>
				<button type="submit" class="btn btn-secondary">Filter</button>
				<a href="/cards" class="btn btn-secondary">Clear</a>
			</form>
		</div>

		<div class="card">
			<div class="table-container">
				<table>
					<thead>
						<tr>
							<th class="checkbox-cell">
								<input type="checkbox" id="select-all-checkbox" onchange="selectAllCards(this)">
							</th>
							<th>Question</th>
							<th>Topic</th>
							<th>Difficulty</th>
							<th>Reviews</th>
							<th>Actions</th>
						</tr>
					</thead>
					<tbody>
						{rows}
					</tbody>
				</table>
			</div>
		</div>

		<div id="bulk-actions" class="bulk-actions hidden">
			<span><span id="selected-count">0</span> selected</span>
			<button class="btn btn-sm btn-success" onclick="bulkChangeDifficulty(1)">Set Easy</button>
			<button class="btn btn-sm btn-warning" onclick="bulkChangeDifficulty(2)">Set Medium</button>
			<button class="btn btn-sm btn-danger" onclick="bulkChangeDifficulty(3)">Set Hard</button>
			<button class="btn btn-sm btn-danger" onclick="bulkDelete()">Delete</button>
			<button class="btn btn-sm btn-secondary" onclick="cancelBulkSelection()">Cancel</button>
		</div>
		'''

		return build_page("Cards", content)

	# ---- Card Detail ----
	@app.route('/cards/<card_id>')
	async def card_detail(card_id):
		card = db_get_card(card_id)
		if not card:
			return build_page("Not Found", '<div class="empty-state"><h3>Card not found</h3></div>'), 404

		diff_names = {1: "Easy", 2: "Medium", 3: "Hard"}
		diff_badges = {1: "badge-easy", 2: "badge-medium", 3: "badge-hard"}

		answer_html = render_markdown(card["answer"])

		content = f'''
		<div class="card">
			<div class="card-header">
				<h2>Card Details</h2>
				<div style="display: flex; gap: 8px;">
					<a href="/cards/{card["id"]}/edit" class="btn btn-secondary">Edit</a>
					<form method="post" action="/cards/{card["id"]}/delete" style="display: inline;">
						<button type="submit" class="btn btn-danger" onclick="return confirm('Delete this card?')">Delete</button>
					</form>
				</div>
			</div>

			<div class="form-group">
				<label>Question</label>
				<div style="padding: 12px; background: var(--bg-primary); border-radius: 8px;">{card["question"]}</div>
			</div>

			<div class="form-group">
				<label>Answer</label>
				<div style="padding: 12px; background: var(--bg-primary); border-radius: 8px;">{answer_html}</div>
			</div>

			<div style="display: flex; gap: 24px; flex-wrap: wrap;">
				<div>
					<label style="color: var(--text-muted);">Topic</label>
					<div>{card["topic"] or "-"}</div>
				</div>
				<div>
					<label style="color: var(--text-muted);">Difficulty</label>
					<div><span class="badge {diff_badges.get(card["difficulty"], "")}">{diff_names.get(card["difficulty"], "?")}</span></div>
				</div>
				<div>
					<label style="color: var(--text-muted);">Times Reviewed</label>
					<div>{card["times_reviewed"]}</div>
				</div>
				<div>
					<label style="color: var(--text-muted);">Times Correct</label>
					<div>{card["times_correct"]}</div>
				</div>
			</div>

			<div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border); font-size: 13px; color: var(--text-muted);">
				Note: {card["note_path"]}
			</div>
		</div>

		<a href="/cards" class="btn btn-secondary">Back to Cards</a>
		'''

		return build_page("Card Detail", content)

	# ---- Card Edit ----
	@app.route('/cards/<card_id>/edit', methods=['GET', 'POST'])
	async def card_edit(card_id):
		card = db_get_card(card_id)
		if not card:
			return build_page("Not Found", '<div class="empty-state"><h3>Card not found</h3></div>'), 404

		message = ""
		if request.method == 'POST':
			form = await request.form
			updates = {
				"question": form.get("question"),
				"answer": form.get("answer"),
				"topic": form.get("topic"),
				"difficulty": int(form.get("difficulty", 2)),
			}
			if db_update_card(card["id"], updates):
				message = '<div class="alert alert-success">Card updated successfully!</div>'
				card = db_get_card(card_id)  # Refresh
			else:
				message = '<div class="alert alert-error">Failed to update card</div>'

		content = f'''
		{message}
		<div class="card">
			<h2 style="margin-bottom: 20px;">Edit Card</h2>

			<form method="post">
				<div class="form-group">
					<label>Question</label>
					<textarea name="question" class="form-control" rows="3">{card["question"]}</textarea>
				</div>

				<div class="form-group">
					<label>Answer</label>
					<textarea name="answer" class="form-control" rows="5">{card["answer"]}</textarea>
				</div>

				<div class="form-group">
					<label>Topic</label>
					<input type="text" name="topic" class="form-control" value="{card["topic"] or ""}">
				</div>

				<div class="form-group">
					<label>Difficulty</label>
					<select name="difficulty" class="form-control">
						<option value="1" {"selected" if card["difficulty"] == 1 else ""}>Easy</option>
						<option value="2" {"selected" if card["difficulty"] == 2 else ""}>Medium</option>
						<option value="3" {"selected" if card["difficulty"] == 3 else ""}>Hard</option>
					</select>
				</div>

				<div style="display: flex; gap: 12px;">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<a href="/cards/{card["id"]}" class="btn btn-secondary">Cancel</a>
				</div>
			</form>
		</div>
		'''

		return build_page("Edit Card", content)

	# ---- Card Delete ----
	@app.route('/cards/<card_id>/delete', methods=['POST'])
	async def card_delete(card_id):
		db_delete_card(card_id)
		return redirect(url_for('cards_list'))

	# ---- Review Mode ----
	@app.route('/review')
	async def review_page():
		content = f'''
		<h2>Start Review Session</h2>

		<div class="card">
			<form method="post" action="/review/start">
				<div class="form-group">
					<label>Maximum Cards</label>
					<input type="number" name="max_cards" class="form-control" value="20" min="1" max="100">
				</div>

				<div class="form-group">
					<label>Difficulty Filter</label>
					<select name="difficulty" class="form-control">
						<option value="">All</option>
						<option value="1">Easy only</option>
						<option value="2">Medium only</option>
						<option value="3">Hard only</option>
					</select>
				</div>

				<div class="form-group">
					<label>Topic Filter</label>
					<input type="text" name="topic" class="form-control" placeholder="Filter by topic...">
				</div>

				<div class="form-group">
					<label>
						<input type="checkbox" name="due_only" value="1"> Only show cards due for review
					</label>
				</div>

				<button type="submit" class="btn btn-primary">Start Review</button>
			</form>
		</div>
		'''

		return build_page("Review", content, FLASHCARD_CSS)

	@app.route('/review/start', methods=['POST'])
	async def review_start():
		form = await request.form
		max_cards = int(form.get('max_cards', 20))
		difficulty = form.get('difficulty')
		difficulty = int(difficulty) if difficulty else None
		topic = form.get('topic') or None
		due_only = form.get('due_only') == '1'

		card_ids = db_get_review_cards(
			max_cards=max_cards,
			difficulty=difficulty,
			topic=topic,
			due_only=due_only,
		)

		if not card_ids:
			content = '''
			<div class="empty-state">
				<h3>No cards to review!</h3>
				<p>Try generating some cards first or adjusting your filters.</p>
				<a href="/generate" class="btn btn-primary" style="margin-top: 16px;">Generate Cards</a>
			</div>
			'''
			return build_page("Review", content, FLASHCARD_CSS)

		session_id = str(uuid.uuid4())
		REVIEW_SESSIONS[session_id] = ReviewSession(
			session_id=session_id,
			card_ids=card_ids,
			difficulty_filter=difficulty,
			topic_filter=topic,
			due_only=due_only,
		)

		return redirect(url_for('review_session', session_id=session_id))

	@app.route('/review/<session_id>')
	async def review_session(session_id):
		session = REVIEW_SESSIONS.get(session_id)
		if not session:
			return redirect(url_for('review_page'))

		# Check if session is complete
		if session.current_index >= len(session.card_ids):
			return redirect(url_for('review_complete', session_id=session_id))

		card_id = session.card_ids[session.current_index]
		card = db_get_card(card_id)

		if not card:
			# Skip missing card
			session.current_index += 1
			return redirect(url_for('review_session', session_id=session_id))

		progress_pct = (session.current_index / len(session.card_ids)) * 100
		diff_names = {1: "Easy", 2: "Medium", 3: "Hard"}

		answer_html = render_markdown(card["answer"])

		review_js = f'''
		let isFlipped = false;

		function flipCard() {{
			const flashcard = document.getElementById('flashcard');
			isFlipped = !isFlipped;
			flashcard.classList.toggle('flipped', isFlipped);

			document.getElementById('flip-hint').classList.toggle('hidden', isFlipped);
			document.getElementById('rating-buttons').classList.toggle('hidden', !isFlipped);
		}}

		document.addEventListener('keydown', function(e) {{
			if (e.code === 'Space') {{
				e.preventDefault();
				flipCard();
			}}
			if (isFlipped) {{
				if (e.key === '1') submitRating(1);
				if (e.key === '2') submitRating(2);
				if (e.key === '3') submitRating(3);
				if (e.key === 's' || e.key === 'S') submitRating(0);
			}}
		}});

		function submitRating(rating) {{
			window.location.href = '/review/{session_id}/rate?rating=' + rating;
		}}
		'''

		content = f'''
		<div class="review-progress">
			<div class="review-progress-text">Card {session.current_index + 1} of {len(session.card_ids)}</div>
			<div class="progress-bar">
				<div class="progress-fill" style="width: {progress_pct}%"></div>
			</div>
		</div>

		<div class="flashcard-container" onclick="flipCard()">
			<div class="flashcard" id="flashcard">
				<div class="flashcard-face flashcard-front">
					<div class="flashcard-label">Question</div>
					<div class="flashcard-content">{card["question"]}</div>
					<div class="flashcard-meta">
						<span>{card["topic"] or "No topic"}</span>
						<span>{diff_names.get(card["difficulty"], "?")}</span>
					</div>
				</div>
				<div class="flashcard-face flashcard-back">
					<div class="flashcard-label">Answer</div>
					<div class="flashcard-content">{answer_html}</div>
				</div>
			</div>
		</div>

		<div class="review-controls">
			<div id="flip-hint" class="flip-hint">Click card or press Space to reveal answer</div>

			<div id="rating-buttons" class="rating-buttons hidden">
				<button class="rating-btn rating-easy" onclick="submitRating(1)">Easy (1)</button>
				<button class="rating-btn rating-medium" onclick="submitRating(2)">Medium (2)</button>
				<button class="rating-btn rating-hard" onclick="submitRating(3)">Hard (3)</button>
				<button class="rating-btn rating-skip" onclick="submitRating(0)">Skip (S)</button>
			</div>

			<div class="keyboard-shortcuts">
				<span><kbd>Space</kbd> Flip</span>
				<span><kbd>1</kbd> Easy</span>
				<span><kbd>2</kbd> Medium</span>
				<span><kbd>3</kbd> Hard</span>
				<span><kbd>S</kbd> Skip</span>
			</div>
		</div>
		'''

		return build_page("Review", content, FLASHCARD_CSS, review_js)

	@app.route('/review/<session_id>/rate')
	async def review_rate(session_id):
		session = REVIEW_SESSIONS.get(session_id)
		if not session:
			return redirect(url_for('review_page'))

		rating = request.args.get('rating', type=int, default=0)
		card_id = session.card_ids[session.current_index]

		if rating > 0:
			session.ratings[card_id] = rating
			db_update_after_review(card_id, rating)

		session.current_index += 1

		if session.current_index >= len(session.card_ids):
			return redirect(url_for('review_complete', session_id=session_id))

		return redirect(url_for('review_session', session_id=session_id))

	@app.route('/review/<session_id>/complete')
	async def review_complete(session_id):
		session = REVIEW_SESSIONS.get(session_id)
		if not session:
			return redirect(url_for('review_page'))

		total = len(session.card_ids)
		reviewed = len(session.ratings)
		skipped = total - reviewed
		easy_count = sum(1 for r in session.ratings.values() if r == 1)

		success_rate = (easy_count / reviewed * 100) if reviewed > 0 else 0

		# Clean up session
		del REVIEW_SESSIONS[session_id]

		content = f'''
		<div class="session-summary">
			<h2>Session Complete!</h2>

			<div class="summary-stats">
				<div class="summary-stat">
					<div class="summary-stat-value">{reviewed}</div>
					<div class="summary-stat-label">Reviewed</div>
				</div>
				<div class="summary-stat">
					<div class="summary-stat-value">{easy_count}</div>
					<div class="summary-stat-label">Easy</div>
				</div>
				<div class="summary-stat">
					<div class="summary-stat-value">{success_rate:.0f}%</div>
					<div class="summary-stat-label">Success Rate</div>
				</div>
			</div>

			<div style="display: flex; gap: 12px; justify-content: center;">
				<a href="/review" class="btn btn-primary">New Session</a>
				<a href="/" class="btn btn-secondary">Dashboard</a>
			</div>
		</div>
		'''

		return build_page("Session Complete", content, FLASHCARD_CSS)

	# ---- Generate ----
	@app.route('/generate')
	async def generate_page():
		# Get recent notes for selection
		notes = db_get_recent_notes(days=14)

		notes_options = ""
		for note in notes[:30]:
			short_path = note["path"][-50:] if len(note["path"]) > 50 else note["path"]
			notes_options += f'<option value="{note["path"]}">{short_path}</option>\n'

		content = f'''
		<h2>Generate Flashcards</h2>

		<div class="tabs">
			<button class="tab active" onclick="showTab('notes')">From Notes</button>
			<button class="tab" onclick="showTab('content')">From Content</button>
		</div>

		<div id="tab-notes" class="card">
			<form method="post" action="/generate/from-notes">
				<div class="form-group">
					<label>Select Notes (recent 14 days)</label>
					<select name="note_paths" class="form-control" multiple size="10" style="min-height: 200px;">
						{notes_options}
					</select>
					<small style="color: var(--text-muted);">Hold Ctrl/Cmd to select multiple</small>
				</div>

				<div class="form-group">
					<label>Cards per Note</label>
					<input type="number" name="cards_per_note" class="form-control" value="5" min="1" max="20">
				</div>

				<button type="submit" class="btn btn-primary">Generate from Notes</button>
			</form>
		</div>

		<div id="tab-content" class="card hidden">
			<form method="post" action="/generate/from-content">
				<div class="form-group">
					<label>Paste Content</label>
					<textarea name="content" class="form-control" rows="12" placeholder="Paste your note content here..."></textarea>
				</div>

				<div class="form-group">
					<label>Source Name (optional)</label>
					<input type="text" name="source_name" class="form-control" placeholder="e.g., 'Python Notes'">
				</div>

				<div class="form-group">
					<label>Number of Cards</label>
					<input type="number" name="cards_count" class="form-control" value="5" min="1" max="20">
				</div>

				<button type="submit" class="btn btn-primary">Generate from Content</button>
			</form>
		</div>
		'''

		tab_js = '''
		function showTab(tab) {
			document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
			document.querySelectorAll('[id^="tab-"]').forEach(t => t.classList.add('hidden'));

			event.target.classList.add('active');
			document.getElementById('tab-' + tab).classList.remove('hidden');
		}
		'''

		return build_page("Generate", content, "", tab_js)

	@app.route('/generate/from-notes', methods=['POST'])
	async def generate_from_notes():
		form = await request.form
		note_paths = form.getlist('note_paths')
		cards_per_note = int(form.get('cards_per_note', 5))

		if not note_paths:
			return build_page("Generate", '<div class="alert alert-error">Please select at least one note</div>')

		# Use CLI to generate
		total_generated = 0
		errors = []

		for note_path in note_paths:
			result = await run_flashcards_command([
				"generate",
				"--days", "365",  # High number since we have specific path
				"--cards-per-note", str(cards_per_note),
				"--force",
				"--quiet",
			])

			if result["returncode"] == 0:
				# Count cards for this note
				cards = db_get_cards(note_path=note_path, limit=100)
				total_generated += len(cards)
			else:
				errors.append(f"{note_path}: {result['stderr']}")

		message = f'<div class="alert alert-success">Generated flashcards for {len(note_paths)} notes!</div>'
		if errors:
			message += f'<div class="alert alert-error">Some errors occurred: {"; ".join(errors[:3])}</div>'

		return build_page("Generate", f'''
			{message}
			<a href="/cards" class="btn btn-primary">View Cards</a>
			<a href="/generate" class="btn btn-secondary">Generate More</a>
		''')

	@app.route('/generate/from-content', methods=['POST'])
	async def generate_from_content():
		form = await request.form
		content = form.get('content', '')
		source_name = form.get('source_name', 'pasted-content')
		cards_count = int(form.get('cards_count', 5))

		if not content.strip():
			return build_page("Generate", '<div class="alert alert-error">Please provide some content</div>')

		# Use CLI with stdin
		result = await run_flashcards_command([
			"generate",
			"--stdin",
			"--cards-per-note", str(cards_count),
		], timeout=180)

		if result["returncode"] != 0:
			return build_page("Generate", f'''
				<div class="alert alert-error">Generation failed: {result["stderr"]}</div>
				<a href="/generate" class="btn btn-secondary">Try Again</a>
			''')

		# Parse generated cards from stdout
		try:
			data = json.loads(result["stdout"])
			cards = data.get("flashcards", [])

			if cards:
				# Insert into database
				count = db_insert_cards(cards, source_name, None, datetime.now())
				message = f'<div class="alert alert-success">Generated {count} flashcards!</div>'
			else:
				message = '<div class="alert alert-error">No cards were generated</div>'
		except json.JSONDecodeError:
			message = '<div class="alert alert-error">Failed to parse generated cards</div>'

		return build_page("Generate", f'''
			{message}
			<a href="/cards" class="btn btn-primary">View Cards</a>
			<a href="/generate" class="btn btn-secondary">Generate More</a>
		''')

	# ---- Stats ----
	@app.route('/stats')
	async def stats_page():
		stats = db_get_stats()

		diff_names = {1: "Easy", 2: "Medium", 3: "Hard"}
		difficulty_rows = ""
		for diff in [1, 2, 3]:
			count = stats["by_difficulty"].get(diff, 0)
			percentage = (count / stats["total_cards"] * 100) if stats["total_cards"] > 0 else 0
			difficulty_rows += f'''
			<tr>
				<td>{diff_names[diff]}</td>
				<td>{count}</td>
				<td>{percentage:.1f}%</td>
			</tr>
			'''

		topics_rows = ""
		for t in stats["top_topics"]:
			topics_rows += f'<tr><td>{t["topic"]}</td><td>{t["count"]}</td></tr>'

		if not topics_rows:
			topics_rows = '<tr><td colspan="2" class="empty-state">No topics yet</td></tr>'

		content = f'''
		<h2>Statistics</h2>

		<div class="stats-grid">
			<div class="stat-card">
				<div class="stat-value">{stats["total_cards"]}</div>
				<div class="stat-label">Total Cards</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["due_for_review"]}</div>
				<div class="stat-label">Due for Review</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["notes_with_cards"]}</div>
				<div class="stat-label">Notes with Cards</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["total_reviews"]}</div>
				<div class="stat-label">Total Reviews</div>
			</div>
		</div>

		<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
			<div class="card">
				<h3 style="margin-bottom: 16px;">By Difficulty</h3>
				<table>
					<thead>
						<tr><th>Difficulty</th><th>Count</th><th>Percentage</th></tr>
					</thead>
					<tbody>{difficulty_rows}</tbody>
				</table>
			</div>

			<div class="card">
				<h3 style="margin-bottom: 16px;">Top Topics</h3>
				<table>
					<thead>
						<tr><th>Topic</th><th>Cards</th></tr>
					</thead>
					<tbody>{topics_rows}</tbody>
				</table>
			</div>
		</div>

		<div class="card" style="margin-top: 20px;">
			<h3 style="margin-bottom: 16px;">Export/Import</h3>
			<div style="display: flex; gap: 12px;">
				<a href="/export?format=json" class="btn btn-secondary">Export JSON</a>
				<a href="/export?format=yaml" class="btn btn-secondary">Export YAML</a>
				<a href="/import" class="btn btn-secondary">Import</a>
			</div>
		</div>
		'''

		return build_page("Statistics", content)

	# ---- Export ----
	@app.route('/export')
	async def export_page():
		format_type = request.args.get('format', 'json')

		cards = db_get_cards(limit=10000)

		# Convert datetime objects
		for card in cards:
			for key in ["last_reviewed", "next_review", "note_mtime", "created_at", "updated_at"]:
				if card.get(key):
					card[key] = card[key].isoformat()

		if format_type == 'yaml':
			try:
				import yaml
				content_type = 'application/x-yaml'
				filename = 'flashcards_export.yaml'
				data = yaml.dump(cards, default_flow_style=False)
			except ImportError:
				return "PyYAML not installed", 500
		else:
			content_type = 'application/json'
			filename = 'flashcards_export.json'
			data = json.dumps(cards, indent=2)

		response = await make_response(data)
		response.headers['Content-Type'] = content_type
		response.headers['Content-Disposition'] = f'attachment; filename={filename}'
		return response

	# ---- Import ----
	@app.route('/import', methods=['GET', 'POST'])
	async def import_page():
		if request.method == 'GET':
			content = '''
			<h2>Import Flashcards</h2>

			<div class="card">
				<form method="post" enctype="multipart/form-data">
					<div class="form-group">
						<label>Upload File (JSON or YAML)</label>
						<input type="file" name="file" class="form-control" accept=".json,.yaml,.yml">
					</div>

					<button type="submit" class="btn btn-primary">Import</button>
				</form>
			</div>
			'''
			return build_page("Import", content)

		files = await request.files
		file = files.get('file')

		if not file:
			return build_page("Import", '<div class="alert alert-error">No file provided</div>')

		content = file.read().decode('utf-8')

		try:
			if file.filename.endswith(('.yaml', '.yml')):
				import yaml
				cards = yaml.safe_load(content)
			else:
				cards = json.loads(content)
		except Exception as e:
			return build_page("Import", f'<div class="alert alert-error">Failed to parse file: {e}</div>')

		if not isinstance(cards, list):
			return build_page("Import", '<div class="alert alert-error">Expected a list of cards</div>')

		imported = 0
		with get_flashcards_connection() as conn:
			with conn.cursor() as cur:
				for card in cards:
					if not all(k in card for k in ["note_path", "question", "answer"]):
						continue

					cur.execute("""
						INSERT INTO flashcards (
							note_path, question, answer, topic, difficulty,
							times_reviewed, times_correct, note_mtime
						) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
					""", (
						card["note_path"],
						card["question"],
						card["answer"],
						card.get("topic"),
						card.get("difficulty", 2),
						card.get("times_reviewed", 0),
						card.get("times_correct", 0),
						datetime.now(),
					))
					imported += 1
			conn.commit()

		return build_page("Import", f'''
			<div class="alert alert-success">Imported {imported} flashcards!</div>
			<a href="/cards" class="btn btn-primary">View Cards</a>
		''')

	# ---- API Endpoints ----
	@app.route('/api/cards/bulk', methods=['PUT', 'DELETE'])
	async def api_bulk_operations():
		data = await request.get_json()
		card_ids = data.get('card_ids', [])

		if not card_ids:
			return jsonify({"error": "No card IDs provided"}), 400

		if request.method == 'DELETE':
			count = db_delete_cards_bulk(card_ids)
			return jsonify({"deleted": count})

		elif request.method == 'PUT':
			updates = data.get('updates', {})
			count = db_update_cards_bulk(card_ids, updates)
			return jsonify({"updated": count})

	@app.route('/api/stats')
	async def api_stats():
		stats = db_get_stats()
		return jsonify(stats)

	return app


# ============================================================================
# MAIN
# ============================================================================

def parse_arguments() -> argparse.Namespace:
	"""Parse command line arguments."""
	parser = argparse.ArgumentParser(
		prog="flashcards-serve",
		description="Web UI for flashcard review and administration",
	)
	parser.add_argument("--host", default="127.0.0.1", help="Host to bind to (default: 127.0.0.1)")
	parser.add_argument("--port", type=int, default=5003, help="Port to bind to (default: 5003)")
	parser.add_argument("--debug", action="store_true", help="Enable debug mode")
	return parser.parse_args()


async def check_db_available() -> bool:
	"""Check if database is available."""
	try:
		conn = get_flashcards_connection()
		conn.close()
		return True
	except Exception as e:
		print(f"Database connection error: {e}", file=sys.stderr)
		return False


async def main() -> int:
	"""Main entry point."""
	args = parse_arguments()

	if not await check_db_available():
		print("Error: Could not connect to flashcards database", file=sys.stderr)
		print("Make sure to run: local_postgres init-flashcards", file=sys.stderr)
		return 1

	print(f"Starting flashcards-serve on http://{args.host}:{args.port}", file=sys.stderr)

	app = create_app(debug=args.debug)
	await app.run_task(host=args.host, port=args.port, debug=args.debug)

	return 0


if __name__ == "__main__":
	sys.exit(asyncio.run(main()))
