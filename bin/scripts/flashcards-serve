#!/usr/bin/python3

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
flashcards-serve - Web UI for flashcard review and administration

Provides a web interface for:
- Reviewing flashcards with flip animation
- Generating flashcards from notes or pasted content
- Managing cards (edit, delete, bulk operations)
- Viewing statistics
"""

import os
import subprocess
import sys

# Container check for distrobox - do this BEFORE any other imports
ctr_id = os.environ.get("CONTAINER_ID", "")
no_dbox_check = os.environ.get("NO_DBOX_CHECK", "").lower() in ("1", "true")

if not no_dbox_check and ctr_id != "dev":
	cmd = ["distrobox", "enter", "dev", "--", *sys.argv]
	subprocess.run(cmd)
	sys.exit(0)

# Now import everything else inside the dev container
import argparse
import asyncio
import json
import random
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any

try:
	from quart import Quart, request, jsonify, redirect, url_for, make_response
except ImportError:
	print("Error: quart required. Install with: pip install quart", file=sys.stderr)
	sys.exit(1)

try:
	import psycopg2
	from psycopg2.extras import RealDictCursor
except ImportError:
	print("Error: psycopg2 required. Install with: pip install psycopg2-binary", file=sys.stderr)
	sys.exit(1)

try:
	import markdown
except ImportError:
	markdown = None


# ============================================================================
# CONFIGURATION
# ============================================================================

DB_HOST: str = os.environ.get("FLASHCARDS_DB_HOST", "127.0.0.1")
DB_PORT: int = int(os.environ.get("FLASHCARDS_DB_PORT", "5432"))
DB_NAME: str = os.environ.get("FLASHCARDS_DB_NAME", "flashcards")
DB_USER: str = os.environ.get("FLASHCARDS_DB_USER", "postgres")
DB_PASSWORD: str = os.environ.get("FLASHCARDS_DB_PASSWORD", "")

NOTES_DB_HOST: str = os.environ.get("NOTES_DB_HOST", "127.0.0.1")
NOTES_DB_PORT: int = int(os.environ.get("NOTES_DB_PORT", "5432"))
NOTES_DB_NAME: str = os.environ.get("NOTES_DB_NAME", "notes")
NOTES_DB_USER: str = os.environ.get("NOTES_DB_USER", "postgres")
NOTES_DB_PASSWORD: str = os.environ.get("NOTES_DB_PASSWORD", "")

PARA_PREFIX_MAP: Dict[str, str] = {
	"inbox": "00_inbox",
	"projects": "01_projects",
	"areas": "02_areas",
	"resources": "03_resources",
	"archives": "04_archives",
}


# ============================================================================
# DATA CLASSES
# ============================================================================

@dataclass
class Flashcard:
	"""Represents a flashcard."""
	id: str
	note_path: str
	question: str
	answer: str
	topic: Optional[str] = None
	note_uuid: Optional[str] = None
	difficulty: int = 2
	times_reviewed: int = 0
	times_correct: int = 0
	last_reviewed: Optional[datetime] = None
	next_review: Optional[datetime] = None
	note_mtime: Optional[datetime] = None
	created_at: Optional[datetime] = None
	updated_at: Optional[datetime] = None


@dataclass
class ReviewSession:
	"""Represents an active review session."""
	session_id: str
	card_ids: List[str]
	current_index: int = 0
	ratings: Dict[str, int] = field(default_factory=dict)
	started_at: datetime = field(default_factory=datetime.now)
	difficulty_filter: Optional[int] = None
	para_filter: Optional[str] = None
	topic_filter: Optional[str] = None
	due_only: bool = False


# In-memory session store
REVIEW_SESSIONS: Dict[str, ReviewSession] = {}


# ============================================================================
# DATABASE LAYER
# ============================================================================

def get_flashcards_connection():
	"""Get connection to flashcards database."""
	conn_params: Dict[str, Any] = {
		"host": DB_HOST,
		"port": DB_PORT,
		"dbname": DB_NAME,
		"user": DB_USER,
	}
	if DB_PASSWORD:
		conn_params["password"] = DB_PASSWORD
	return psycopg2.connect(**conn_params)


def get_notes_connection():
	"""Get connection to notes database."""
	conn_params: Dict[str, Any] = {
		"host": NOTES_DB_HOST,
		"port": NOTES_DB_PORT,
		"dbname": NOTES_DB_NAME,
		"user": NOTES_DB_USER,
	}
	if NOTES_DB_PASSWORD:
		conn_params["password"] = NOTES_DB_PASSWORD
	return psycopg2.connect(**conn_params)


def db_get_cards(
	limit: int = 50,
	offset: int = 0,
	difficulty: Optional[int] = None,
	topic: Optional[str] = None,
	note_path: Optional[str] = None,
	search: Optional[str] = None,
) -> List[Dict[str, Any]]:
	"""Get flashcards with optional filters."""
	conditions: List[str] = []
	params: List[Any] = []

	if difficulty is not None:
		conditions.append("difficulty = %s")
		params.append(difficulty)

	if topic:
		conditions.append("topic ILIKE %s")
		params.append(f"%{topic}%")

	if note_path:
		conditions.append("note_path ILIKE %s")
		params.append(f"%{note_path}%")

	if search:
		conditions.append("(question ILIKE %s OR answer ILIKE %s)")
		params.extend([f"%{search}%", f"%{search}%"])

	where_clause: str = ""
	if conditions:
		where_clause = "WHERE " + " AND ".join(conditions)

	query: str = f"""
		SELECT id::text, note_path, note_uuid::text, question, answer, topic,
		       difficulty, times_reviewed, times_correct, last_reviewed,
		       next_review, note_mtime, created_at, updated_at
		FROM flashcards
		{where_clause}
		ORDER BY updated_at DESC
		LIMIT %s OFFSET %s
	"""
	params.extend([limit, offset])

	cards: List[Dict[str, Any]] = []
	with get_flashcards_connection() as conn:
		with conn.cursor(cursor_factory=RealDictCursor) as cur:
			cur.execute(query, params)
			cards = [dict(row) for row in cur.fetchall()]

	return cards


def db_get_card(card_id: str) -> Optional[Dict[str, Any]]:
	"""Get a single card by ID."""
	query: str = """
		SELECT id::text, note_path, note_uuid::text, question, answer, topic,
		       difficulty, times_reviewed, times_correct, last_reviewed,
		       next_review, note_mtime, created_at, updated_at
		FROM flashcards
		WHERE id::text LIKE %s
		LIMIT 1
	"""
	with get_flashcards_connection() as conn:
		with conn.cursor(cursor_factory=RealDictCursor) as cur:
			cur.execute(query, (f"{card_id}%",))
			row = cur.fetchone()
			if row:
				return dict(row)
	return None


def db_update_card(card_id: str, updates: Dict[str, Any]) -> bool:
	"""Update a card's fields."""
	if not updates:
		return False

	set_parts: List[str] = []
	params: List[Any] = []

	for key, value in updates.items():
		if key in ["question", "answer", "topic", "difficulty"]:
			set_parts.append(f"{key} = %s")
			params.append(value)

	if not set_parts:
		return False

	params.append(f"{card_id}%")
	query: str = f"UPDATE flashcards SET {', '.join(set_parts)} WHERE id::text LIKE %s"

	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			cur.execute(query, params)
			count: int = cur.rowcount
		conn.commit()

	return count > 0


def db_delete_card(card_id: str) -> bool:
	"""Delete a single card."""
	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			cur.execute("DELETE FROM flashcards WHERE id::text LIKE %s", (f"{card_id}%",))
			count: int = cur.rowcount
		conn.commit()
	return count > 0


def db_delete_cards_bulk(card_ids: List[str]) -> int:
	"""Delete multiple cards. Returns count deleted."""
	if not card_ids:
		return 0

	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			cur.execute(
				"DELETE FROM flashcards WHERE id::text = ANY(%s)",
				(card_ids,)
			)
			count: int = cur.rowcount
		conn.commit()
	return count


def db_update_cards_bulk(card_ids: List[str], updates: Dict[str, Any]) -> int:
	"""Update multiple cards. Returns count updated."""
	if not card_ids or not updates:
		return 0

	set_parts: List[str] = []
	params: List[Any] = []

	for key, value in updates.items():
		if key in ["difficulty"]:
			set_parts.append(f"{key} = %s")
			params.append(value)

	if not set_parts:
		return 0

	params.append(card_ids)
	query: str = f"UPDATE flashcards SET {', '.join(set_parts)} WHERE id::text = ANY(%s)"

	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			cur.execute(query, params)
			count: int = cur.rowcount
		conn.commit()

	return count


def db_get_stats() -> Dict[str, Any]:
	"""Get flashcard statistics."""
	stats: Dict[str, Any] = {}

	with get_flashcards_connection() as conn:
		with conn.cursor(cursor_factory=RealDictCursor) as cur:
			cur.execute("SELECT COUNT(*) as total FROM flashcards")
			stats["total_cards"] = cur.fetchone()["total"]

			cur.execute("""
				SELECT difficulty, COUNT(*) as count
				FROM flashcards
				GROUP BY difficulty
				ORDER BY difficulty
			""")
			stats["by_difficulty"] = {
				row["difficulty"]: row["count"] for row in cur.fetchall()
			}

			cur.execute("""
				SELECT COUNT(*) as due
				FROM flashcards
				WHERE next_review IS NULL OR next_review <= NOW()
			""")
			stats["due_for_review"] = cur.fetchone()["due"]

			cur.execute("SELECT SUM(times_reviewed) as total FROM flashcards")
			result = cur.fetchone()["total"]
			stats["total_reviews"] = result or 0

			cur.execute("SELECT COUNT(DISTINCT note_path) as notes FROM flashcards")
			stats["notes_with_cards"] = cur.fetchone()["notes"]

			# Topics breakdown
			cur.execute("""
				SELECT topic, COUNT(*) as count
				FROM flashcards
				WHERE topic IS NOT NULL AND topic != ''
				GROUP BY topic
				ORDER BY count DESC
				LIMIT 10
			""")
			stats["top_topics"] = [
				{"topic": row["topic"], "count": row["count"]}
				for row in cur.fetchall()
			]

	return stats


def db_get_review_cards(
	max_cards: int = 20,
	difficulty: Optional[int] = None,
	para: Optional[str] = None,
	topic: Optional[str] = None,
	due_only: bool = False,
) -> List[str]:
	"""
	Get card IDs for review session.

	Args:
		max_cards: Maximum number of cards to return
		difficulty: Filter by difficulty (1=easy, 2=medium, 3=hard)
		para: Filter by PARA category (inbox, projects, areas, resources, archives)
		topic: Filter by path segment (e.g., 'repos/dotfiles' matches paths containing it)
		due_only: Only return cards due for review
	"""
	conditions: List[str] = []
	params: List[Any] = []

	if difficulty is not None:
		conditions.append("difficulty = %s")
		params.append(difficulty)

	if para:
		# Map para name to directory prefix
		prefix: str = PARA_PREFIX_MAP.get(para, para)
		conditions.append("note_path LIKE %s")
		params.append(f"{prefix}/%")

	if topic:
		# Filter by path segment (e.g., 'repos/dotfiles' matches '02_areas/repos/dotfiles/aipy.md')
		conditions.append("note_path LIKE %s")
		params.append(f"%{topic}%")

	if due_only:
		conditions.append("(next_review IS NULL OR next_review <= NOW())")

	where_clause: str = ""
	if conditions:
		where_clause = "WHERE " + " AND ".join(conditions)

	query: str = f"SELECT id::text FROM flashcards {where_clause}"

	card_ids: List[str] = []
	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			cur.execute(query, params)
			card_ids = [row[0] for row in cur.fetchall()]

	random.shuffle(card_ids)
	return card_ids[:max_cards]


def db_update_after_review(card_id: str, rating: int) -> None:
	"""Update card after review."""
	with get_flashcards_connection() as conn:
		with conn.cursor(cursor_factory=RealDictCursor) as cur:
			cur.execute(
				"SELECT times_reviewed, times_correct FROM flashcards WHERE id = %s",
				(card_id,)
			)
			row = cur.fetchone()
			if not row:
				return

			times_reviewed: int = row["times_reviewed"] + 1
			times_correct: int = row["times_correct"] + (1 if rating == 1 else 0)

			# Calculate next review
			base_intervals: Dict[int, List[int]] = {
				1: [1, 3, 7, 14, 30, 60, 120],
				2: [1, 2, 4, 8, 16, 32, 64],
				3: [1, 1, 2, 4, 8, 16, 32],
			}
			intervals: List[int] = base_intervals.get(rating, base_intervals[2])
			idx: int = min(times_correct, len(intervals) - 1)
			days: int = intervals[idx]
			next_review: datetime = datetime.now() + timedelta(days=days)

			cur.execute("""
				UPDATE flashcards
				SET times_reviewed = %s,
				    times_correct = %s,
				    difficulty = %s,
				    last_reviewed = NOW(),
				    next_review = %s
				WHERE id = %s
			""", (times_reviewed, times_correct, rating, next_review, card_id))

		conn.commit()


def db_get_recent_notes(days: int = 7, para: Optional[str] = None) -> List[Dict[str, Any]]:
	"""Get recent notes from notes database."""
	query: str = """
		SELECT id::text, path, para, category, content, last_modified
		FROM notes
		WHERE last_modified > NOW() - INTERVAL '1 day' * %s
	"""
	params: List[Any] = [days]

	if para:
		query += " AND para = %s"
		params.append(para)

	query += " ORDER BY last_modified DESC LIMIT 100"

	notes: List[Dict[str, Any]] = []
	try:
		with get_notes_connection() as conn:
			with conn.cursor(cursor_factory=RealDictCursor) as cur:
				cur.execute(query, params)
				notes = [dict(row) for row in cur.fetchall()]
	except Exception as e:
		print(f"Error fetching notes: {e}", file=sys.stderr)

	return notes


def db_insert_cards(cards: List[Dict[str, str]], note_path: str, note_uuid: Optional[str], note_mtime: datetime) -> int:
	"""Insert generated cards into database."""
	if not cards:
		return 0

	with get_flashcards_connection() as conn:
		with conn.cursor() as cur:
			for card in cards:
				cur.execute("""
					INSERT INTO flashcards (note_path, note_uuid, note_mtime, topic, question, answer)
					VALUES (%s, %s, %s, %s, %s, %s)
				""", (
					note_path,
					note_uuid,
					note_mtime,
					card.get("topic"),
					card["question"],
					card["answer"],
				))
		conn.commit()

	return len(cards)


# ============================================================================
# AI GENERATION
# ============================================================================

async def run_flashcards_command(args: List[str], timeout: int = 120) -> Dict[str, Any]:
	"""Run flashcards CLI command asynchronously."""
	proc = await asyncio.create_subprocess_exec(
		"flashcards", *args,
		stdout=asyncio.subprocess.PIPE,
		stderr=asyncio.subprocess.PIPE,
		env={**os.environ, "NO_DBOX_CHECK": "1"},
	)
	try:
		stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=timeout)
		return {
			"returncode": proc.returncode,
			"stdout": stdout.decode("utf-8"),
			"stderr": stderr.decode("utf-8"),
		}
	except asyncio.TimeoutError:
		proc.kill()
		return {
			"returncode": -1,
			"stdout": "",
			"stderr": "Command timed out",
		}


# ============================================================================
# MCP SERVER
# ============================================================================

def create_mcp_server(host: str = "127.0.0.1", port: int = 5003):
	"""
	Create and configure the MCP server for flashcards.

	Args:
		host: Host to bind to (for HTTP transport)
		port: Port to bind to (for HTTP transport)

	Provides tools for:
	- Listing and searching flashcards
	- Getting flashcard details
	- Creating flashcards (manual and AI-generated)
	- Updating flashcards
	- Deleting flashcards
	- Getting statistics
	- Recording review ratings
	"""
	try:
		from mcp.server.fastmcp import FastMCP
	except ImportError:
		print("Error: mcp package required for MCP server.", file=sys.stderr)
		print("Install with: pip install 'mcp[cli]'", file=sys.stderr)
		sys.exit(1)

	mcp = FastMCP("flashcards", json_response=True, host=host, port=port)

	@mcp.tool()
	def list_flashcards(
		limit: int = 50,
		offset: int = 0,
		topic: str = "",
		difficulty: str = "",
		note_path: str = "",
		due_only: bool = False,
	) -> dict:
		"""
		List flashcards with optional filters.

		Args:
			limit: Maximum number of cards to return (default: 50, max: 500)
			offset: Number of cards to skip for pagination (default: 0)
			topic: Filter by topic (partial match)
			difficulty: Filter by difficulty: 'easy', 'medium', 'hard', or '' for all
			note_path: Filter by note path (partial match)
			due_only: Only return cards due for review

		Returns:
			Dictionary with 'cards' list and 'total' count
		"""
		limit = min(limit, 500)
		diff_map = {"easy": 1, "medium": 2, "hard": 3, "": None}
		diff_int = diff_map.get(difficulty.lower(), None)

		cards = db_get_cards(
			limit=limit,
			offset=offset,
			topic=topic if topic else None,
			difficulty=diff_int,
			note_path=note_path if note_path else None,
			due_only=due_only,
		)

		# Convert datetime objects to ISO strings
		for card in cards:
			for key in ["last_reviewed", "next_review", "note_mtime", "created_at", "updated_at"]:
				if card.get(key):
					card[key] = card[key].isoformat()

		return {"cards": cards, "count": len(cards)}

	@mcp.tool()
	def get_flashcard(card_id: str) -> dict:
		"""
		Get a single flashcard by ID.

		Args:
			card_id: UUID of the flashcard (supports partial match, minimum 8 characters)

		Returns:
			Flashcard details or error message
		"""
		if len(card_id) < 8:
			return {"error": "card_id must be at least 8 characters"}

		card = db_get_card(card_id)
		if not card:
			return {"error": f"Flashcard not found: {card_id}"}

		# Convert datetime objects
		for key in ["last_reviewed", "next_review", "note_mtime", "created_at", "updated_at"]:
			if card.get(key):
				card[key] = card[key].isoformat()

		return card

	@mcp.tool()
	def create_flashcard(
		question: str,
		answer: str,
		note_path: str = "manual",
		topic: str = "",
		difficulty: int = 2,
	) -> dict:
		"""
		Create a single flashcard manually.

		Args:
			question: The question text
			answer: The answer text
			note_path: Source note path (default: 'manual' for manually created)
			topic: Optional topic/category
			difficulty: Initial difficulty 1=easy, 2=medium, 3=hard (default: 2)

		Returns:
			Created flashcard details with ID
		"""
		if not question.strip():
			return {"error": "Question cannot be empty"}
		if not answer.strip():
			return {"error": "Answer cannot be empty"}
		if difficulty not in [1, 2, 3]:
			return {"error": "Difficulty must be 1, 2, or 3"}

		cards = [{
			"question": question.strip(),
			"answer": answer.strip(),
			"topic": topic.strip() if topic else None,
		}]

		count = db_insert_cards(
			cards=cards,
			note_path=note_path,
			note_uuid=None,
			note_mtime=datetime.now(),
		)

		if count > 0:
			# Fetch the created card to return it
			result = db_get_cards(limit=1, note_path=note_path)
			if result:
				card = result[0]
				for key in ["last_reviewed", "next_review", "note_mtime", "created_at", "updated_at"]:
					if card.get(key):
						card[key] = card[key].isoformat()
				return {"created": True, "card": card}

		return {"error": "Failed to create flashcard"}

	@mcp.tool()
	def generate_flashcards_from_content(
		content: str,
		source_name: str = "mcp-input",
		cards_per_note: int = 5,
	) -> dict:
		"""
		Generate flashcards from text content using AI.

		Args:
			content: The text content to generate flashcards from
			source_name: Name to identify the source (default: 'mcp-input')
			cards_per_note: Target number of cards to generate (default: 5)

		Returns:
			Dictionary with generated cards or error
		"""
		if not content.strip():
			return {"error": "Content cannot be empty"}

		if len(content) < 50:
			return {"error": "Content too short (minimum 50 characters)"}

		import subprocess as sp

		# Call flashcards CLI to generate from stdin
		try:
			result = sp.run(
				["flashcards", "--generate", "--stdin", "--cards-per-note", str(cards_per_note)],
				input=content,
				capture_output=True,
				text=True,
				timeout=120,
				env={**os.environ, "NO_DBOX_CHECK": "1"},
			)

			if result.returncode != 0:
				return {"error": f"Generation failed: {result.stderr}"}

			# Parse the JSON output
			try:
				data = json.loads(result.stdout)
				cards = data.get("flashcards", [])

				# Insert the cards
				if cards:
					count = db_insert_cards(
						cards=cards,
						note_path=source_name,
						note_uuid=None,
						note_mtime=datetime.now(),
					)
					return {"generated": count, "cards": cards}
				else:
					return {"error": "No cards generated from content"}

			except json.JSONDecodeError:
				return {"error": "Failed to parse generated cards"}

		except sp.TimeoutExpired:
			return {"error": "Generation timed out"}
		except Exception as e:
			return {"error": f"Generation error: {str(e)}"}

	@mcp.tool()
	def update_flashcard(
		card_id: str,
		question: str = "",
		answer: str = "",
		topic: str = "",
		difficulty: int = 0,
	) -> dict:
		"""
		Update an existing flashcard.

		Args:
			card_id: UUID of the flashcard to update (minimum 8 characters)
			question: New question text (empty string = no change)
			answer: New answer text (empty string = no change)
			topic: New topic (empty string = no change)
			difficulty: New difficulty 1-3 (0 = no change)

		Returns:
			Updated flashcard or error
		"""
		if len(card_id) < 8:
			return {"error": "card_id must be at least 8 characters"}

		# Check card exists
		existing = db_get_card(card_id)
		if not existing:
			return {"error": f"Flashcard not found: {card_id}"}

		updates = {}
		if question.strip():
			updates["question"] = question.strip()
		if answer.strip():
			updates["answer"] = answer.strip()
		if topic.strip():
			updates["topic"] = topic.strip()
		if difficulty in [1, 2, 3]:
			updates["difficulty"] = difficulty

		if not updates:
			return {"error": "No valid updates provided"}

		success = db_update_card(card_id, updates)
		if success:
			updated = db_get_card(card_id)
			for key in ["last_reviewed", "next_review", "note_mtime", "created_at", "updated_at"]:
				if updated.get(key):
					updated[key] = updated[key].isoformat()
			return {"updated": True, "card": updated}

		return {"error": "Failed to update flashcard"}

	@mcp.tool()
	def delete_flashcard(card_id: str, confirm: bool = False) -> dict:
		"""
		Delete a flashcard.

		Args:
			card_id: UUID of the flashcard to delete (minimum 8 characters)
			confirm: Must be True to actually delete (safety check)

		Returns:
			Deletion result
		"""
		if not confirm:
			return {"error": "Set confirm=True to delete the flashcard"}

		if len(card_id) < 8:
			return {"error": "card_id must be at least 8 characters"}

		# Check card exists
		existing = db_get_card(card_id)
		if not existing:
			return {"error": f"Flashcard not found: {card_id}"}

		success = db_delete_card(card_id)
		if success:
			return {"deleted": True, "card_id": existing["id"]}

		return {"error": "Failed to delete flashcard"}

	@mcp.tool()
	def delete_flashcards_by_note(note_path: str, confirm: bool = False) -> dict:
		"""
		Delete all flashcards for a specific note.

		Args:
			note_path: The note path to delete cards for
			confirm: Must be True to actually delete (safety check)

		Returns:
			Deletion result with count
		"""
		if not confirm:
			return {"error": "Set confirm=True to delete flashcards"}

		if not note_path.strip():
			return {"error": "note_path cannot be empty"}

		# Get cards to delete
		cards = db_get_cards(limit=1000, note_path=note_path)
		if not cards:
			return {"error": f"No flashcards found for note: {note_path}"}

		card_ids = [c["id"] for c in cards]
		count = db_delete_cards_bulk(card_ids)

		return {"deleted": count, "note_path": note_path}

	@mcp.tool()
	def get_flashcard_stats() -> dict:
		"""
		Get flashcard statistics.

		Returns:
			Dictionary with total cards, difficulty breakdown, due counts, etc.
		"""
		stats = db_get_stats()

		# Map difficulty numbers to names
		diff_names = {1: "easy", 2: "medium", 3: "hard"}
		by_difficulty = {}
		for diff, count in stats.get("by_difficulty", {}).items():
			name = diff_names.get(diff, f"unknown_{diff}")
			by_difficulty[name] = count

		return {
			"total_cards": stats.get("total_cards", 0),
			"notes_with_cards": stats.get("notes_with_cards", 0),
			"avg_cards_per_note": stats.get("avg_cards_per_note", 0),
			"due_for_review": stats.get("due_for_review", 0),
			"total_reviews": stats.get("total_reviews", 0),
			"by_difficulty": by_difficulty,
		}

	@mcp.tool()
	def review_flashcard(card_id: str, rating: int) -> dict:
		"""
		Record a review rating for a flashcard.

		This updates the card's review statistics and calculates the next review date
		based on spaced repetition algorithms.

		Args:
			card_id: UUID of the flashcard (minimum 8 characters)
			rating: Review rating: 1=easy (knew instantly), 2=medium (had to think), 3=hard (struggled)

		Returns:
			Updated card with new next_review date
		"""
		if len(card_id) < 8:
			return {"error": "card_id must be at least 8 characters"}

		if rating not in [1, 2, 3]:
			return {"error": "Rating must be 1 (easy), 2 (medium), or 3 (hard)"}

		# Check card exists
		existing = db_get_card(card_id)
		if not existing:
			return {"error": f"Flashcard not found: {card_id}"}

		db_update_after_review(card_id, rating)

		# Return updated card
		updated = db_get_card(card_id)
		for key in ["last_reviewed", "next_review", "note_mtime", "created_at", "updated_at"]:
			if updated.get(key):
				updated[key] = updated[key].isoformat()

		rating_names = {1: "easy", 2: "medium", 3: "hard"}
		return {
			"reviewed": True,
			"rating": rating_names[rating],
			"card": updated,
		}

	@mcp.tool()
	def get_review_session(
		max_cards: int = 20,
		difficulty: str = "",
		topic: str = "",
		para: str = "",
		due_only: bool = False,
	) -> dict:
		"""
		Get a set of flashcards for a review session.

		Args:
			max_cards: Maximum cards to include (default: 20)
			difficulty: Filter by difficulty: 'easy', 'medium', 'hard', or '' for all
			topic: Filter by path segment (e.g., 'repos/dotfiles')
			para: Filter by PARA category: 'inbox', 'projects', 'areas', 'resources', 'archives'
			due_only: Only include cards due for review

		Returns:
			Dictionary with shuffled cards for review
		"""
		max_cards = min(max_cards, 100)
		diff_map = {"easy": 1, "medium": 2, "hard": 3, "": None}
		diff_int = diff_map.get(difficulty.lower(), None)

		para_map = {
			"inbox": "00_inbox",
			"projects": "01_projects",
			"areas": "02_areas",
			"resources": "03_resources",
			"archives": "04_archives",
		}
		para_prefix = para_map.get(para.lower(), "") if para else ""

		cards = db_get_review_cards(
			max_cards=max_cards * 2,  # Get extra for filtering
			difficulty=diff_int,
			topic=topic if topic else None,
			due_only=due_only,
		)

		# Apply para filter
		if para_prefix:
			cards = [c for c in cards if c.get("note_path", "").startswith(para_prefix + "/")]

		# Apply topic path filter
		if topic:
			cards = [c for c in cards if f"/{topic}/" in c.get("note_path", "")]

		# Shuffle and limit
		random.shuffle(cards)
		cards = cards[:max_cards]

		# Convert datetime objects
		for card in cards:
			for key in ["last_reviewed", "next_review", "note_mtime", "created_at", "updated_at"]:
				if card.get(key):
					card[key] = card[key].isoformat()

		return {
			"session_cards": cards,
			"count": len(cards),
			"filters": {
				"difficulty": difficulty or "all",
				"topic": topic or "all",
				"para": para or "all",
				"due_only": due_only,
			}
		}

	@mcp.tool()
	def search_flashcards(query: str, limit: int = 20) -> dict:
		"""
		Search flashcards by question or answer text.

		Args:
			query: Search query (searches in question and answer fields)
			limit: Maximum results (default: 20, max: 100)

		Returns:
			Matching flashcards
		"""
		if not query.strip():
			return {"error": "Search query cannot be empty"}

		limit = min(limit, 100)

		# Search in database
		conditions = []
		params = []

		conditions.append("(question ILIKE %s OR answer ILIKE %s)")
		params.extend([f"%{query}%", f"%{query}%"])

		where_clause = "WHERE " + " AND ".join(conditions)

		query_sql = f"""
			SELECT id::text, note_path, question, answer, topic, difficulty,
				   times_reviewed, last_reviewed, next_review
			FROM flashcards
			{where_clause}
			ORDER BY updated_at DESC
			LIMIT %s
		"""
		params.append(limit)

		cards = []
		with get_flashcards_connection() as conn:
			with conn.cursor(cursor_factory=RealDictCursor) as cur:
				cur.execute(query_sql, params)
				cards = [dict(row) for row in cur.fetchall()]

		# Convert datetime objects
		for card in cards:
			for key in ["last_reviewed", "next_review"]:
				if card.get(key):
					card[key] = card[key].isoformat()

		return {"results": cards, "count": len(cards), "query": query}

	return mcp


def run_mcp_server(transport: str = "stdio", host: str = "127.0.0.1", port: int = 5003) -> int:
	"""
	Run the MCP server.

	Args:
		transport: Transport type - 'stdio' or 'streamable-http'
		host: Host to bind to (for HTTP transport)
		port: Port to bind to (for HTTP transport)
	"""
	# Check database first
	try:
		conn = get_flashcards_connection()
		conn.close()
	except Exception as e:
		print(f"Error: Could not connect to flashcards database: {e}", file=sys.stderr)
		print("Make sure to run: local_postgres init-flashcards", file=sys.stderr)
		return 1

	# Create MCP server with host/port configured (used by HTTP transport)
	mcp = create_mcp_server(host=host, port=port)

	if transport == "stdio":
		mcp.run(transport="stdio")
	elif transport in ("http", "streamable-http"):
		print(f"Starting MCP server (HTTP) on http://{host}:{port}", file=sys.stderr)
		mcp.run(transport="streamable-http")
	else:
		print(f"Error: Unknown transport: {transport}", file=sys.stderr)
		return 1

	return 0


# ============================================================================
# TEMPLATES: SHARED CSS
# ============================================================================

BASE_CSS: str = '''
:root {
	--bg-primary: #1e1e2e;
	--bg-secondary: #313244;
	--bg-tertiary: #45475a;
	--text-primary: #cdd6f4;
	--text-secondary: #a6adc8;
	--text-muted: #6c7086;
	--accent: #89b4fa;
	--accent-hover: #b4befe;
	--success: #a6e3a1;
	--warning: #f9e2af;
	--error: #f38ba8;
	--border: #585b70;
	--shadow: rgba(0, 0, 0, 0.3);
}

:root[data-theme="light"] {
	--bg-primary: #eff1f5;
	--bg-secondary: #e6e9ef;
	--bg-tertiary: #dce0e8;
	--text-primary: #4c4f69;
	--text-secondary: #5c5f77;
	--text-muted: #9ca0b0;
	--accent: #1e66f5;
	--accent-hover: #7287fd;
	--success: #40a02b;
	--warning: #df8e1d;
	--error: #d20f39;
	--border: #bcc0cc;
	--shadow: rgba(0, 0, 0, 0.1);
}

* {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

body {
	font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
	background: var(--bg-primary);
	color: var(--text-primary);
	line-height: 1.6;
	min-height: 100vh;
}

a {
	color: var(--accent);
	text-decoration: none;
}

a:hover {
	color: var(--accent-hover);
	text-decoration: underline;
}

.container {
	max-width: 1200px;
	margin: 0 auto;
	padding: 20px;
}

.header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 16px 24px;
	background: var(--bg-secondary);
	border-bottom: 1px solid var(--border);
	margin-bottom: 24px;
}

.header h1 {
	font-size: 1.5rem;
	display: flex;
	align-items: center;
	gap: 10px;
}

.header nav {
	display: flex;
	gap: 16px;
	align-items: center;
}

.header nav a {
	padding: 8px 16px;
	border-radius: 6px;
	transition: background 0.2s;
}

.header nav a:hover {
	background: var(--bg-tertiary);
	text-decoration: none;
}

.btn {
	display: inline-flex;
	align-items: center;
	gap: 8px;
	padding: 10px 20px;
	border: none;
	border-radius: 8px;
	font-size: 14px;
	font-weight: 500;
	cursor: pointer;
	transition: all 0.2s;
}

.btn-primary {
	background: var(--accent);
	color: var(--bg-primary);
}

.btn-primary:hover {
	background: var(--accent-hover);
}

.btn-secondary {
	background: var(--bg-tertiary);
	color: var(--text-primary);
}

.btn-secondary:hover {
	background: var(--border);
}

.btn-danger {
	background: var(--error);
	color: white;
}

.btn-danger:hover {
	opacity: 0.9;
}

.btn-success {
	background: var(--success);
	color: var(--bg-primary);
}

.btn-warning {
	background: var(--warning);
	color: var(--bg-primary);
}

.btn-sm {
	padding: 6px 12px;
	font-size: 12px;
}

.card {
	background: var(--bg-secondary);
	border-radius: 12px;
	padding: 20px;
	margin-bottom: 16px;
	border: 1px solid var(--border);
}

.card-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 16px;
	padding-bottom: 12px;
	border-bottom: 1px solid var(--border);
}

.form-group {
	margin-bottom: 16px;
}

.form-group label {
	display: block;
	margin-bottom: 6px;
	font-weight: 500;
	color: var(--text-secondary);
}

.form-control {
	width: 100%;
	padding: 10px 14px;
	border: 1px solid var(--border);
	border-radius: 8px;
	background: var(--bg-primary);
	color: var(--text-primary);
	font-size: 14px;
	transition: border-color 0.2s;
}

.form-control:focus {
	outline: none;
	border-color: var(--accent);
}

textarea.form-control {
	min-height: 100px;
	resize: vertical;
}

select.form-control {
	cursor: pointer;
}

.badge {
	display: inline-block;
	padding: 4px 10px;
	border-radius: 20px;
	font-size: 12px;
	font-weight: 500;
}

.badge-easy {
	background: var(--success);
	color: var(--bg-primary);
}

.badge-medium {
	background: var(--warning);
	color: var(--bg-primary);
}

.badge-hard {
	background: var(--error);
	color: white;
}

.stats-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
	gap: 16px;
	margin-bottom: 24px;
}

.stat-card {
	background: var(--bg-secondary);
	border-radius: 12px;
	padding: 20px;
	text-align: center;
	border: 1px solid var(--border);
}

.stat-value {
	font-size: 2.5rem;
	font-weight: 700;
	color: var(--accent);
}

.stat-label {
	color: var(--text-secondary);
	font-size: 14px;
	margin-top: 4px;
}

.table-container {
	overflow-x: auto;
}

table {
	width: 100%;
	border-collapse: collapse;
}

th, td {
	padding: 12px 16px;
	text-align: left;
	border-bottom: 1px solid var(--border);
}

th {
	background: var(--bg-tertiary);
	font-weight: 600;
	color: var(--text-secondary);
}

tr:hover {
	background: var(--bg-tertiary);
}

.checkbox-cell {
	width: 40px;
}

.theme-toggle {
	background: var(--bg-tertiary);
	border: none;
	padding: 8px 12px;
	border-radius: 6px;
	cursor: pointer;
	color: var(--text-primary);
	font-size: 16px;
}

.hidden {
	display: none !important;
}

.bulk-actions {
	position: fixed;
	bottom: 20px;
	left: 50%;
	transform: translateX(-50%);
	background: var(--bg-secondary);
	padding: 16px 24px;
	border-radius: 12px;
	box-shadow: 0 4px 20px var(--shadow);
	display: flex;
	gap: 12px;
	align-items: center;
	border: 1px solid var(--border);
	z-index: 100;
}

.selected-count {
	font-weight: 600;
	color: var(--accent);
}

.tabs {
	display: flex;
	gap: 4px;
	margin-bottom: 20px;
	background: var(--bg-tertiary);
	padding: 4px;
	border-radius: 10px;
	width: fit-content;
}

.tab {
	padding: 10px 20px;
	border: none;
	background: transparent;
	color: var(--text-secondary);
	cursor: pointer;
	border-radius: 8px;
	font-weight: 500;
	transition: all 0.2s;
}

.tab.active {
	background: var(--bg-secondary);
	color: var(--text-primary);
}

.tab:hover:not(.active) {
	color: var(--text-primary);
}

.progress-bar {
	width: 100%;
	height: 8px;
	background: var(--bg-tertiary);
	border-radius: 4px;
	overflow: hidden;
	margin-bottom: 16px;
}

.progress-fill {
	height: 100%;
	background: var(--accent);
	transition: width 0.3s ease;
}

.empty-state {
	text-align: center;
	padding: 60px 20px;
	color: var(--text-muted);
}

.empty-state h3 {
	margin-bottom: 8px;
	color: var(--text-secondary);
}

.alert {
	padding: 12px 16px;
	border-radius: 8px;
	margin-bottom: 16px;
}

.alert-success {
	background: rgba(166, 227, 161, 0.2);
	border: 1px solid var(--success);
	color: var(--success);
}

.alert-error {
	background: rgba(243, 139, 168, 0.2);
	border: 1px solid var(--error);
	color: var(--error);
}

.loading {
	display: flex;
	align-items: center;
	justify-content: center;
	padding: 40px;
}

.spinner {
	width: 40px;
	height: 40px;
	border: 3px solid var(--bg-tertiary);
	border-top-color: var(--accent);
	border-radius: 50%;
	animation: spin 0.8s linear infinite;
}

@keyframes spin {
	to { transform: rotate(360deg); }
}

@media (max-width: 768px) {
	.header {
		flex-direction: column;
		gap: 16px;
	}

	.header nav {
		flex-wrap: wrap;
		justify-content: center;
	}

	.stats-grid {
		grid-template-columns: repeat(2, 1fr);
	}
}
'''

# ============================================================================
# TEMPLATES: FLASHCARD CSS
# ============================================================================

FLASHCARD_CSS: str = '''
.flashcard-container {
	perspective: 1000px;
	width: 100%;
	max-width: 700px;
	height: 450px;
	margin: 0 auto 24px;
}

.flashcard {
	position: relative;
	width: 100%;
	height: 100%;
	transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
	transform-style: preserve-3d;
	cursor: pointer;
}

.flashcard.flipped {
	transform: rotateY(180deg);
}

.flashcard-face {
	position: absolute;
	width: 100%;
	height: 100%;
	backface-visibility: hidden;
	-webkit-backface-visibility: hidden;
	border-radius: 16px;
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	padding: 32px;
	background: var(--bg-secondary);
	border: 2px solid var(--border);
	box-shadow: 0 10px 40px var(--shadow);
}

.flashcard-front {
	background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
}

.flashcard-back {
	transform: rotateY(180deg);
	background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
}

.flashcard-label {
	position: absolute;
	top: 16px;
	left: 16px;
	font-size: 12px;
	font-weight: 600;
	color: var(--text-muted);
	text-transform: uppercase;
	letter-spacing: 1px;
}

.flashcard-content {
	font-size: 1.4rem;
	text-align: center;
	line-height: 1.6;
	max-height: 100%;
	overflow-y: auto;
}

.flashcard-meta {
	position: absolute;
	bottom: 16px;
	display: flex;
	gap: 12px;
	font-size: 12px;
	color: var(--text-muted);
}

.review-controls {
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 16px;
}

.flip-hint {
	color: var(--text-muted);
	font-size: 14px;
}

.rating-buttons {
	display: flex;
	gap: 12px;
	flex-wrap: wrap;
	justify-content: center;
}

.rating-btn {
	padding: 14px 28px;
	border: 2px solid transparent;
	border-radius: 10px;
	font-size: 16px;
	font-weight: 600;
	cursor: pointer;
	transition: all 0.2s;
}

.rating-btn:hover {
	transform: translateY(-2px);
}

.rating-easy {
	background: var(--success);
	color: var(--bg-primary);
}

.rating-easy:hover {
	box-shadow: 0 4px 20px rgba(166, 227, 161, 0.4);
}

.rating-medium {
	background: var(--warning);
	color: var(--bg-primary);
}

.rating-medium:hover {
	box-shadow: 0 4px 20px rgba(249, 226, 175, 0.4);
}

.rating-hard {
	background: var(--error);
	color: white;
}

.rating-hard:hover {
	box-shadow: 0 4px 20px rgba(243, 139, 168, 0.4);
}

.rating-skip {
	background: var(--bg-tertiary);
	color: var(--text-primary);
}

.review-progress {
	text-align: center;
	margin-bottom: 20px;
}

.review-progress-text {
	font-size: 14px;
	color: var(--text-secondary);
	margin-bottom: 8px;
}

.session-summary {
	max-width: 500px;
	margin: 0 auto;
	text-align: center;
}

.session-summary h2 {
	margin-bottom: 24px;
}

.summary-stats {
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	gap: 16px;
	margin-bottom: 24px;
}

.summary-stat {
	padding: 16px;
	background: var(--bg-tertiary);
	border-radius: 10px;
}

.summary-stat-value {
	font-size: 2rem;
	font-weight: 700;
}

.summary-stat-label {
	font-size: 12px;
	color: var(--text-muted);
}

.keyboard-shortcuts {
	display: flex;
	justify-content: center;
	gap: 20px;
	margin-top: 20px;
	font-size: 13px;
	color: var(--text-muted);
}

.keyboard-shortcuts kbd {
	display: inline-block;
	padding: 2px 8px;
	background: var(--bg-tertiary);
	border-radius: 4px;
	font-family: monospace;
	margin-right: 4px;
}
'''

# ============================================================================
# TEMPLATES: SHARED JAVASCRIPT
# ============================================================================

BASE_JS: str = '''
function toggleTheme() {
	const html = document.documentElement;
	const current = html.getAttribute('data-theme') || 'dark';
	const next = current === 'dark' ? 'light' : 'dark';
	html.setAttribute('data-theme', next);
	localStorage.setItem('theme', next);
}

// Initialize theme from localStorage
(function() {
	const saved = localStorage.getItem('theme');
	if (saved) {
		document.documentElement.setAttribute('data-theme', saved);
	}
})();

// Bulk selection
let selectedCards = new Set();

function toggleCardSelection(cardId, checkbox) {
	if (checkbox.checked) {
		selectedCards.add(cardId);
	} else {
		selectedCards.delete(cardId);
	}
	updateBulkActionsUI();
}

function selectAllCards(checkbox) {
	document.querySelectorAll('.card-checkbox').forEach(cb => {
		cb.checked = checkbox.checked;
		if (checkbox.checked) {
			selectedCards.add(cb.dataset.cardId);
		} else {
			selectedCards.delete(cb.dataset.cardId);
		}
	});
	updateBulkActionsUI();
}

function updateBulkActionsUI() {
	const bulkActions = document.getElementById('bulk-actions');
	const count = document.getElementById('selected-count');

	if (bulkActions) {
		if (selectedCards.size > 0) {
			bulkActions.classList.remove('hidden');
			count.textContent = selectedCards.size;
		} else {
			bulkActions.classList.add('hidden');
		}
	}
}

async function bulkDelete() {
	if (!confirm(`Delete ${selectedCards.size} cards?`)) return;

	const response = await fetch('/api/cards/bulk', {
		method: 'DELETE',
		headers: {'Content-Type': 'application/json'},
		body: JSON.stringify({card_ids: Array.from(selectedCards)})
	});

	if (response.ok) {
		location.reload();
	} else {
		alert('Failed to delete cards');
	}
}

async function bulkChangeDifficulty(difficulty) {
	const response = await fetch('/api/cards/bulk', {
		method: 'PUT',
		headers: {'Content-Type': 'application/json'},
		body: JSON.stringify({
			card_ids: Array.from(selectedCards),
			updates: {difficulty: difficulty}
		})
	});

	if (response.ok) {
		location.reload();
	} else {
		alert('Failed to update cards');
	}
}

function cancelBulkSelection() {
	selectedCards.clear();
	document.querySelectorAll('.card-checkbox').forEach(cb => cb.checked = false);
	document.getElementById('select-all-checkbox').checked = false;
	updateBulkActionsUI();
}
'''

# ============================================================================
# TEMPLATES: PAGE BUILDER
# ============================================================================

def build_page(title: str, content: str, extra_css: str = "", extra_js: str = "") -> str:
	"""Build a complete HTML page."""
	return f'''<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>{title} - Flashcards</title>
	<style>{BASE_CSS}{extra_css}</style>
</head>
<body>
	<header class="header">
		<h1><a href="/" style="color: inherit; text-decoration: none;">Flashcards</a></h1>
		<nav>
			<a href="/">Dashboard</a>
			<a href="/review">Review</a>
			<a href="/cards">Cards</a>
			<a href="/generate">Generate</a>
			<a href="/stats">Stats</a>
			<button class="theme-toggle" onclick="toggleTheme()">Theme</button>
		</nav>
	</header>
	<main class="container">
		{content}
	</main>
	<script>{BASE_JS}{extra_js}</script>
</body>
</html>'''


def render_markdown(text: str) -> str:
	"""Render markdown to HTML if available."""
	if markdown:
		return markdown.markdown(text, extensions=['fenced_code', 'tables'])
	return f"<p>{text}</p>"


# ============================================================================
# ROUTE HANDLERS
# ============================================================================

def create_app(debug: bool = False) -> Quart:
	"""Create and configure the Quart application."""
	app = Quart(__name__)
	app.config['DEBUG'] = debug

	# ---- Dashboard ----
	@app.route('/')
	async def index():
		stats = db_get_stats()

		content = f'''
		<h2>Dashboard</h2>

		<div class="stats-grid">
			<div class="stat-card">
				<div class="stat-value">{stats["total_cards"]}</div>
				<div class="stat-label">Total Cards</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["due_for_review"]}</div>
				<div class="stat-label">Due for Review</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["notes_with_cards"]}</div>
				<div class="stat-label">Notes</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["total_reviews"]}</div>
				<div class="stat-label">Total Reviews</div>
			</div>
		</div>

		<div style="display: flex; gap: 16px; margin-bottom: 24px;">
			<a href="/review" class="btn btn-primary">Start Review Session</a>
			<a href="/generate" class="btn btn-secondary">Generate Cards</a>
		</div>

		<div class="card">
			<h3 style="margin-bottom: 16px;">Cards by Difficulty</h3>
			<div style="display: flex; gap: 24px;">
				<div><span class="badge badge-easy">Easy</span> {stats["by_difficulty"].get(1, 0)}</div>
				<div><span class="badge badge-medium">Medium</span> {stats["by_difficulty"].get(2, 0)}</div>
				<div><span class="badge badge-hard">Hard</span> {stats["by_difficulty"].get(3, 0)}</div>
			</div>
		</div>
		'''

		if stats["top_topics"]:
			topics_html = "".join([
				f'<div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border);"><span>{t["topic"]}</span><span>{t["count"]}</span></div>'
				for t in stats["top_topics"]
			])
			content += f'''
			<div class="card">
				<h3 style="margin-bottom: 16px;">Top Topics</h3>
				{topics_html}
			</div>
			'''

		return build_page("Dashboard", content)

	# ---- Cards List ----
	@app.route('/cards')
	async def cards_list():
		difficulty = request.args.get('difficulty', type=int)
		topic = request.args.get('topic')
		note = request.args.get('note')
		search = request.args.get('search')

		cards = db_get_cards(
			limit=100,
			difficulty=difficulty,
			topic=topic,
			note_path=note,
			search=search,
		)

		diff_names = {1: "Easy", 2: "Medium", 3: "Hard"}
		diff_badges = {1: "badge-easy", 2: "badge-medium", 3: "badge-hard"}

		rows = ""
		for card in cards:
			question_preview = card["question"][:60] + "..." if len(card["question"]) > 60 else card["question"]
			diff = card["difficulty"]
			rows += f'''
			<tr>
				<td class="checkbox-cell">
					<input type="checkbox" class="card-checkbox" data-card-id="{card["id"]}"
					       onchange="toggleCardSelection('{card["id"]}', this)">
				</td>
				<td><a href="/cards/{card["id"]}">{question_preview}</a></td>
				<td>{card["topic"] or "-"}</td>
				<td><span class="badge {diff_badges.get(diff, "")}">{diff_names.get(diff, "?")}</span></td>
				<td>{card["times_reviewed"]}</td>
				<td>
					<a href="/cards/{card["id"]}/edit" class="btn btn-sm btn-secondary">Edit</a>
				</td>
			</tr>
			'''

		if not cards:
			rows = '<tr><td colspan="6" class="empty-state">No cards found</td></tr>'

		content = f'''
		<div class="card-header">
			<h2>Flashcards</h2>
			<a href="/generate" class="btn btn-primary">Generate New</a>
		</div>

		<div class="card" style="margin-bottom: 20px;">
			<form method="get" style="display: flex; gap: 12px; flex-wrap: wrap; align-items: end;">
				<div class="form-group" style="margin-bottom: 0;">
					<label>Search</label>
					<input type="text" name="search" class="form-control" value="{search or ""}" placeholder="Search questions...">
				</div>
				<div class="form-group" style="margin-bottom: 0;">
					<label>Difficulty</label>
					<select name="difficulty" class="form-control">
						<option value="">All</option>
						<option value="1" {"selected" if difficulty == 1 else ""}>Easy</option>
						<option value="2" {"selected" if difficulty == 2 else ""}>Medium</option>
						<option value="3" {"selected" if difficulty == 3 else ""}>Hard</option>
					</select>
				</div>
				<div class="form-group" style="margin-bottom: 0;">
					<label>Topic</label>
					<input type="text" name="topic" class="form-control" value="{topic or ""}" placeholder="Topic...">
				</div>
				<button type="submit" class="btn btn-secondary">Filter</button>
				<a href="/cards" class="btn btn-secondary">Clear</a>
			</form>
		</div>

		<div class="card">
			<div class="table-container">
				<table>
					<thead>
						<tr>
							<th class="checkbox-cell">
								<input type="checkbox" id="select-all-checkbox" onchange="selectAllCards(this)">
							</th>
							<th>Question</th>
							<th>Topic</th>
							<th>Difficulty</th>
							<th>Reviews</th>
							<th>Actions</th>
						</tr>
					</thead>
					<tbody>
						{rows}
					</tbody>
				</table>
			</div>
		</div>

		<div id="bulk-actions" class="bulk-actions hidden">
			<span><span id="selected-count">0</span> selected</span>
			<button class="btn btn-sm btn-success" onclick="bulkChangeDifficulty(1)">Set Easy</button>
			<button class="btn btn-sm btn-warning" onclick="bulkChangeDifficulty(2)">Set Medium</button>
			<button class="btn btn-sm btn-danger" onclick="bulkChangeDifficulty(3)">Set Hard</button>
			<button class="btn btn-sm btn-danger" onclick="bulkDelete()">Delete</button>
			<button class="btn btn-sm btn-secondary" onclick="cancelBulkSelection()">Cancel</button>
		</div>
		'''

		return build_page("Cards", content)

	# ---- Card Detail ----
	@app.route('/cards/<card_id>')
	async def card_detail(card_id):
		card = db_get_card(card_id)
		if not card:
			return build_page("Not Found", '<div class="empty-state"><h3>Card not found</h3></div>'), 404

		diff_names = {1: "Easy", 2: "Medium", 3: "Hard"}
		diff_badges = {1: "badge-easy", 2: "badge-medium", 3: "badge-hard"}

		answer_html = render_markdown(card["answer"])

		content = f'''
		<div class="card">
			<div class="card-header">
				<h2>Card Details</h2>
				<div style="display: flex; gap: 8px;">
					<a href="/cards/{card["id"]}/edit" class="btn btn-secondary">Edit</a>
					<form method="post" action="/cards/{card["id"]}/delete" style="display: inline;">
						<button type="submit" class="btn btn-danger" onclick="return confirm('Delete this card?')">Delete</button>
					</form>
				</div>
			</div>

			<div class="form-group">
				<label>Question</label>
				<div style="padding: 12px; background: var(--bg-primary); border-radius: 8px;">{card["question"]}</div>
			</div>

			<div class="form-group">
				<label>Answer</label>
				<div style="padding: 12px; background: var(--bg-primary); border-radius: 8px;">{answer_html}</div>
			</div>

			<div style="display: flex; gap: 24px; flex-wrap: wrap;">
				<div>
					<label style="color: var(--text-muted);">Topic</label>
					<div>{card["topic"] or "-"}</div>
				</div>
				<div>
					<label style="color: var(--text-muted);">Difficulty</label>
					<div><span class="badge {diff_badges.get(card["difficulty"], "")}">{diff_names.get(card["difficulty"], "?")}</span></div>
				</div>
				<div>
					<label style="color: var(--text-muted);">Times Reviewed</label>
					<div>{card["times_reviewed"]}</div>
				</div>
				<div>
					<label style="color: var(--text-muted);">Times Correct</label>
					<div>{card["times_correct"]}</div>
				</div>
			</div>

			<div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border); font-size: 13px; color: var(--text-muted);">
				Note: {card["note_path"]}
			</div>
		</div>

		<a href="/cards" class="btn btn-secondary">Back to Cards</a>
		'''

		return build_page("Card Detail", content)

	# ---- Card Edit ----
	@app.route('/cards/<card_id>/edit', methods=['GET', 'POST'])
	async def card_edit(card_id):
		card = db_get_card(card_id)
		if not card:
			return build_page("Not Found", '<div class="empty-state"><h3>Card not found</h3></div>'), 404

		message = ""
		if request.method == 'POST':
			form = await request.form
			updates = {
				"question": form.get("question"),
				"answer": form.get("answer"),
				"topic": form.get("topic"),
				"difficulty": int(form.get("difficulty", 2)),
			}
			if db_update_card(card["id"], updates):
				message = '<div class="alert alert-success">Card updated successfully!</div>'
				card = db_get_card(card_id)  # Refresh
			else:
				message = '<div class="alert alert-error">Failed to update card</div>'

		content = f'''
		{message}
		<div class="card">
			<h2 style="margin-bottom: 20px;">Edit Card</h2>

			<form method="post">
				<div class="form-group">
					<label>Question</label>
					<textarea name="question" class="form-control" rows="3">{card["question"]}</textarea>
				</div>

				<div class="form-group">
					<label>Answer</label>
					<textarea name="answer" class="form-control" rows="5">{card["answer"]}</textarea>
				</div>

				<div class="form-group">
					<label>Topic</label>
					<input type="text" name="topic" class="form-control" value="{card["topic"] or ""}">
				</div>

				<div class="form-group">
					<label>Difficulty</label>
					<select name="difficulty" class="form-control">
						<option value="1" {"selected" if card["difficulty"] == 1 else ""}>Easy</option>
						<option value="2" {"selected" if card["difficulty"] == 2 else ""}>Medium</option>
						<option value="3" {"selected" if card["difficulty"] == 3 else ""}>Hard</option>
					</select>
				</div>

				<div style="display: flex; gap: 12px;">
					<button type="submit" class="btn btn-primary">Save Changes</button>
					<a href="/cards/{card["id"]}" class="btn btn-secondary">Cancel</a>
				</div>
			</form>
		</div>
		'''

		return build_page("Edit Card", content)

	# ---- Card Delete ----
	@app.route('/cards/<card_id>/delete', methods=['POST'])
	async def card_delete(card_id):
		db_delete_card(card_id)
		return redirect(url_for('cards_list'))

	# ---- Review Mode ----
	@app.route('/review')
	async def review_page():
		# JavaScript for fzf-style autocomplete
		autocomplete_js: str = '''
		<script>
		(function() {
			const topicInput = document.getElementById('topic-input');
			const paraSelect = document.getElementById('para-select');
			const suggestionsList = document.getElementById('suggestions-list');
			const selectedDisplay = document.getElementById('selected-topic');
			const clearBtn = document.getElementById('clear-topic');
			let debounceTimer = null;
			let selectedIndex = -1;
			let suggestions = [];

			function updateSuggestions(query) {
				const para = paraSelect.value;
				let url = '/api/autocomplete/paths?limit=15';
				if (query) url += '&q=' + encodeURIComponent(query);
				if (para) url += '&para=' + encodeURIComponent(para);

				fetch(url)
					.then(r => r.json())
					.then(data => {
						suggestions = data.paths || [];
						renderSuggestions(query);
					});
			}

			function renderSuggestions(query) {
				if (suggestions.length === 0) {
					suggestionsList.innerHTML = '<div class="suggestion-empty">No matches found</div>';
					suggestionsList.style.display = 'block';
					return;
				}

				const queryLower = (query || '').toLowerCase();
				suggestionsList.innerHTML = suggestions.map((s, i) => {
					let html = s;
					if (queryLower) {
						const idx = s.toLowerCase().indexOf(queryLower);
						if (idx >= 0) {
							html = s.slice(0, idx) +
								'<mark>' + s.slice(idx, idx + queryLower.length) + '</mark>' +
								s.slice(idx + queryLower.length);
						}
					}
					return '<div class="suggestion-item' + (i === selectedIndex ? ' selected' : '') +
						'" data-value="' + s + '">' + html + '</div>';
				}).join('');
				suggestionsList.style.display = 'block';
			}

			function selectSuggestion(value) {
				document.getElementById('topic-hidden').value = value;
				selectedDisplay.textContent = value;
				selectedDisplay.style.display = 'inline-block';
				clearBtn.style.display = 'inline-block';
				topicInput.value = '';
				suggestionsList.style.display = 'none';
				selectedIndex = -1;
			}

			function clearSelection() {
				document.getElementById('topic-hidden').value = '';
				selectedDisplay.style.display = 'none';
				clearBtn.style.display = 'none';
				topicInput.value = '';
				topicInput.focus();
			}

			topicInput.addEventListener('input', function() {
				clearTimeout(debounceTimer);
				selectedIndex = -1;
				debounceTimer = setTimeout(() => updateSuggestions(this.value), 150);
			});

			topicInput.addEventListener('focus', function() {
				updateSuggestions(this.value);
			});

			topicInput.addEventListener('keydown', function(e) {
				if (suggestions.length === 0) return;

				if (e.key === 'ArrowDown') {
					e.preventDefault();
					selectedIndex = Math.min(selectedIndex + 1, suggestions.length - 1);
					renderSuggestions(this.value);
				} else if (e.key === 'ArrowUp') {
					e.preventDefault();
					selectedIndex = Math.max(selectedIndex - 1, 0);
					renderSuggestions(this.value);
				} else if (e.key === 'Enter' && selectedIndex >= 0) {
					e.preventDefault();
					selectSuggestion(suggestions[selectedIndex]);
				} else if (e.key === 'Escape') {
					suggestionsList.style.display = 'none';
					selectedIndex = -1;
				} else if (e.key === 'Tab' && selectedIndex >= 0) {
					e.preventDefault();
					selectSuggestion(suggestions[selectedIndex]);
				}
			});

			suggestionsList.addEventListener('click', function(e) {
				const item = e.target.closest('.suggestion-item');
				if (item) {
					selectSuggestion(item.dataset.value);
				}
			});

			clearBtn.addEventListener('click', clearSelection);

			paraSelect.addEventListener('change', function() {
				if (topicInput.value || suggestionsList.style.display === 'block') {
					updateSuggestions(topicInput.value);
				}
			});

			document.addEventListener('click', function(e) {
				if (!e.target.closest('.autocomplete-container')) {
					suggestionsList.style.display = 'none';
				}
			});
		})();
		</script>
		'''

		# CSS for the autocomplete
		autocomplete_css: str = '''
		<style>
		.autocomplete-container {
			position: relative;
		}
		.autocomplete-input-wrapper {
			display: flex;
			align-items: center;
			gap: 8px;
			flex-wrap: wrap;
		}
		.autocomplete-input-wrapper input[type="text"] {
			flex: 1;
			min-width: 200px;
		}
		.selected-tag {
			display: none;
			background: var(--accent);
			color: var(--bg-primary);
			padding: 4px 8px;
			border-radius: 4px;
			font-size: 14px;
			font-family: monospace;
		}
		.clear-btn {
			display: none;
			background: none;
			border: none;
			color: var(--text-muted);
			cursor: pointer;
			padding: 4px 8px;
			font-size: 16px;
		}
		.clear-btn:hover {
			color: var(--error);
		}
		#suggestions-list {
			display: none;
			position: absolute;
			top: 100%;
			left: 0;
			right: 0;
			max-height: 300px;
			overflow-y: auto;
			background: var(--bg-secondary);
			border: 1px solid var(--border);
			border-radius: 4px;
			box-shadow: 0 4px 12px rgba(0,0,0,0.5);
			z-index: 100;
			margin-top: 4px;
		}
		.suggestion-item {
			padding: 10px 12px;
			cursor: pointer;
			border-bottom: 1px solid var(--border);
			font-family: monospace;
			font-size: 14px;
			background: var(--bg-secondary);
			color: var(--text-primary);
		}
		.suggestion-item:last-child {
			border-bottom: none;
		}
		.suggestion-item:hover,
		.suggestion-item.selected {
			background: var(--bg-tertiary);
		}
		.suggestion-item mark {
			background: var(--warning);
			color: var(--bg-primary);
			padding: 0 2px;
			border-radius: 2px;
		}
		.suggestion-empty {
			padding: 12px;
			color: var(--text-muted);
			font-style: italic;
			text-align: center;
		}
		.filter-hint {
			font-size: 12px;
			color: var(--text-muted);
			margin-top: 4px;
		}
		</style>
		'''

		content: str = f'''
		<h2>Start Review Session</h2>

		<div class="card">
			<form method="post" action="/review/start">
				<div class="form-group">
					<label>Maximum Cards</label>
					<input type="number" name="max_cards" class="form-control" value="20" min="1" max="100">
				</div>

				<div class="form-group">
					<label>PARA Category</label>
					<select name="para" id="para-select" class="form-control">
						<option value="">All Categories</option>
						<option value="inbox">Inbox (00_inbox)</option>
						<option value="projects">Projects (01_projects)</option>
						<option value="areas">Areas (02_areas)</option>
						<option value="resources">Resources (03_resources)</option>
						<option value="archives">Archives (04_archives)</option>
					</select>
				</div>

				<div class="form-group">
					<label>Topic / Path Filter</label>
					<div class="autocomplete-container">
						<div class="autocomplete-input-wrapper">
							<span id="selected-topic" class="selected-tag"></span>
							<button type="button" id="clear-topic" class="clear-btn" title="Clear selection">&times;</button>
							<input type="text" id="topic-input" class="form-control"
								placeholder="Type to search paths (fzf-style)..." autocomplete="off">
						</div>
						<input type="hidden" name="topic" id="topic-hidden" value="">
						<div id="suggestions-list"></div>
					</div>
					<div class="filter-hint">Use arrow keys to navigate, Enter/Tab to select, Esc to close</div>
				</div>

				<div class="form-group">
					<label>Difficulty Filter</label>
					<select name="difficulty" class="form-control">
						<option value="">All</option>
						<option value="1">Easy only</option>
						<option value="2">Medium only</option>
						<option value="3">Hard only</option>
					</select>
				</div>

				<div class="form-group">
					<label>
						<input type="checkbox" name="due_only" value="1"> Only show cards due for review
					</label>
				</div>

				<button type="submit" class="btn btn-primary">Start Review</button>
			</form>
		</div>
		{autocomplete_css}
		{autocomplete_js}
		'''

		return build_page("Review", content, FLASHCARD_CSS)

	@app.route('/review/start', methods=['POST'])
	async def review_start():
		form = await request.form
		max_cards: int = int(form.get('max_cards', 20))
		difficulty_str: str = form.get('difficulty', '')
		difficulty: Optional[int] = int(difficulty_str) if difficulty_str else None
		para: Optional[str] = form.get('para') or None
		topic: Optional[str] = form.get('topic') or None
		due_only: bool = form.get('due_only') == '1'

		card_ids: List[str] = db_get_review_cards(
			max_cards=max_cards,
			difficulty=difficulty,
			para=para,
			topic=topic,
			due_only=due_only,
		)

		if not card_ids:
			content: str = '''
			<div class="empty-state">
				<h3>No cards to review!</h3>
				<p>Try generating some cards first or adjusting your filters.</p>
				<a href="/generate" class="btn btn-primary" style="margin-top: 16px;">Generate Cards</a>
			</div>
			'''
			return build_page("Review", content, FLASHCARD_CSS)

		session_id: str = str(uuid.uuid4())
		REVIEW_SESSIONS[session_id] = ReviewSession(
			session_id=session_id,
			card_ids=card_ids,
			difficulty_filter=difficulty,
			para_filter=para,
			topic_filter=topic,
			due_only=due_only,
		)

		return redirect(url_for('review_session', session_id=session_id))

	@app.route('/review/<session_id>')
	async def review_session(session_id):
		session = REVIEW_SESSIONS.get(session_id)
		if not session:
			return redirect(url_for('review_page'))

		# Check if session is complete
		if session.current_index >= len(session.card_ids):
			return redirect(url_for('review_complete', session_id=session_id))

		card_id = session.card_ids[session.current_index]
		card = db_get_card(card_id)

		if not card:
			# Skip missing card
			session.current_index += 1
			return redirect(url_for('review_session', session_id=session_id))

		progress_pct = (session.current_index / len(session.card_ids)) * 100
		diff_names = {1: "Easy", 2: "Medium", 3: "Hard"}

		answer_html = render_markdown(card["answer"])

		review_js = f'''
		let isFlipped = false;

		function flipCard() {{
			const flashcard = document.getElementById('flashcard');
			isFlipped = !isFlipped;
			flashcard.classList.toggle('flipped', isFlipped);

			document.getElementById('flip-hint').classList.toggle('hidden', isFlipped);
			document.getElementById('rating-buttons').classList.toggle('hidden', !isFlipped);
		}}

		document.addEventListener('keydown', function(e) {{
			if (e.code === 'Space') {{
				e.preventDefault();
				flipCard();
			}}
			if (isFlipped) {{
				if (e.key === '1') submitRating(1);
				if (e.key === '2') submitRating(2);
				if (e.key === '3') submitRating(3);
				if (e.key === 's' || e.key === 'S') submitRating(0);
			}}
		}});

		function submitRating(rating) {{
			window.location.href = '/review/{session_id}/rate?rating=' + rating;
		}}
		'''

		content = f'''
		<div class="review-progress">
			<div class="review-progress-text">Card {session.current_index + 1} of {len(session.card_ids)}</div>
			<div class="progress-bar">
				<div class="progress-fill" style="width: {progress_pct}%"></div>
			</div>
		</div>

		<div class="flashcard-container" onclick="flipCard()">
			<div class="flashcard" id="flashcard">
				<div class="flashcard-face flashcard-front">
					<div class="flashcard-label">Question</div>
					<div class="flashcard-content">{card["question"]}</div>
					<div class="flashcard-meta">
						<span>{card["topic"] or "No topic"}</span>
						<span>{diff_names.get(card["difficulty"], "?")}</span>
					</div>
				</div>
				<div class="flashcard-face flashcard-back">
					<div class="flashcard-label">Answer</div>
					<div class="flashcard-content">{answer_html}</div>
				</div>
			</div>
		</div>

		<div class="review-controls">
			<div id="flip-hint" class="flip-hint">Click card or press Space to reveal answer</div>

			<div id="rating-buttons" class="rating-buttons hidden">
				<button class="rating-btn rating-easy" onclick="submitRating(1)">Easy (1)</button>
				<button class="rating-btn rating-medium" onclick="submitRating(2)">Medium (2)</button>
				<button class="rating-btn rating-hard" onclick="submitRating(3)">Hard (3)</button>
				<button class="rating-btn rating-skip" onclick="submitRating(0)">Skip (S)</button>
			</div>

			<div class="keyboard-shortcuts">
				<span><kbd>Space</kbd> Flip</span>
				<span><kbd>1</kbd> Easy</span>
				<span><kbd>2</kbd> Medium</span>
				<span><kbd>3</kbd> Hard</span>
				<span><kbd>S</kbd> Skip</span>
			</div>
		</div>
		'''

		return build_page("Review", content, FLASHCARD_CSS, review_js)

	@app.route('/review/<session_id>/rate')
	async def review_rate(session_id):
		session = REVIEW_SESSIONS.get(session_id)
		if not session:
			return redirect(url_for('review_page'))

		rating = request.args.get('rating', type=int, default=0)
		card_id = session.card_ids[session.current_index]

		if rating > 0:
			session.ratings[card_id] = rating
			db_update_after_review(card_id, rating)

		session.current_index += 1

		if session.current_index >= len(session.card_ids):
			return redirect(url_for('review_complete', session_id=session_id))

		return redirect(url_for('review_session', session_id=session_id))

	@app.route('/review/<session_id>/complete')
	async def review_complete(session_id):
		session = REVIEW_SESSIONS.get(session_id)
		if not session:
			return redirect(url_for('review_page'))

		total = len(session.card_ids)
		reviewed = len(session.ratings)
		skipped = total - reviewed
		easy_count = sum(1 for r in session.ratings.values() if r == 1)

		success_rate = (easy_count / reviewed * 100) if reviewed > 0 else 0

		# Clean up session
		del REVIEW_SESSIONS[session_id]

		content = f'''
		<div class="session-summary">
			<h2>Session Complete!</h2>

			<div class="summary-stats">
				<div class="summary-stat">
					<div class="summary-stat-value">{reviewed}</div>
					<div class="summary-stat-label">Reviewed</div>
				</div>
				<div class="summary-stat">
					<div class="summary-stat-value">{easy_count}</div>
					<div class="summary-stat-label">Easy</div>
				</div>
				<div class="summary-stat">
					<div class="summary-stat-value">{success_rate:.0f}%</div>
					<div class="summary-stat-label">Success Rate</div>
				</div>
			</div>

			<div style="display: flex; gap: 12px; justify-content: center;">
				<a href="/review" class="btn btn-primary">New Session</a>
				<a href="/" class="btn btn-secondary">Dashboard</a>
			</div>
		</div>
		'''

		return build_page("Session Complete", content, FLASHCARD_CSS)

	# ---- Generate ----
	@app.route('/generate')
	async def generate_page():
		# Get recent notes for selection
		notes = db_get_recent_notes(days=14)

		notes_options = ""
		for note in notes[:30]:
			short_path = note["path"][-50:] if len(note["path"]) > 50 else note["path"]
			notes_options += f'<option value="{note["path"]}">{short_path}</option>\n'

		content = f'''
		<h2>Generate Flashcards</h2>

		<div class="tabs">
			<button class="tab active" onclick="showTab('notes')">From Notes</button>
			<button class="tab" onclick="showTab('content')">From Content</button>
		</div>

		<div id="tab-notes" class="card">
			<form method="post" action="/generate/from-notes">
				<div class="form-group">
					<label>Select Notes (recent 14 days)</label>
					<select name="note_paths" class="form-control" multiple size="10" style="min-height: 200px;">
						{notes_options}
					</select>
					<small style="color: var(--text-muted);">Hold Ctrl/Cmd to select multiple</small>
				</div>

				<div class="form-group">
					<label>Cards per Note</label>
					<input type="number" name="cards_per_note" class="form-control" value="5" min="1" max="20">
				</div>

				<button type="submit" class="btn btn-primary">Generate from Notes</button>
			</form>
		</div>

		<div id="tab-content" class="card hidden">
			<form method="post" action="/generate/from-content">
				<div class="form-group">
					<label>Paste Content</label>
					<textarea name="content" class="form-control" rows="12" placeholder="Paste your note content here..."></textarea>
				</div>

				<div class="form-group">
					<label>Source Name (optional)</label>
					<input type="text" name="source_name" class="form-control" placeholder="e.g., 'Python Notes'">
				</div>

				<div class="form-group">
					<label>Number of Cards</label>
					<input type="number" name="cards_count" class="form-control" value="5" min="1" max="20">
				</div>

				<button type="submit" class="btn btn-primary">Generate from Content</button>
			</form>
		</div>
		'''

		tab_js = '''
		function showTab(tab) {
			document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
			document.querySelectorAll('[id^="tab-"]').forEach(t => t.classList.add('hidden'));

			event.target.classList.add('active');
			document.getElementById('tab-' + tab).classList.remove('hidden');
		}
		'''

		return build_page("Generate", content, "", tab_js)

	@app.route('/generate/from-notes', methods=['POST'])
	async def generate_from_notes():
		form = await request.form
		note_paths = form.getlist('note_paths')
		cards_per_note = int(form.get('cards_per_note', 5))

		if not note_paths:
			return build_page("Generate", '<div class="alert alert-error">Please select at least one note</div>')

		# Use CLI to generate
		total_generated = 0
		errors = []

		for note_path in note_paths:
			result = await run_flashcards_command([
				"generate",
				"--days", "365",  # High number since we have specific path
				"--cards-per-note", str(cards_per_note),
				"--force",
				"--quiet",
			])

			if result["returncode"] == 0:
				# Count cards for this note
				cards = db_get_cards(note_path=note_path, limit=100)
				total_generated += len(cards)
			else:
				errors.append(f"{note_path}: {result['stderr']}")

		message = f'<div class="alert alert-success">Generated flashcards for {len(note_paths)} notes!</div>'
		if errors:
			message += f'<div class="alert alert-error">Some errors occurred: {"; ".join(errors[:3])}</div>'

		return build_page("Generate", f'''
			{message}
			<a href="/cards" class="btn btn-primary">View Cards</a>
			<a href="/generate" class="btn btn-secondary">Generate More</a>
		''')

	@app.route('/generate/from-content', methods=['POST'])
	async def generate_from_content():
		form = await request.form
		content = form.get('content', '')
		source_name = form.get('source_name', 'pasted-content')
		cards_count = int(form.get('cards_count', 5))

		if not content.strip():
			return build_page("Generate", '<div class="alert alert-error">Please provide some content</div>')

		# Use CLI with stdin
		result = await run_flashcards_command([
			"generate",
			"--stdin",
			"--cards-per-note", str(cards_count),
		], timeout=180)

		if result["returncode"] != 0:
			return build_page("Generate", f'''
				<div class="alert alert-error">Generation failed: {result["stderr"]}</div>
				<a href="/generate" class="btn btn-secondary">Try Again</a>
			''')

		# Parse generated cards from stdout
		try:
			data = json.loads(result["stdout"])
			cards = data.get("flashcards", [])

			if cards:
				# Insert into database
				count = db_insert_cards(cards, source_name, None, datetime.now())
				message = f'<div class="alert alert-success">Generated {count} flashcards!</div>'
			else:
				message = '<div class="alert alert-error">No cards were generated</div>'
		except json.JSONDecodeError:
			message = '<div class="alert alert-error">Failed to parse generated cards</div>'

		return build_page("Generate", f'''
			{message}
			<a href="/cards" class="btn btn-primary">View Cards</a>
			<a href="/generate" class="btn btn-secondary">Generate More</a>
		''')

	# ---- Stats ----
	@app.route('/stats')
	async def stats_page():
		stats = db_get_stats()

		diff_names = {1: "Easy", 2: "Medium", 3: "Hard"}
		difficulty_rows = ""
		for diff in [1, 2, 3]:
			count = stats["by_difficulty"].get(diff, 0)
			percentage = (count / stats["total_cards"] * 100) if stats["total_cards"] > 0 else 0
			difficulty_rows += f'''
			<tr>
				<td>{diff_names[diff]}</td>
				<td>{count}</td>
				<td>{percentage:.1f}%</td>
			</tr>
			'''

		topics_rows = ""
		for t in stats["top_topics"]:
			topics_rows += f'<tr><td>{t["topic"]}</td><td>{t["count"]}</td></tr>'

		if not topics_rows:
			topics_rows = '<tr><td colspan="2" class="empty-state">No topics yet</td></tr>'

		content = f'''
		<h2>Statistics</h2>

		<div class="stats-grid">
			<div class="stat-card">
				<div class="stat-value">{stats["total_cards"]}</div>
				<div class="stat-label">Total Cards</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["due_for_review"]}</div>
				<div class="stat-label">Due for Review</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["notes_with_cards"]}</div>
				<div class="stat-label">Notes with Cards</div>
			</div>
			<div class="stat-card">
				<div class="stat-value">{stats["total_reviews"]}</div>
				<div class="stat-label">Total Reviews</div>
			</div>
		</div>

		<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
			<div class="card">
				<h3 style="margin-bottom: 16px;">By Difficulty</h3>
				<table>
					<thead>
						<tr><th>Difficulty</th><th>Count</th><th>Percentage</th></tr>
					</thead>
					<tbody>{difficulty_rows}</tbody>
				</table>
			</div>

			<div class="card">
				<h3 style="margin-bottom: 16px;">Top Topics</h3>
				<table>
					<thead>
						<tr><th>Topic</th><th>Cards</th></tr>
					</thead>
					<tbody>{topics_rows}</tbody>
				</table>
			</div>
		</div>

		<div class="card" style="margin-top: 20px;">
			<h3 style="margin-bottom: 16px;">Export/Import</h3>
			<div style="display: flex; gap: 12px;">
				<a href="/export?format=json" class="btn btn-secondary">Export JSON</a>
				<a href="/export?format=yaml" class="btn btn-secondary">Export YAML</a>
				<a href="/import" class="btn btn-secondary">Import</a>
			</div>
		</div>
		'''

		return build_page("Statistics", content)

	# ---- Export ----
	@app.route('/export')
	async def export_page():
		format_type = request.args.get('format', 'json')

		cards = db_get_cards(limit=10000)

		# Convert datetime objects
		for card in cards:
			for key in ["last_reviewed", "next_review", "note_mtime", "created_at", "updated_at"]:
				if card.get(key):
					card[key] = card[key].isoformat()

		if format_type == 'yaml':
			try:
				import yaml
				content_type = 'application/x-yaml'
				filename = 'flashcards_export.yaml'
				data = yaml.dump(cards, default_flow_style=False)
			except ImportError:
				return "PyYAML not installed", 500
		else:
			content_type = 'application/json'
			filename = 'flashcards_export.json'
			data = json.dumps(cards, indent=2)

		response = await make_response(data)
		response.headers['Content-Type'] = content_type
		response.headers['Content-Disposition'] = f'attachment; filename={filename}'
		return response

	# ---- Import ----
	@app.route('/import', methods=['GET', 'POST'])
	async def import_page():
		if request.method == 'GET':
			content = '''
			<h2>Import Flashcards</h2>

			<div class="card">
				<form method="post" enctype="multipart/form-data">
					<div class="form-group">
						<label>Upload File (JSON or YAML)</label>
						<input type="file" name="file" class="form-control" accept=".json,.yaml,.yml">
					</div>

					<button type="submit" class="btn btn-primary">Import</button>
				</form>
			</div>
			'''
			return build_page("Import", content)

		files = await request.files
		file = files.get('file')

		if not file:
			return build_page("Import", '<div class="alert alert-error">No file provided</div>')

		content = file.read().decode('utf-8')

		try:
			if file.filename.endswith(('.yaml', '.yml')):
				import yaml
				cards = yaml.safe_load(content)
			else:
				cards = json.loads(content)
		except Exception as e:
			return build_page("Import", f'<div class="alert alert-error">Failed to parse file: {e}</div>')

		if not isinstance(cards, list):
			return build_page("Import", '<div class="alert alert-error">Expected a list of cards</div>')

		imported = 0
		with get_flashcards_connection() as conn:
			with conn.cursor() as cur:
				for card in cards:
					if not all(k in card for k in ["note_path", "question", "answer"]):
						continue

					cur.execute("""
						INSERT INTO flashcards (
							note_path, question, answer, topic, difficulty,
							times_reviewed, times_correct, note_mtime
						) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
					""", (
						card["note_path"],
						card["question"],
						card["answer"],
						card.get("topic"),
						card.get("difficulty", 2),
						card.get("times_reviewed", 0),
						card.get("times_correct", 0),
						datetime.now(),
					))
					imported += 1
			conn.commit()

		return build_page("Import", f'''
			<div class="alert alert-success">Imported {imported} flashcards!</div>
			<a href="/cards" class="btn btn-primary">View Cards</a>
		''')

	# ---- API Endpoints ----
	@app.route('/api/cards/bulk', methods=['PUT', 'DELETE'])
	async def api_bulk_operations():
		data = await request.get_json()
		card_ids = data.get('card_ids', [])

		if not card_ids:
			return jsonify({"error": "No card IDs provided"}), 400

		if request.method == 'DELETE':
			count = db_delete_cards_bulk(card_ids)
			return jsonify({"deleted": count})

		elif request.method == 'PUT':
			updates = data.get('updates', {})
			count = db_update_cards_bulk(card_ids, updates)
			return jsonify({"updated": count})

	@app.route('/api/stats')
	async def api_stats():
		stats = db_get_stats()
		return jsonify(stats)

	@app.route('/api/autocomplete/paths')
	async def api_autocomplete_paths():
		"""
		Get distinct path segments for autocomplete.
		Query params:
			q: search query (filters paths containing this string)
			para: filter by PARA category first
			limit: max results (default 20)
		"""
		query_str: str = request.args.get('q', '').strip()
		para: str = request.args.get('para', '').strip()
		limit: int = int(request.args.get('limit', 20))

		conditions: List[str] = []
		params: List[Any] = []

		if para:
			prefix: str = PARA_PREFIX_MAP.get(para, para)
			conditions.append("note_path LIKE %s")
			params.append(f"{prefix}/%")

		if query_str:
			conditions.append("note_path ILIKE %s")
			params.append(f"%{query_str}%")

		where_clause: str = ""
		if conditions:
			where_clause = "WHERE " + " AND ".join(conditions)

		# Get distinct paths and extract useful segments
		sql: str = f"""
			SELECT DISTINCT note_path
			FROM flashcards
			{where_clause}
			ORDER BY note_path
			LIMIT 500
		"""

		paths: List[str] = []
		with get_flashcards_connection() as conn:
			with conn.cursor() as cur:
				cur.execute(sql, params)
				paths = [row[0] for row in cur.fetchall()]

		# Extract unique path segments (directories) from the paths
		# e.g., "02_areas/repos/dotfiles/aipy.md" -> ["02_areas", "repos", "dotfiles", "repos/dotfiles", "02_areas/repos"]
		segments: set = set()
		for path in paths:
			parts = path.rsplit('/', 1)[0].split('/')  # Remove filename, split dirs
			# Add individual segments and combined paths
			for i, part in enumerate(parts):
				segments.add(part)
				# Add combined paths like "repos/dotfiles"
				if i > 0:
					combined = '/'.join(parts[max(0, i-1):i+1])
					segments.add(combined)
				if i > 1:
					combined = '/'.join(parts[max(0, i-2):i+1])
					segments.add(combined)

		# Filter by query if provided
		results: List[str] = sorted(segments)
		if query_str:
			query_lower = query_str.lower()
			results = [s for s in results if query_lower in s.lower()]

		# Sort by relevance (exact prefix matches first, then contains)
		if query_str:
			def sort_key(s: str) -> tuple:
				s_lower = s.lower()
				is_prefix = s_lower.startswith(query_lower)
				return (0 if is_prefix else 1, len(s), s_lower)
			results.sort(key=sort_key)

		return jsonify({"paths": results[:limit]})

	return app


# ============================================================================
# MAIN
# ============================================================================

def parse_arguments() -> argparse.Namespace:
	"""Parse command line arguments."""
	parser = argparse.ArgumentParser(
		prog="flashcards-serve",
		description="Web UI and MCP server for flashcard review and administration",
	)
	parser.add_argument("--host", default="127.0.0.1", help="Host to bind to (default: 127.0.0.1)")
	parser.add_argument("--port", type=int, default=5003, help="Port to bind to (default: 5003)")
	parser.add_argument("--debug", action="store_true", help="Enable debug mode")
	parser.add_argument("--mcp", action="store_true", help="Run as MCP server (stdio transport)")
	parser.add_argument("--mcp-http", action="store_true", help="Run as MCP server (HTTP transport, uses --host/--port)")
	return parser.parse_args()


async def check_db_available() -> bool:
	"""Check if database is available."""
	try:
		conn = get_flashcards_connection()
		conn.close()
		return True
	except Exception as e:
		print(f"Database connection error: {e}", file=sys.stderr)
		return False


async def main() -> int:
	"""Main entry point for web UI server."""
	args = parse_arguments()

	if not await check_db_available():
		print("Error: Could not connect to flashcards database", file=sys.stderr)
		print("Make sure to run: local_postgres init-flashcards", file=sys.stderr)
		return 1

	print(f"Starting flashcards-serve on http://{args.host}:{args.port}", file=sys.stderr)

	app = create_app(debug=args.debug)
	await app.run_task(host=args.host, port=args.port, debug=args.debug)

	return 0


if __name__ == "__main__":
	args = parse_arguments()

	# MCP server mode - runs its own event loop, so handle before asyncio.run()
	if args.mcp:
		sys.exit(run_mcp_server(transport="stdio"))
	elif args.mcp_http:
		sys.exit(run_mcp_server(transport="http", host=args.host, port=args.port))
	else:
		# Web UI server
		sys.exit(asyncio.run(main()))
