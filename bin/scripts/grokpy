#!/usr/bin/python3

from os import environ
from subprocess import run
from sys import argv, exit, stdin, stderr
import argparse
import json
import requests
import sys
import os
import base64
import mimetypes


ctr_id: str|None = ""
api_key: str|None = ""

if ("CONTAINER_ID" in environ):
    ctr_id = environ.get("CONTAINER_ID")

# if we are not in the 'dev' distrobox re-exec the script
# inside of the 'dev' distrobox
if ("dev" != ctr_id):
    cmd: list[str] = [
        "distrobox",
        "enter",
        "dev",
        "--",
        *argv
    ]

    run(cmd)
    exit(0)

if ("GROK_API_KEY" in environ):
    api_key = environ.get("GROK_API_KEY")
    if ("" == api_key):
        print("GROK_API_KEY is empty")
        exit(1)
else:
    print("GROK_API_KEY is not set")
    exit(1)

# Parse arguments
parser = argparse.ArgumentParser(description="Query Grok API")
parser.add_argument("--prompt", help="Prompt to prepend to the input")
parser.add_argument("--model", default="grok-3-beta",
                    help="Model to use (default: grok-3-beta). Available models: grok-3-mini-fast-beta, grok-3-fast-beta, grok-3-mini-beta, grok-3-beta, grok-2-1212, grok-2-vision-1212")
parser.add_argument("--debug", action="store_true", help="Enable debug mode (shows request details)")
parser.add_argument("--json", action="store_true", help="Return a clean JSON response without streaming")
parser.add_argument("-S", "--no-streaming", action="store_true", help="Disable streaming mode for cleaner output capture")
parser.add_argument("--embedding", action="store_true", help="Generate an embedding vector instead of a text response")
parser.add_argument("-f", "--file", action="append", dest="files",
                    help="Include file content in the context (can be specified multiple times)")
parser.add_argument("-L", "--list-models", action="store_true",
                    help="List available models from the Grok API")
parser.add_argument("--no-color", action="store_true",
                    help="Disable colored output")
parser.add_argument("--image-gen", action="store_true",
                    help="Generate an image instead of text response")
parser.add_argument("--output", help="Output filename for image generation (default: auto-numbered output-NNNN.png)")
parser.add_argument("--image", action="append", dest="images",
                    help="Include image file(s) for vision analysis (can be specified multiple times)")
args = parser.parse_args()

def get_auto_numbered_filename(base_name="output", extension=".png"):
    """Generate an auto-numbered filename that doesn't exist yet."""
    counter = 0
    while True:
        filename = f"{base_name}-{counter:04d}{extension}"
        if not os.path.exists(filename):
            return filename
        counter += 1

def encode_image_to_base64(image_path):
    """Encode an image file to base64 with proper MIME type detection."""
    try:
        with open(image_path, 'rb') as image_file:
            image_data = image_file.read()
            encoded_string = base64.b64encode(image_data).decode('utf-8')
            
            # Get MIME type
            mime_type, _ = mimetypes.guess_type(image_path)
            if not mime_type or not mime_type.startswith('image/'):
                # Default to common image types
                if image_path.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.webp')):
                    ext = image_path.lower().split('.')[-1]
                    if ext == 'jpg':
                        ext = 'jpeg'
                    mime_type = f'image/{ext}'
                else:
                    mime_type = 'image/jpeg'  # fallback
            
            return f"data:{mime_type};base64,{encoded_string}"
    except Exception as e:
        print(f"Error reading image {image_path}: {e}", file=sys.stderr)
        exit(1)

# Since outside of the distrobox we may not have these modules
# quietly ignore the fact that they may not exist
try:
    # Handle list-models option first
    if args.list_models:
        # Check if colors should be disabled
        use_colors = not args.no_color and environ.get("NO_COLOR", "").lower() not in ("1", "true")
        
        # ANSI color codes (conditionally set based on use_colors)
        class Colors:
            HEADER = '\033[95m' if use_colors else ''
            BLUE = '\033[94m' if use_colors else ''
            CYAN = '\033[96m' if use_colors else ''
            GREEN = '\033[92m' if use_colors else ''
            YELLOW = '\033[93m' if use_colors else ''
            RED = '\033[91m' if use_colors else ''
            BOLD = '\033[1m' if use_colors else ''
            UNDERLINE = '\033[4m' if use_colors else ''
            END = '\033[0m' if use_colors else ''
        
        # Query Grok API for available models
        try:
            headers = {
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json"
            }
            
            response = requests.get("https://api.x.ai/v1/models", headers=headers)
            
            if response.status_code != 200:
                print(f"Error querying models: {response.status_code}")
                print(response.text)
                exit(1)
            
            models_data = response.json()
            
            # Extract and format models
            models = []
            for model in models_data.get("data", []):
                model_id = model.get("id", "")
                
                # Generate description based on model name
                if "fast" in model_id and "mini" in model_id:
                    desc = "Fastest, lightweight model"
                elif "fast" in model_id:
                    desc = "Fast responses"
                elif "mini" in model_id:
                    desc = "Compact model"
                elif "vision" in model_id:
                    desc = "Vision capabilities"
                elif "beta" in model_id:
                    desc = "Beta model"
                else:
                    desc = "AI model"
                
                # Use model ID as display name (could be enhanced if API provides display names)
                display_name = model_id.replace("-", " ").title()
                
                models.append((model_id, display_name, desc))
            
            # Sort models by ID
            models.sort(key=lambda x: x[0])
            
            if not models:
                print(f"{Colors.YELLOW}No models found. Check your API key permissions.{Colors.END}")
                exit(0)
            
            # Calculate column widths
            max_model = max(len(model[0]) for model in models)
            max_name = max(len(model[1]) for model in models)
            max_desc = max(len(model[2]) for model in models)
            
            # Ensure minimum widths
            max_model = max(max_model, len("Model ID"))
            max_name = max(max_name, len("Name"))
            max_desc = max(max_desc, len("Description"))
            
            # Print header
            print(f"\n{Colors.BOLD}{Colors.CYAN}Available Grok Models:{Colors.END}")
            print(f"{Colors.BOLD}{'─' * (max_model + max_name + max_desc + 6)}{Colors.END}")
            
            # Print table header
            print(f"{Colors.BOLD}{Colors.HEADER}{'Model ID':<{max_model}} {'Name':<{max_name}} {'Description':<{max_desc}}{Colors.END}")
            print(f"{Colors.BOLD}{'─' * max_model} {'─' * max_name} {'─' * max_desc}{Colors.END}")
            
            # Print table rows
            for i, (model_id, name, description) in enumerate(models):
                # Alternate row colors
                color = Colors.CYAN if i % 2 == 0 else Colors.BLUE
                name_color = Colors.GREEN
                desc_color = Colors.YELLOW
                
                print(f"{color}{model_id:<{max_model}}{Colors.END} "
                      f"{name_color}{name:<{max_name}}{Colors.END} "
                      f"{desc_color}{description:<{max_desc}}{Colors.END}")
            
            print(f"{Colors.BOLD}{'─' * (max_model + max_name + max_desc + 6)}{Colors.END}")
            print(f"{Colors.BOLD}Total models: {Colors.GREEN}{len(models)}{Colors.END}\n")
            
        except Exception as e:
            print(f"{Colors.RED}Error querying models: {e}{Colors.END}")
            print(f"{Colors.YELLOW}Falling back to known models list...{Colors.END}")
            
            # Fallback to static list if API fails
            models = [
                ("grok-3-mini-fast-beta", "Grok 3 Mini Fast Beta", "Fastest, lightweight model"),
                ("grok-3-fast-beta", "Grok 3 Fast Beta", "Fast responses"),
                ("grok-3-mini-beta", "Grok 3 Mini Beta", "Compact model"),
                ("grok-3-beta", "Grok 3 Beta", "Main model"),
                ("grok-2-1212", "Grok 2 (December)", "Previous generation"),
                ("grok-2-vision-1212", "Grok 2 Vision (December)", "Vision capabilities"),
            ]
            
            # Calculate and display as before
            max_model = max(len(model[0]) for model in models)
            max_name = max(len(model[1]) for model in models)
            max_desc = max(len(model[2]) for model in models)
            
            max_model = max(max_model, len("Model ID"))
            max_name = max(max_name, len("Name"))
            max_desc = max(max_desc, len("Description"))
            
            print(f"\n{Colors.BOLD}{Colors.CYAN}Known Grok Models:{Colors.END}")
            print(f"{Colors.BOLD}{'─' * (max_model + max_name + max_desc + 6)}{Colors.END}")
            
            print(f"{Colors.BOLD}{Colors.HEADER}{'Model ID':<{max_model}} {'Name':<{max_name}} {'Description':<{max_desc}}{Colors.END}")
            print(f"{Colors.BOLD}{'─' * max_model} {'─' * max_name} {'─' * max_desc}{Colors.END}")
            
            for i, (model_id, name, description) in enumerate(models):
                color = Colors.CYAN if i % 2 == 0 else Colors.BLUE
                name_color = Colors.GREEN
                desc_color = Colors.YELLOW
                
                print(f"{color}{model_id:<{max_model}}{Colors.END} "
                      f"{name_color}{name:<{max_name}}{Colors.END} "
                      f"{desc_color}{description:<{max_desc}}{Colors.END}")
            
            print(f"{Colors.BOLD}{'─' * (max_model + max_name + max_desc + 6)}{Colors.END}")
            print(f"{Colors.BOLD}Total models: {Colors.GREEN}{len(models)}{Colors.END}\n")
        
        exit(0)
    
    # Read file contents if any files were specified
    file_contents = []
    if args.files:
        for file_path in args.files:
            try:
                with open(file_path, 'r') as f:
                    file_content = f.read()
                    file_contents.append(f"=== File: {file_path} ===\n{file_content}\n")
            except IOError as e:
                print(f"Warning: Could not read file {file_path}: {e}", file=stderr)
    
    # Read from standard input
    query = stdin.read()

    # Combine file contents with query
    combined_parts = []
    
    # Add file contents first if any
    if file_contents:
        combined_parts.extend(file_contents)
    
    # Add prompt if provided
    if args.prompt:
        combined_parts.append(args.prompt)
    
    # Add stdin content if any
    if query:
        combined_parts.append(query)
    
    # Combine all parts
    if combined_parts:
        query = "\n".join(combined_parts)
    else:
        query = ""

    # Set up API call
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }

    # Check for image generation request first
    if args.image_gen:
        print("Error: Grok does not currently support true image generation.", file=sys.stderr)
        print("The grok-2-vision-1212 model is for image understanding/analysis, not generation.", file=sys.stderr)
        print("Available providers with image generation:", file=sys.stderr)
        print("  - openpy (DALL-E models)", file=sys.stderr)
        print("  - geminpy (Imagen models)", file=sys.stderr)
        print("  - ollampy (select models with image generation)", file=sys.stderr)
        exit(1)
    
    # Set the API endpoint based on the request type
    if args.embedding:
        # When Grok supports a dedicated embeddings endpoint, use that instead
        # For now, we'll use their chat endpoint with a special prompt
        url = "https://api.x.ai/v1/chat/completions"
        
        # Add embedding instructions to the query
        embedding_instruction = "Generate an embedding vector for the following text. Return ONLY a JSON object with a single key 'embedding' whose value is the embedding vector as an array of 1536 floats. No other text.\n\n"
        query = embedding_instruction + query
    else:
        # Standard chat completion endpoint
        url = "https://api.x.ai/v1/chat/completions"

    # Configure request data
    # Construct message content (text + images if provided)
    message_content = []
    
    # Add text content
    if query:
        message_content.append({
            "type": "text",
            "text": query
        })
    
    # Add image content if provided
    if args.images:
        # Check if using a vision-capable model
        if "vision" not in args.model:
            print(f"Warning: Model '{args.model}' may not support vision. Consider using 'grok-2-vision-1212'", file=sys.stderr)
        
        for image_path in args.images:
            if not os.path.exists(image_path):
                print(f"Error: Image file not found: {image_path}", file=sys.stderr)
                exit(1)
            
            image_url = encode_image_to_base64(image_path)
            message_content.append({
                "type": "image_url",
                "image_url": {
                    "url": image_url
                }
            })
    
    # If no content was added, add empty text
    if not message_content:
        message_content.append({
            "type": "text",
            "text": ""
        })
    
    data = {
        "model": args.model,
        "max_tokens": 4096,
        "messages": [
            {
                "role": "user",
                "content": message_content
            }
        ],
        # Don't stream if JSON output is requested, for embeddings, or --no-streaming
        "stream": not (args.json or args.embedding or args.no_streaming)
    }

    # Print debug info if requested
    if args.debug:
        print(f"Debug: API URL: {url}", file=sys.stderr)
        print(f"Debug: Headers (API key partially hidden): {{'Authorization': 'Bearer {api_key[:5]}...{api_key[-4:]}', 'Content-Type': 'application/json'}}", file=sys.stderr)
        print(f"Debug: Data: {json.dumps(data)}", file=sys.stderr)
        if args.images:
            print(f"Debug: Processing {len(args.images)} image(s): {', '.join(args.images)}", file=sys.stderr)

    # Send request to Grok API
    response = requests.post(url, headers=headers, json=data, stream=data["stream"])

    if response.status_code != 200:
        print(f"Error: {response.status_code}")
        print(response.text)
        exit(1)
    
    # Handle the response based on the request type
    if data["stream"]:
        # Process streaming response
        for line in response.iter_lines():
            if line:
                # Skip the initial "data: " prefix
                line_text = line.decode('utf-8')
                if line_text.startswith("data: "):
                    line_json = line_text[6:]
                    
                    # The last message is usually "data: [DONE]"
                    if line_json == "[DONE]":
                        break
                        
                    try:
                        event = json.loads(line_json)
                        # Extract content delta if it exists
                        if "choices" in event and len(event["choices"]) > 0:
                            choice = event["choices"][0]
                            if "delta" in choice and "content" in choice["delta"]:
                                print(choice["delta"]["content"], end="", flush=True)
                    except json.JSONDecodeError:
                        continue
    else:
        # Process non-streaming response (JSON or embedding)
        response_data = response.json()
        
        if args.embedding:
            # For embeddings, extract the message and parse it to find the embedding
            try:
                # Get the full message content
                message_content = response_data["choices"][0]["message"]["content"]
                
                # Try to extract a JSON object containing the embedding
                import re
                json_pattern = r'\{\s*"embedding"\s*:\s*\[.*?\]\s*\}'
                match = re.search(json_pattern, message_content)
                
                if match:
                    embedding_json = match.group(0)
                    print(embedding_json)  # Print just the embedding JSON
                else:
                    # If no JSON pattern found, try parsing the whole content as JSON
                    try:
                        content_json = json.loads(message_content)
                        if "embedding" in content_json:
                            print(json.dumps({"embedding": content_json["embedding"]}))
                        else:
                            print(message_content)  # Fallback to printing the raw content
                    except json.JSONDecodeError:
                        print(message_content)  # Fallback to printing the raw content
            except (KeyError, IndexError, json.JSONDecodeError):
                # If we can't extract/parse properly, output the raw response
                print(json.dumps(response_data))
        else:
            # For regular JSON output or --no-streaming, return the full message content
            try:
                message_content = response_data["choices"][0]["message"]["content"]
                print(message_content)
            except (KeyError, IndexError):
                # Fallback to printing the full response
                if args.json:
                    print(json.dumps(response_data))
                else:
                    print(f"Unexpected response format: {json.dumps(response_data)}", file=sys.stderr)

except (ImportError, Exception) as e:
    print(f"Error: {e}")
    exit(1)
