#!/usr/bin/env python3
"""
md_table_calc - Excel-like calculations for markdown tables

Usage: 
  echo "table" | md_table_calc "expression"
  md_table_calc "expression" < table.md

Column references:
  A, B, C, etc. - Reference by column letter
  $_<column_name> - Reference by column header name

Functions:
  SUM(column), AVG(column), COUNT(column), MIN(column), MAX(column)
  MED(column), MEDIAN(column), MODE(column), STDDEV(column)
  QUARTILE(column, q), IQR(column), NTILE(column, n, tile)
  PERCENTILE(column, p), PERCENTILE(column, [p1, p2, p3])

Examples:
  md_table_calc "SUM($_amount)"
  md_table_calc "AVG(C) * 1.2" 
  md_table_calc "SUM(A) + AVG(B)"
  md_table_calc "STDDEV($_price)"
  md_table_calc "QUARTILE($_score, 1)"  # Q1/25th percentile
  md_table_calc "IQR($_values)"
  md_table_calc "NTILE($_score, 5, 3)"  # 3rd quintile (60th percentile)
  md_table_calc "PERCENTILE($_score, 25)"  # 25th percentile
  md_table_calc "PERCENTILE($_score, [25, 50, 75])"  # Multiple percentiles
"""

import sys
import re
import string
from typing import List, Dict, Any
import math

class MarkdownTableCalculator:
    def __init__(self):
        self.headers: List[str] = []
        self.data: List[List[str]] = []
        self.column_map: Dict[str, int] = {}
        
    def parse_table(self, lines: List[str]) -> None:
        """Parse markdown table from input lines"""
        table_lines = []
        
        # Filter for table lines only
        for line in lines:
            line = line.strip()
            if line.startswith('|') and line.endswith('|'):
                # Skip separator lines (|---|---|)
                if re.match(r'^\|[-\s|]+\|$', line):
                    continue
                table_lines.append(line)
        
        if not table_lines:
            raise ValueError("No valid markdown table found")
        
        # Parse header
        header_line = table_lines[0]
        self.headers = self._parse_row(header_line)
        
        # Build column mapping
        for i, header in enumerate(self.headers):
            # Map by column letter (A, B, C, etc.)
            if i < 26:
                letter = string.ascii_uppercase[i]
                self.column_map[letter] = i
            
            # Map by column name
            self.column_map[header] = i
        
        # Parse data rows
        for line in table_lines[1:]:
            row_data = self._parse_row(line)
            if len(row_data) == len(self.headers):
                self.data.append(row_data)
    
    def _parse_row(self, line: str) -> List[str]:
        """Parse a single table row"""
        # Remove leading/trailing |
        line = line.strip('|')
        # Split by | and clean whitespace
        return [cell.strip() for cell in line.split('|')]
    
    def _get_column_values(self, col_ref: str) -> List[float]:
        """Get numeric values from a column"""
        # Handle column name reference ($_name)
        if col_ref.startswith('$_'):
            col_name = col_ref[2:]
            if col_name not in self.column_map:
                raise ValueError(f"Column '{col_name}' not found")
            col_index = self.column_map[col_name]
        # Handle letter reference (A, B, C)
        elif col_ref in self.column_map:
            col_index = self.column_map[col_ref]
        else:
            raise ValueError(f"Invalid column reference '{col_ref}'")
        
        values = []
        for row in self.data:
            if col_index < len(row):
                value_str = row[col_index]
                # Clean numeric value (remove $, commas, etc.)
                clean_value = re.sub(r'[$,]', '', value_str)
                try:
                    values.append(float(clean_value))
                except ValueError:
                    # Skip non-numeric values
                    continue
        
        return values
    
    def sum_column(self, col_ref: str) -> float:
        """Calculate sum of column"""
        values = self._get_column_values(col_ref)
        return sum(values)
    
    def avg_column(self, col_ref: str) -> float:
        """Calculate average of column"""
        values = self._get_column_values(col_ref)
        return sum(values) / len(values) if values else 0
    
    def count_column(self, col_ref: str) -> int:
        """Count non-empty values in column"""
        values = self._get_column_values(col_ref)
        return len(values)
    
    def min_column(self, col_ref: str) -> float:
        """Find minimum value in column"""
        values = self._get_column_values(col_ref)
        return min(values) if values else 0
    
    def max_column(self, col_ref: str) -> float:
        """Find maximum value in column"""
        values = self._get_column_values(col_ref)
        return max(values) if values else 0
    
    def median_column(self, col_ref: str) -> float:
        """Find median value in column"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0
        
        sorted_values = sorted(values)
        n = len(sorted_values)
        
        if n % 2 == 0:
            # Even number of values - average of two middle values
            return (sorted_values[n//2 - 1] + sorted_values[n//2]) / 2
        else:
            # Odd number of values - middle value
            return sorted_values[n//2]
    
    def mode_column(self, col_ref: str) -> float:
        """Find mode (most frequent value) in column"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0
        
        # Count frequency of each value
        from collections import Counter
        counts = Counter(values)
        
        # Find the most frequent value(s)
        max_count = max(counts.values())
        modes = [value for value, count in counts.items() if count == max_count]
        
        # Return the first mode (smallest if multiple modes exist)
        return min(modes)
    
    def stddev_column(self, col_ref: str) -> float:
        """Calculate standard deviation of column"""
        values = self._get_column_values(col_ref)
        if len(values) <= 1:
            return 0
        
        mean = sum(values) / len(values)
        variance = sum((x - mean) ** 2 for x in values) / (len(values) - 1)  # Sample std dev
        return variance ** 0.5
    
    def quartile_column(self, col_ref: str, q: int) -> float:
        """Calculate quartile (q=1 for Q1/25th, q=2 for Q2/50th, q=3 for Q3/75th)"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0
        
        sorted_values = sorted(values)
        n = len(sorted_values)
        
        if q == 1:  # Q1 - 25th percentile
            pos = (n + 1) * 0.25
        elif q == 2:  # Q2 - 50th percentile (median)
            pos = (n + 1) * 0.5
        elif q == 3:  # Q3 - 75th percentile
            pos = (n + 1) * 0.75
        else:
            raise ValueError("Quartile must be 1, 2, or 3")
        
        # Handle interpolation between values
        if pos == int(pos):
            return sorted_values[int(pos) - 1]  # Convert to 0-based index
        else:
            lower_idx = int(pos) - 1  # 0-based index
            upper_idx = lower_idx + 1
            if upper_idx >= n:
                return sorted_values[-1]
            
            # Linear interpolation
            weight = pos - int(pos)
            return sorted_values[lower_idx] * (1 - weight) + sorted_values[upper_idx] * weight
    
    def iqr_column(self, col_ref: str) -> float:
        """Calculate Inter-Quartile Range (Q3 - Q1)"""
        q1 = self.quartile_column(col_ref, 1)
        q3 = self.quartile_column(col_ref, 3)
        return q3 - q1
    
    def ntile_column(self, col_ref: str, n: int, tile: int) -> float:
        """Calculate NTILE - divide data into N equal groups and return the boundary for tile number"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0
        
        if tile < 1 or tile > n:
            raise ValueError(f"Tile number must be between 1 and {n}")
        
        sorted_values = sorted(values)
        data_count = len(sorted_values)
        
        # Calculate the position for this tile
        pos = (data_count + 1) * (tile / n)
        
        # Handle interpolation between values
        if pos == int(pos):
            idx = int(pos) - 1  # Convert to 0-based index
            if idx >= data_count:
                return sorted_values[-1]
            return sorted_values[idx]
        else:
            lower_idx = int(pos) - 1  # 0-based index
            upper_idx = lower_idx + 1
            if lower_idx >= data_count:
                return sorted_values[-1]
            if upper_idx >= data_count:
                return sorted_values[-1]
            
            # Linear interpolation
            weight = pos - int(pos)
            return sorted_values[lower_idx] * (1 - weight) + sorted_values[upper_idx] * weight
    
    def percentile_column(self, col_ref: str, percentiles) -> Any:
        """Calculate percentile(s) - can handle single percentile or list of percentiles"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0 if isinstance(percentiles, (int, float)) else [0] * len(percentiles)
        
        sorted_values = sorted(values)
        data_count = len(sorted_values)
        
        def calc_single_percentile(p):
            if p < 0 or p > 100:
                raise ValueError("Percentile must be between 0 and 100")
            
            # Calculate position using the standard percentile formula
            pos = (data_count - 1) * (p / 100) + 1
            
            # Handle interpolation between values
            if pos == int(pos):
                idx = int(pos) - 1  # Convert to 0-based index
                if idx >= data_count:
                    return sorted_values[-1]
                if idx < 0:
                    return sorted_values[0]
                return sorted_values[idx]
            else:
                lower_idx = int(pos) - 1  # 0-based index
                upper_idx = lower_idx + 1
                if lower_idx < 0:
                    return sorted_values[0]
                if upper_idx >= data_count:
                    return sorted_values[-1]
                
                # Linear interpolation
                weight = pos - int(pos)
                return sorted_values[lower_idx] * (1 - weight) + sorted_values[upper_idx] * weight
        
        # Handle single percentile
        if isinstance(percentiles, (int, float)):
            return calc_single_percentile(percentiles)
        
        # Handle list of percentiles
        if isinstance(percentiles, (list, tuple)):
            return [calc_single_percentile(p) for p in percentiles]
        
        raise ValueError("Percentiles must be a number or list of numbers")
    
    def evaluate_expression(self, expression: str) -> Any:
        """Evaluate mathematical expression with function calls"""
        # Create wrapper functions for safe evaluation
        def SUM(col_ref): return self.sum_column(col_ref)
        def AVG(col_ref): return self.avg_column(col_ref)
        def COUNT(col_ref): return self.count_column(col_ref)
        def MIN(col_ref): return self.min_column(col_ref)
        def MAX(col_ref): return self.max_column(col_ref)
        def MED(col_ref): return self.median_column(col_ref)
        def MEDIAN(col_ref): return self.median_column(col_ref)
        def MODE(col_ref): return self.mode_column(col_ref)
        def STDDEV(col_ref): return self.stddev_column(col_ref)
        def QUARTILE(col_ref, q): return self.quartile_column(col_ref, q)
        def IQR(col_ref): return self.iqr_column(col_ref)
        def NTILE(col_ref, n, tile): return self.ntile_column(col_ref, n, tile)
        def PERCENTILE(col_ref, percentiles): return self.percentile_column(col_ref, percentiles)
        
        # Create a safe namespace for evaluation
        safe_dict = {
            '__builtins__': {},
            'SUM': SUM,
            'AVG': AVG,
            'COUNT': COUNT,
            'MIN': MIN,
            'MAX': MAX,
            'MED': MED,
            'MEDIAN': MEDIAN,
            'MODE': MODE,
            'STDDEV': STDDEV,
            'QUARTILE': QUARTILE,
            'IQR': IQR,
            'NTILE': NTILE,
            'PERCENTILE': PERCENTILE,
            'abs': abs,
            'round': round,
            'int': int,
            'float': float,
            'pow': pow,
            'sqrt': math.sqrt,
            'ceil': math.ceil,
            'floor': math.floor,
        }
        
        try:
            # Replace column references in function calls
            # Handle $_column_name pattern - use raw strings to avoid escape issues
            expression = re.sub(
                r'\$_([a-zA-Z_][a-zA-Z0-9_]*)',
                r'"$_\1"',
                expression
            )
            
            # Handle single letter column references in functions
            expression = re.sub(
                r'([A-Z])(?=[,)])',
                r'"\1"',
                expression
            )
            
            result = eval(expression, safe_dict)
            # Don't convert lists to float - return as-is for PERCENTILE with multiple values
            if isinstance(result, list):
                return result
            return float(result)
        except Exception as e:
            raise ValueError(f"Error evaluating expression: {e}")

def main():
    if len(sys.argv) != 2:
        print("Usage: md_table_calc 'expression'", file=sys.stderr)
        print("Examples:", file=sys.stderr)
        print("  md_table_calc 'SUM($_amount)'", file=sys.stderr)
        print("  md_table_calc 'AVG(C) * 1.2'", file=sys.stderr)
        sys.exit(1)
    
    expression = sys.argv[1]
    
    try:
        # Read input from stdin
        lines = sys.stdin.readlines()
        
        # Create calculator and parse table
        calc = MarkdownTableCalculator()
        calc.parse_table(lines)
        
        # Evaluate expression
        result = calc.evaluate_expression(expression)
        
        # Format result - handle both single values and lists
        if isinstance(result, list):
            # Format list of values
            formatted = []
            for val in result:
                if val == int(val):
                    formatted.append(str(int(val)))
                else:
                    formatted.append(f"{val:.2f}")
            print("[" + ", ".join(formatted) + "]")
        else:
            # Format single value
            if result == int(result):
                print(int(result))
            else:
                print(f"{result:.2f}")
            
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()