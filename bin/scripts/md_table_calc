#!/usr/bin/python3
"""
md_table_calc - Excel-like calculations for markdown tables

Usage: 
  echo "table" | md_table_calc "expression"
  md_table_calc "expression" < table.md
  md_table_calc --column "column_name" < table.md
  md_table_calc --formula "New_Column = SUM($_Total)" < table.md
  md_table_calc --formula "Commission = $_Total * 0.05" --formula "Tax = $_Total * 0.08" < table.md

Column references:
  A, B, C, etc. - Reference by column letter
  $_<column_name> - Reference by column header name

Functions:
  # Statistical
  SUM(column), AVG(column), COUNT(column), MIN(column), MAX(column)
  MED(column), MEDIAN(column), MODE(column), STDDEV(column)
  QUARTILE(column, q), IQR(column), NTILE(column, n, tile)
  PERCENTILE(column, p), PERCENTILE(column, [p1, p2, p3])
  
  # Data Access  
  VALUES(column), VALUES([col1, col2]), PRINT(column), PRINT([col1, col2])
  
  # Logical
  IF(condition, true_val, false_val), AND(a, b, ...), OR(a, b, ...), NOT(val)
  ISNUMBER(val), ISTEXT(val)
  
  # Conditional Aggregation
  SUMIF(column, condition), SUMIF(test_col, condition, sum_col)
  COUNTIF(column, condition), AVERAGEIF(column, condition)
  
  # Utility
  UNIQUE(column), DISTINCT(column), RANK(column, value)
  OUTLIERS(column), ZSCORE(column, value), NORMALIZE(column, value)

Examples:
  md_table_calc "SUM($_amount)"
  md_table_calc "AVG(C) * 1.2" 
  md_table_calc "SUM(A) + AVG(B)"
  md_table_calc "STDDEV($_price)"
  md_table_calc "QUARTILE($_score, 1)"  # Q1/25th percentile
  md_table_calc "IQR($_values)"
  md_table_calc "NTILE($_score, 5, 3)"  # 3rd quintile (60th percentile)
  md_table_calc "PERCENTILE($_score, 25)"  # 25th percentile
  md_table_calc "PERCENTILE($_score, [25, 50, 75])"  # Multiple percentiles
  md_table_calc "VALUES($_score)"  # All values as list
  md_table_calc "PRINT($_score)"  # All values, one per line
  md_table_calc --column $_score  # All values, one per line (alternative syntax)
  md_table_calc "IF(AVG($_score) > 85, 'Pass', 'Fail')"  # Conditional logic
  md_table_calc "SUMIF($_category, 'food')"  # Sum where category = 'food'
  md_table_calc "COUNTIF($_score, '>90')"  # Count scores > 90
  md_table_calc "UNIQUE($_category)"  # Count unique categories
  md_table_calc "OUTLIERS($_price)"  # Find outlier prices
"""

import sys
import re
import string
from typing import List, Dict, Any
import math

class MarkdownTableCalculator:
    def __init__(self):
        self.headers: List[str] = []
        self.data: List[List[str]] = []
        self.column_map: Dict[str, int] = {}
        
    def parse_table(self, lines: List[str]) -> None:
        """Parse markdown table from input lines"""
        table_lines = []
        
        # Filter for table lines only
        for line in lines:
            line = line.strip()
            if line.startswith('|') and line.endswith('|'):
                # Skip separator lines (|---|---|)
                if re.match(r'^\|[-\s|]+\|$', line):
                    continue
                table_lines.append(line)
        
        if not table_lines:
            raise ValueError("No valid markdown table found")
        
        # Parse header
        header_line = table_lines[0]
        self.headers = self._parse_row(header_line)
        
        # Build column mapping
        for i, header in enumerate(self.headers):
            # Map by column letter (A, B, C, etc.)
            if i < 26:
                letter = string.ascii_uppercase[i]
                self.column_map[letter] = i
            
            # Map by column name
            self.column_map[header] = i
        
        # Parse data rows
        for line in table_lines[1:]:
            row_data = self._parse_row(line)
            if len(row_data) == len(self.headers):
                self.data.append(row_data)
    
    def _parse_row(self, line: str) -> List[str]:
        """Parse a single table row"""
        # Remove leading/trailing |
        line = line.strip('|')
        # Split by | and clean whitespace
        return [cell.strip() for cell in line.split('|')]
    
    def _get_column_values(self, col_ref: str) -> List[float]:
        """Get numeric values from a column"""
        # Handle column name reference ($_name)
        if col_ref.startswith('$_'):
            col_name = col_ref[2:]
            if col_name not in self.column_map:
                raise ValueError(f"Column '{col_name}' not found")
            col_index = self.column_map[col_name]
        # Handle letter reference (A, B, C)
        elif col_ref in self.column_map:
            col_index = self.column_map[col_ref]
        else:
            raise ValueError(f"Invalid column reference '{col_ref}'")
        
        values = []
        for row in self.data:
            if col_index < len(row):
                value_str = row[col_index]
                # Clean numeric value (remove $, commas, etc.)
                clean_value = re.sub(r'[$,]', '', value_str)
                try:
                    values.append(float(clean_value))
                except ValueError:
                    # Skip non-numeric values
                    continue
        
        return values
    
    def _get_all_column_values(self, col_ref: str) -> List[str]:
        """Get all values from a column (including text values)"""
        # Handle column name reference ($_name)
        if col_ref.startswith('$_'):
            col_name = col_ref[2:]
            if col_name not in self.column_map:
                raise ValueError(f"Column '{col_name}' not found")
            col_index = self.column_map[col_name]
        # Handle letter reference (A, B, C)
        elif col_ref in self.column_map:
            col_index = self.column_map[col_ref]
        else:
            raise ValueError(f"Invalid column reference '{col_ref}'")
        
        # Extract column data (all values, not just numeric)
        values = []
        for row in self.data:
            if col_index < len(row):
                values.append(row[col_index])
        
        return values
    
    def sum_column(self, col_ref: str) -> float:
        """Calculate sum of column"""
        values = self._get_column_values(col_ref)
        return sum(values)
    
    def avg_column(self, col_ref: str) -> float:
        """Calculate average of column"""
        values = self._get_column_values(col_ref)
        return sum(values) / len(values) if values else 0
    
    def count_column(self, col_ref: str) -> int:
        """Count non-empty values in column"""
        values = self._get_column_values(col_ref)
        return len(values)
    
    def min_column(self, col_ref: str) -> float:
        """Find minimum value in column"""
        values = self._get_column_values(col_ref)
        return min(values) if values else 0
    
    def max_column(self, col_ref: str) -> float:
        """Find maximum value in column"""
        values = self._get_column_values(col_ref)
        return max(values) if values else 0
    
    def median_column(self, col_ref: str) -> float:
        """Find median value in column"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0
        
        sorted_values = sorted(values)
        n = len(sorted_values)
        
        if n % 2 == 0:
            # Even number of values - average of two middle values
            return (sorted_values[n//2 - 1] + sorted_values[n//2]) / 2
        else:
            # Odd number of values - middle value
            return sorted_values[n//2]
    
    def mode_column(self, col_ref: str) -> float:
        """Find mode (most frequent value) in column"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0
        
        # Count frequency of each value
        from collections import Counter
        counts = Counter(values)
        
        # Find the most frequent value(s)
        max_count = max(counts.values())
        modes = [value for value, count in counts.items() if count == max_count]
        
        # Return the first mode (smallest if multiple modes exist)
        return min(modes)
    
    def stddev_column(self, col_ref: str) -> float:
        """Calculate standard deviation of column"""
        values = self._get_column_values(col_ref)
        if len(values) <= 1:
            return 0
        
        mean = sum(values) / len(values)
        variance = sum((x - mean) ** 2 for x in values) / (len(values) - 1)  # Sample std dev
        return variance ** 0.5
    
    def quartile_column(self, col_ref: str, q: int) -> float:
        """Calculate quartile (q=1 for Q1/25th, q=2 for Q2/50th, q=3 for Q3/75th)"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0
        
        sorted_values = sorted(values)
        n = len(sorted_values)
        
        if q == 1:  # Q1 - 25th percentile
            pos = (n + 1) * 0.25
        elif q == 2:  # Q2 - 50th percentile (median)
            pos = (n + 1) * 0.5
        elif q == 3:  # Q3 - 75th percentile
            pos = (n + 1) * 0.75
        else:
            raise ValueError("Quartile must be 1, 2, or 3")
        
        # Handle interpolation between values
        if pos == int(pos):
            return sorted_values[int(pos) - 1]  # Convert to 0-based index
        else:
            lower_idx = int(pos) - 1  # 0-based index
            upper_idx = lower_idx + 1
            if upper_idx >= n:
                return sorted_values[-1]
            
            # Linear interpolation
            weight = pos - int(pos)
            return sorted_values[lower_idx] * (1 - weight) + sorted_values[upper_idx] * weight
    
    def iqr_column(self, col_ref: str) -> float:
        """Calculate Inter-Quartile Range (Q3 - Q1)"""
        q1 = self.quartile_column(col_ref, 1)
        q3 = self.quartile_column(col_ref, 3)
        return q3 - q1
    
    def ntile_column(self, col_ref: str, n: int, tile: int) -> float:
        """Calculate NTILE - divide data into N equal groups and return the boundary for tile number"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0
        
        if tile < 1 or tile > n:
            raise ValueError(f"Tile number must be between 1 and {n}")
        
        sorted_values = sorted(values)
        data_count = len(sorted_values)
        
        # Calculate the position for this tile
        pos = (data_count + 1) * (tile / n)
        
        # Handle interpolation between values
        if pos == int(pos):
            idx = int(pos) - 1  # Convert to 0-based index
            if idx >= data_count:
                return sorted_values[-1]
            return sorted_values[idx]
        else:
            lower_idx = int(pos) - 1  # 0-based index
            upper_idx = lower_idx + 1
            if lower_idx >= data_count:
                return sorted_values[-1]
            if upper_idx >= data_count:
                return sorted_values[-1]
            
            # Linear interpolation
            weight = pos - int(pos)
            return sorted_values[lower_idx] * (1 - weight) + sorted_values[upper_idx] * weight
    
    def percentile_column(self, col_ref: str, percentiles) -> Any:
        """Calculate percentile(s) - can handle single percentile or list of percentiles"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0 if isinstance(percentiles, (int, float)) else [0] * len(percentiles)
        
        sorted_values = sorted(values)
        data_count = len(sorted_values)
        
        def calc_single_percentile(p):
            if p < 0 or p > 100:
                raise ValueError("Percentile must be between 0 and 100")
            
            # Calculate position using the standard percentile formula
            pos = (data_count - 1) * (p / 100) + 1
            
            # Handle interpolation between values
            if pos == int(pos):
                idx = int(pos) - 1  # Convert to 0-based index
                if idx >= data_count:
                    return sorted_values[-1]
                if idx < 0:
                    return sorted_values[0]
                return sorted_values[idx]
            else:
                lower_idx = int(pos) - 1  # 0-based index
                upper_idx = lower_idx + 1
                if lower_idx < 0:
                    return sorted_values[0]
                if upper_idx >= data_count:
                    return sorted_values[-1]
                
                # Linear interpolation
                weight = pos - int(pos)
                return sorted_values[lower_idx] * (1 - weight) + sorted_values[upper_idx] * weight
        
        # Handle single percentile
        if isinstance(percentiles, (int, float)):
            return calc_single_percentile(percentiles)
        
        # Handle list of percentiles
        if isinstance(percentiles, (list, tuple)):
            return [calc_single_percentile(p) for p in percentiles]
        
        raise ValueError("Percentiles must be a number or list of numbers")
    
    def values_column(self, col_refs) -> Any:
        """Get all values from column(s) - returns list for single column or dict for multiple"""
        if isinstance(col_refs, str):
            # Single column - return all values (including text)
            return self._get_all_column_values(col_refs)
        elif isinstance(col_refs, (list, tuple)):
            # Multiple columns - return dict
            result = {}
            for col_ref in col_refs:
                if isinstance(col_ref, str):
                    # Handle column name reference ($_name)
                    if col_ref.startswith('$_'):
                        col_name = col_ref[2:]
                        if col_name not in self.column_map:
                            raise ValueError(f"Column '{col_name}' not found")
                        display_name = col_name
                    # Handle letter reference (A, B, C)
                    elif col_ref in self.column_map:
                        display_name = col_ref
                    else:
                        raise ValueError(f"Invalid column reference '{col_ref}'")
                    
                    result[display_name] = self._get_all_column_values(col_ref)
                else:
                    raise ValueError("Column references must be strings")
            return result
        else:
            raise ValueError("Column reference must be string or list of strings")
    
    def print_column(self, col_refs) -> str:
        """Print all values from column(s) - returns formatted string for output"""
        if isinstance(col_refs, str):
            # Single column - return all values (including text)
            values = self._get_all_column_values(col_refs)
            return '\n'.join(str(v) for v in values)
        elif isinstance(col_refs, (list, tuple)):
            # Multiple columns - return tab-separated format
            col_data = {}
            headers = []
            
            for col_ref in col_refs:
                if isinstance(col_ref, str):
                    # Handle column name reference ($_name)
                    if col_ref.startswith('$_'):
                        col_name = col_ref[2:]
                        if col_name not in self.column_map:
                            raise ValueError(f"Column '{col_name}' not found")
                        display_name = col_name
                    # Handle letter reference (A, B, C)
                    elif col_ref in self.column_map:
                        display_name = col_ref
                    else:
                        raise ValueError(f"Invalid column reference '{col_ref}'")
                    
                    col_data[display_name] = self._get_all_column_values(col_ref)
                    headers.append(display_name)
                else:
                    raise ValueError("Column references must be strings")
            
            # Create tab-separated output
            lines = ['\t'.join(headers)]  # Header row
            max_rows = max(len(values) for values in col_data.values()) if col_data else 0
            
            for i in range(max_rows):
                row = []
                for header in headers:
                    values = col_data[header]
                    if i < len(values):
                        row.append(str(values[i]))
                    else:
                        row.append('')  # Empty if column has fewer values
                lines.append('\t'.join(row))
            
            return '\n'.join(lines)
        else:
            raise ValueError("Column reference must be string or list of strings")
    
    # Logical Functions
    def if_function(self, condition, true_value, false_value):
        """IF function - returns true_value if condition is True, else false_value"""
        return true_value if condition else false_value
    
    def and_function(self, *args):
        """AND function - returns True if all arguments are True"""
        return all(args)
    
    def or_function(self, *args):
        """OR function - returns True if any argument is True"""
        return any(args)
    
    def not_function(self, value):
        """NOT function - returns logical negation"""
        return not value
    
    def isnumber(self, value):
        """Check if value is numeric"""
        try:
            float(value)
            return True
        except (ValueError, TypeError):
            return False
    
    def istext(self, value):
        """Check if value is text (non-numeric)"""
        return not self.isnumber(value)
    
    # Conditional aggregation functions
    def sumif(self, col_ref, condition, sum_col_ref=None):
        """Sum values that meet condition: SUMIF(column, ">100") or SUMIF(test_col, ">100", sum_col)"""
        if sum_col_ref is None:
            sum_col_ref = col_ref
        
        test_values = self._get_all_column_values(col_ref)
        sum_values = self._get_column_values(sum_col_ref)
        
        # Parse condition - check longer operators first
        if condition.startswith('>='):
            threshold = float(condition[2:])
            matching_indices = [i for i, v in enumerate(test_values) if self.isnumber(v) and float(v) >= threshold]
        elif condition.startswith('<='):
            threshold = float(condition[2:])
            matching_indices = [i for i, v in enumerate(test_values) if self.isnumber(v) and float(v) <= threshold]
        elif condition.startswith('>'):
            threshold = float(condition[1:])
            matching_indices = [i for i, v in enumerate(test_values) if self.isnumber(v) and float(v) > threshold]
        elif condition.startswith('<'):
            threshold = float(condition[1:])
            matching_indices = [i for i, v in enumerate(test_values) if self.isnumber(v) and float(v) < threshold]
        elif condition.startswith('='):
            target = condition[1:].strip('"\'')
            matching_indices = [i for i, v in enumerate(test_values) if str(v) == target]
        elif condition.startswith('!='):
            target = condition[2:].strip('"\'')
            matching_indices = [i for i, v in enumerate(test_values) if str(v) != target]
        else:
            # Exact match
            target = condition.strip('"\'')
            matching_indices = [i for i, v in enumerate(test_values) if str(v) == target]
        
        # Sum matching values
        total = 0
        for i in matching_indices:
            if i < len(sum_values):
                total += sum_values[i]
        
        return total
    
    def countif(self, col_ref, condition):
        """Count values that meet condition: COUNTIF(column, ">100")"""
        values = self._get_all_column_values(col_ref)
        
        # Parse condition - check longer operators first
        if condition.startswith('>='):
            threshold = float(condition[2:])
            return sum(1 for v in values if self.isnumber(v) and float(v) >= threshold)
        elif condition.startswith('<='):
            threshold = float(condition[2:])
            return sum(1 for v in values if self.isnumber(v) and float(v) <= threshold)
        elif condition.startswith('>'):
            threshold = float(condition[1:])
            return sum(1 for v in values if self.isnumber(v) and float(v) > threshold)
        elif condition.startswith('<'):
            threshold = float(condition[1:])
            return sum(1 for v in values if self.isnumber(v) and float(v) < threshold)
        elif condition.startswith('='):
            target = condition[1:].strip('"\'')
            return sum(1 for v in values if str(v) == target)
        elif condition.startswith('!='):
            target = condition[2:].strip('"\'')
            return sum(1 for v in values if str(v) != target)
        else:
            # Exact match
            target = condition.strip('"\'')
            return sum(1 for v in values if str(v) == target)
    
    def averageif(self, col_ref, condition, avg_col_ref=None):
        """Average values that meet condition"""
        if avg_col_ref is None:
            avg_col_ref = col_ref
        
        total = self.sumif(col_ref, condition, avg_col_ref)
        count = self.countif(col_ref, condition)
        
        return total / count if count > 0 else 0
    
    # Utility functions
    def unique_count(self, col_ref):
        """Count unique values in column"""
        values = self._get_all_column_values(col_ref)
        return len(set(values))
    
    def distinct_values(self, col_ref):
        """Get list of distinct values"""
        values = self._get_all_column_values(col_ref)
        return sorted(list(set(values)))
    
    def rank_value(self, col_ref, target_value, descending=True):
        """Get rank of a specific value (1-based ranking)"""
        values = self._get_column_values(col_ref)
        sorted_values = sorted(values, reverse=descending)
        
        try:
            target = float(target_value)
            return sorted_values.index(target) + 1
        except (ValueError, TypeError):
            return 0
    
    def outliers_iqr(self, col_ref):
        """Detect outliers using IQR method - returns list of outlier values"""
        values = self._get_column_values(col_ref)
        if len(values) < 4:
            return []
        
        q1 = self.quartile_column(col_ref, 1)
        q3 = self.quartile_column(col_ref, 3)
        iqr = q3 - q1
        
        lower_bound = q1 - 1.5 * iqr
        upper_bound = q3 + 1.5 * iqr
        
        outliers = [v for v in values if v < lower_bound or v > upper_bound]
        return outliers
    
    def zscore_normalize(self, col_ref, target_value):
        """Calculate Z-score for a specific value"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0
        
        mean = sum(values) / len(values)
        std_dev = self.stddev_column(col_ref)
        
        if std_dev == 0:
            return 0
        
        try:
            target = float(target_value)
            return (target - mean) / std_dev
        except (ValueError, TypeError):
            return 0
    
    def minmax_normalize(self, col_ref, target_value):
        """Normalize value to 0-1 range using min-max normalization"""
        values = self._get_column_values(col_ref)
        if not values:
            return 0
        
        min_val = min(values)
        max_val = max(values)
        
        if min_val == max_val:
            return 0
        
        try:
            target = float(target_value)
            return (target - min_val) / (max_val - min_val)
        except (ValueError, TypeError):
            return 0
    
    def evaluate_expression(self, expression: str) -> Any:
        """Evaluate mathematical expression with function calls"""
        # Create wrapper functions for safe evaluation
        def SUM(col_ref): return self.sum_column(col_ref)
        def AVG(col_ref): return self.avg_column(col_ref)
        def COUNT(col_ref): return self.count_column(col_ref)
        def MIN(col_ref): return self.min_column(col_ref)
        def MAX(col_ref): return self.max_column(col_ref)
        def MED(col_ref): return self.median_column(col_ref)
        def MEDIAN(col_ref): return self.median_column(col_ref)
        def MODE(col_ref): return self.mode_column(col_ref)
        def STDDEV(col_ref): return self.stddev_column(col_ref)
        def QUARTILE(col_ref, q): return self.quartile_column(col_ref, q)
        def IQR(col_ref): return self.iqr_column(col_ref)
        def NTILE(col_ref, n, tile): return self.ntile_column(col_ref, n, tile)
        def PERCENTILE(col_ref, percentiles): return self.percentile_column(col_ref, percentiles)
        def VALUES(col_refs): return self.values_column(col_refs)
        def PRINT(col_refs): return self.print_column(col_refs)
        
        # Logical functions
        def IF(condition, true_value, false_value): return self.if_function(condition, true_value, false_value)
        def AND(*args): return self.and_function(*args)
        def OR(*args): return self.or_function(*args)
        def NOT(value): return self.not_function(value)
        def ISNUMBER(value): return self.isnumber(value)
        def ISTEXT(value): return self.istext(value)
        
        # Conditional aggregation
        def SUMIF(col_ref, condition, sum_col_ref=None): return self.sumif(col_ref, condition, sum_col_ref)
        def COUNTIF(col_ref, condition): return self.countif(col_ref, condition)
        def AVERAGEIF(col_ref, condition, avg_col_ref=None): return self.averageif(col_ref, condition, avg_col_ref)
        
        # Utility functions  
        def UNIQUE(col_ref): return self.unique_count(col_ref)
        def DISTINCT(col_ref): return self.distinct_values(col_ref)
        def RANK(col_ref, target_value, descending=True): return self.rank_value(col_ref, target_value, descending)
        def OUTLIERS(col_ref): return self.outliers_iqr(col_ref)
        def ZSCORE(col_ref, target_value): return self.zscore_normalize(col_ref, target_value)
        def NORMALIZE(col_ref, target_value): return self.minmax_normalize(col_ref, target_value)
        
        # Create a safe namespace for evaluation
        safe_dict = {
            '__builtins__': {},
            'SUM': SUM,
            'AVG': AVG,
            'COUNT': COUNT,
            'MIN': MIN,
            'MAX': MAX,
            'MED': MED,
            'MEDIAN': MEDIAN,
            'MODE': MODE,
            'STDDEV': STDDEV,
            'QUARTILE': QUARTILE,
            'IQR': IQR,
            'NTILE': NTILE,
            'PERCENTILE': PERCENTILE,
            'VALUES': VALUES,
            'PRINT': PRINT,
            # Logical functions
            'IF': IF,
            'AND': AND,
            'OR': OR,
            'NOT': NOT,
            'ISNUMBER': ISNUMBER,
            'ISTEXT': ISTEXT,
            # Conditional aggregation
            'SUMIF': SUMIF,
            'COUNTIF': COUNTIF,
            'AVERAGEIF': AVERAGEIF,
            # Utility functions
            'UNIQUE': UNIQUE,
            'DISTINCT': DISTINCT,
            'RANK': RANK,
            'OUTLIERS': OUTLIERS,
            'ZSCORE': ZSCORE,
            'NORMALIZE': NORMALIZE,
            'abs': abs,
            'round': round,
            'int': int,
            'float': float,
            'pow': pow,
            'sqrt': math.sqrt,
            'ceil': math.ceil,
            'floor': math.floor,
        }
        
        try:
            # Replace column references in function calls
            # Handle $_column_name pattern - only if not already quoted
            expression = re.sub(
                r'(?<!")(\$_[a-zA-Z_][a-zA-Z0-9_]*)(?!")',
                r'"\1"',
                expression
            )
            
            # Handle single letter column references in functions - only if not already quoted
            expression = re.sub(
                r'(?<!")([A-Z])(?=[,)])(?!")',
                r'"\1"',
                expression
            )
            
            result = eval(expression, safe_dict)
            # Handle different return types
            if isinstance(result, (list, dict, str)):
                return result
            return float(result)
        except Exception as e:
            raise ValueError(f"Error evaluating expression: {e}")

    def add_calculated_columns(self, formulas):
        """Add calculated columns to the table based on formulas"""
        calculated_data = []
        
        for formula in formulas:
            # Parse formula: "column_name = expression"
            if '=' not in formula:
                raise ValueError(f"Invalid formula format: {formula}. Expected 'column_name = expression'")
            
            parts = formula.split('=', 1)
            if len(parts) != 2:
                raise ValueError(f"Invalid formula format: {formula}. Expected 'column_name = expression'")
            
            column_name = parts[0].strip()
            expression = parts[1].strip()
            
            # Calculate values for each row
            column_values = []
            
            # Check if this is a row-wise calculation (contains single column references)
            # vs aggregate function (contains functions like SUM, AVG, etc.)
            is_row_wise = self._is_row_wise_expression(expression)
            
            try:
                if is_row_wise:
                    # Calculate value for each row
                    for row_idx, row in enumerate(self.data):
                        row_value = self._evaluate_row_expression(expression, row_idx)
                        column_values.append(str(row_value))
                else:
                    # Table-wide calculation - same value for all rows
                    result = self.evaluate_expression(expression)
                    
                    if isinstance(result, (int, float, bool)):
                        column_values = [str(result)] * len(self.data)
                    elif isinstance(result, str):
                        column_values = [result] * len(self.data)
                    elif isinstance(result, list):
                        # If it's a list, use the values directly (truncate or pad as needed)
                        column_values = [str(v) for v in result]
                        # Pad or truncate to match data length
                        while len(column_values) < len(self.data):
                            column_values.append('')
                        column_values = column_values[:len(self.data)]
                    else:
                        column_values = [str(result)] * len(self.data)
                
                calculated_data.append((column_name, column_values))
                
            except Exception as e:
                raise ValueError(f"Error calculating formula '{formula}': {e}")
        
        return calculated_data

    def _is_row_wise_expression(self, expression):
        """Determine if expression should be calculated per row vs table-wide"""
        # If expression contains aggregation functions, it's table-wide
        aggregate_functions = ['SUM', 'AVG', 'COUNT', 'MIN', 'MAX', 'MEDIAN', 'MED', 'MODE', 'STDDEV']
        
        for func in aggregate_functions:
            if func + '(' in expression.upper():
                return False
        
        # If it contains column references, it's likely row-wise
        import re
        if re.search(r'\$_\w+', expression) or re.search(r'\b[A-Z]\b', expression):
            return True
        
        return False

    def _evaluate_row_expression(self, expression, row_idx):
        """Evaluate expression in the context of a specific row"""
        if row_idx >= len(self.data):
            return 0
        
        row = self.data[row_idx]
        
        # Replace column references with actual values
        import re
        
        # Replace $_column_name references
        def replace_column_ref(match):
            col_name = match.group(1)
            if col_name in self.column_map:
                col_idx = self.column_map[col_name]
                if col_idx < len(row):
                    value_str = row[col_idx]
                    # Clean numeric value (remove $, commas, etc.)
                    clean_value = re.sub(r'[$,]', '', value_str)
                    try:
                        return str(float(clean_value))
                    except ValueError:
                        return f'"{value_str}"'
                else:
                    return '0'
            else:
                raise ValueError(f"Column '{col_name}' not found")
        
        # Replace column letter references
        def replace_letter_ref(match):
            col_letter = match.group(0)
            if col_letter in self.column_map:
                col_idx = self.column_map[col_letter]
                if col_idx < len(row):
                    value_str = row[col_idx]
                    # Clean numeric value (remove $, commas, etc.)
                    clean_value = re.sub(r'[$,]', '', value_str)
                    try:
                        return str(float(clean_value))
                    except ValueError:
                        return f'"{value_str}"'
                else:
                    return '0'
            else:
                raise ValueError(f"Column '{col_letter}' not found")
        
        # Process expression
        processed_expr = re.sub(r'\$_(\w+)', replace_column_ref, expression)
        processed_expr = re.sub(r'\b([A-Z])\b', replace_letter_ref, processed_expr)
        
        # Evaluate the processed expression
        try:
            result = eval(processed_expr, {'__builtins__': {}, 'abs': abs, 'round': round, 'int': int, 'float': float, 'pow': pow})
            return result
        except Exception as e:
            raise ValueError(f"Error evaluating row expression '{processed_expr}': {e}")

    def generate_table_with_formulas(self, formulas):
        """Generate markdown table with additional calculated columns"""
        if not formulas:
            return self.generate_original_table()
        
        # Get calculated columns
        calculated_data = self.add_calculated_columns(formulas)
        
        # Build new headers
        new_headers = self.headers[:]
        for column_name, _ in calculated_data:
            new_headers.append(column_name)
        
        # Build new data rows
        new_data = []
        for i, row in enumerate(self.data):
            new_row = row[:]
            for _, column_values in calculated_data:
                if i < len(column_values):
                    new_row.append(column_values[i])
                else:
                    new_row.append('')
            new_data.append(new_row)
        
        # Generate markdown table
        lines = []
        
        # Header line
        header_line = "| " + " | ".join(new_headers) + " |"
        lines.append(header_line)
        
        # Separator line
        separator_line = "|" + "|".join(["-" * (len(h) + 2) for h in new_headers]) + "|"
        lines.append(separator_line)
        
        # Data lines
        for row in new_data:
            data_line = "| " + " | ".join(str(cell) for cell in row) + " |"
            lines.append(data_line)
        
        return '\n'.join(lines)

    def generate_original_table(self):
        """Generate the original markdown table"""
        lines = []
        
        # Header line
        header_line = "| " + " | ".join(self.headers) + " |"
        lines.append(header_line)
        
        # Separator line
        separator_line = "|" + "|".join(["-" * (len(h) + 2) for h in self.headers]) + "|"
        lines.append(separator_line)
        
        # Data lines
        for row in self.data:
            data_line = "| " + " | ".join(str(cell) for cell in row) + " |"
            lines.append(data_line)
        
        return '\n'.join(lines)

def print_function_reference():
    """Print comprehensive function reference"""
    print("""
MD_TABLE_CALC FUNCTION REFERENCE
=================================

COLUMN REFERENCES:
  $_column_name    Reference column by header name (e.g., $_score, $_price)
  A, B, C, ...     Reference column by letter (A=1st column, B=2nd, etc.)

STATISTICAL FUNCTIONS:
  SUM(column)                     Sum all values in column
  AVG(column)                     Average of all values  
  COUNT(column)                   Count of numeric values
  MIN(column)                     Minimum value
  MAX(column)                     Maximum value
  MED(column) / MEDIAN(column)    Median (50th percentile)
  MODE(column)                    Most frequently occurring value
  STDDEV(column)                  Sample standard deviation
  
PERCENTILE FUNCTIONS:
  QUARTILE(column, q)             Quartile (q=1,2,3 for Q1,Q2,Q3)
  PERCENTILE(column, p)           Single percentile (p=0-100)
  PERCENTILE(column, [p1,p2,p3])  Multiple percentiles
  NTILE(column, n, tile)          Divide into N groups, get tile boundary
  IQR(column)                     Interquartile range (Q3-Q1)

DATA ACCESS FUNCTIONS:
  VALUES(column)                  Get all values as array
  VALUES([col1, col2, ...])       Get multiple columns as JSON object
  PRINT(column)                   Print values one per line
  PRINT([col1, col2, ...])        Print columns in tab-separated format

LOGICAL FUNCTIONS:
  IF(condition, true_val, false_val)  Conditional logic
  AND(val1, val2, ...)            Logical AND of all arguments
  OR(val1, val2, ...)             Logical OR of all arguments  
  NOT(value)                      Logical negation
  ISNUMBER(value)                 True if value is numeric
  ISTEXT(value)                   True if value is text

CONDITIONAL AGGREGATION:
  SUMIF(column, condition)              Sum values meeting condition
  SUMIF(test_col, condition, sum_col)   Sum sum_col where test_col meets condition
  COUNTIF(column, condition)            Count values meeting condition
  AVERAGEIF(column, condition)          Average values meeting condition
  AVERAGEIF(test_col, condition, avg_col)  Average avg_col where test_col meets condition

  Condition Examples:
    ">50"      Greater than 50
    "<100"     Less than 100  
    ">=85"     Greater than or equal to 85
    "<=90"     Less than or equal to 90
    "=A"       Equals "A" (exact match)
    "!=B"      Not equal to "B"
    "pass"     Exact text match (same as "=pass")

UTILITY FUNCTIONS:
  UNIQUE(column)                  Count of unique values
  DISTINCT(column)                Array of unique values (sorted)
  RANK(column, value)             Rank of value (1=highest, descending)
  RANK(column, value, False)      Rank of value (1=lowest, ascending)
  OUTLIERS(column)                Detect outliers using IQR method
  ZSCORE(column, value)           Z-score normalization of value
  NORMALIZE(column, value)        Min-max normalization (0-1 range)

MATHEMATICAL FUNCTIONS:
  abs(x), round(x), int(x), float(x)     Basic math functions
  pow(x, y), sqrt(x)                     Power and square root
  ceil(x), floor(x)                      Ceiling and floor

USAGE EXAMPLES:
  Basic Statistics:
    md_table_calc 'AVG($_score)'
    md_table_calc 'SUM($_amount) * 1.08'                    # Add 8% tax
    md_table_calc 'PERCENTILE($_score, [25, 50, 75])'      # Quartiles

  Conditional Logic:
    md_table_calc 'IF(AVG($_score) > 85, "Pass", "Fail")'
    md_table_calc 'AND(MIN($_score) > 70, AVG($_score) > 80)'

  Conditional Aggregation:
    md_table_calc 'SUMIF($_category, "food", $_amount)'     # Sum food expenses
    md_table_calc 'COUNTIF($_grade, ">=85")'               # Count high scores
    md_table_calc 'AVERAGEIF($_status, "active", $_salary)' # Avg active salaries

  Data Analysis:
    md_table_calc 'UNIQUE($_department)'                    # Count departments
    md_table_calc 'OUTLIERS($_salary)'                      # Find salary outliers
    md_table_calc 'RANK($_performance, 95)'                 # Rank performance

  Data Access:
    md_table_calc 'VALUES($_score)'                         # All scores as array
    md_table_calc 'PRINT(["$_name", "$_score"])'           # Names and scores
    md_table_calc --column $_score                          # Print scores (alt syntax)

  Complex Expressions:
    md_table_calc 'IF(COUNTIF($_status, "failed") > 0, "Alert", "OK")'
    md_table_calc 'round(SUMIF($_category, "A", $_price) / COUNTIF($_category, "A"), 2)'
""")

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='Excel-like calculations for markdown tables')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('expression', nargs='?', help='Mathematical expression to evaluate')
    group.add_argument('--column', '-c', help='Print all values from specified column(s)')
    group.add_argument('--formula', '-f', action='append', help='Add calculated column: "column_name = expression"')
    group.add_argument('--list-functions', '-l', action='store_true', help='List all available functions')
    
    args = parser.parse_args()
    
    # Handle --list-functions flag
    if args.list_functions:
        print_function_reference()
        return
    
    try:
        # Read input from stdin
        lines = sys.stdin.readlines()
        
        # Create calculator and parse table
        calc = MarkdownTableCalculator()
        calc.parse_table(lines)
        
        # Handle formula mode
        if args.formula:
            # Generate table with calculated columns
            result_table = calc.generate_table_with_formulas(args.formula)
            print(result_table)
            return
        
        # Determine what operation to perform
        if args.column:
            # Handle --column flag - can be single column or comma-separated list
            if ',' in args.column:
                col_refs = [col.strip() for col in args.column.split(',')]
                # Create list representation for expression
                col_list = ', '.join(f'"{col}"' for col in col_refs)
                expression = f'PRINT([{col_list}])'
            else:
                expression = f'PRINT("{args.column}")'
        else:
            expression = args.expression
        
        # Evaluate expression
        result = calc.evaluate_expression(expression)
        
        # Format result - handle different return types
        if isinstance(result, str):
            # String result (from PRINT function) - output directly
            print(result)
        elif isinstance(result, dict):
            # Dictionary result (from VALUES with multiple columns)
            import json
            formatted_dict = {}
            for key, values in result.items():
                formatted_values = []
                for val in values:
                    if isinstance(val, float) and val == int(val):
                        formatted_values.append(int(val))
                    else:
                        formatted_values.append(val)
                formatted_dict[key] = formatted_values
            print(json.dumps(formatted_dict, indent=2))
        elif isinstance(result, list):
            # List result (from VALUES single column or PERCENTILE)
            formatted = []
            for val in result:
                if isinstance(val, float) and val == int(val):
                    formatted.append(str(int(val)))
                elif isinstance(val, float):
                    formatted.append(f"{val:.2f}")
                else:
                    formatted.append(str(val))
            print("[" + ", ".join(formatted) + "]")
        elif isinstance(result, bool):
            # Boolean result
            print("True" if result else "False")
        else:
            # Single numeric value
            if isinstance(result, float) and result == int(result):
                print(int(result))
            else:
                print(f"{result:.2f}")
            
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()