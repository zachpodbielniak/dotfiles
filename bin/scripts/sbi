#!/bin/bash

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail

# ==============================================================================
# sbi - Second Brain Ingest
# ==============================================================================
# Author: Zach
# Version: 1.0
# Last Updated: May 4, 2025
# Location: ~/.dotfiles/bin/scripts/sbi
#
# Description:
# A comprehensive utility for ingesting various content types into a second brain 
# knowledge management system organized using the PARA methodology (Projects, 
# Areas, Resources, Archives). This script handles multiple content formats, from
# plain text to multimedia, converting them to a consistent format (Markdown by default, 
# or Neorg when --neorg flag is used).
#
# Features:
# - Supports multiple content types (text, audio, video, web content, ebooks, PDFs)
# - Automatically transcribes audio/video files using Whisper
# - Generates AI summaries of content
# - Processes YouTube videos and other web content directly from URLs
# - Supports piping content from stdin
# - Integrates with the PARA organizational structure
# - Provides content editing capabilities
# - Supports custom naming for ingested content
# - Offers directory structure viewing and navigation
# - Handles append mode for existing files
#
# Dependencies:
# - transcribe_audio: For audio transcription (via Whisper distrobox)
# - strip_audio: For extracting audio from video (via FFmpeg)
# - ai_summary_as_markdown: For generating summaries in Markdown format
# - perpy: For AI-based PARA category detection
# - mton: For Markdown to Neorg conversion (used only with --neorg flag)
# - yt-dlp: For YouTube content downloading
# - markitdown: For document/HTML conversion (preferred)
# - pandoc: For document format conversion (fallback)
# - curl: For web content downloading
# - vipe: For editing content within pipes
# - Various fallback utilities: lynx/w3m, pdftotext, etc.
#
# Usage: See the show_help() function or run with --help flag
# ==============================================================================

# Configuration
NOTES_DIR="$HOME/Documents/notes"  # Base directory for second brain
DEFAULT_PARA="00_inbox"            # Default PARA category if none specified
PARA_MAP=("00_inbox" "01_projects" "02_areas" "03_resources" "04_archives")  # Valid PARA categories
DEBUG_MODE=false                   # Debug mode flag, toggled with --debug
DEBUG_LOG_FILE=""                  # Optional log file path for persistent logging
INTERACTIVE_MODE=false             # Interactive TUI mode flag, toggled with --interactive
SANITIZE_MODE=false                # Sanitize mode flag, toggled with --sanitize

# Web crawling configuration
CRAWL_MODE=false                   # Web crawling mode flag, toggled with --crawl
EXPORT_MODE=false                  # Site export processing mode flag, toggled with --export
CRAWL_ARCHIVE=false                # Whether to save the complete website archive
SILENT_MODE=false                  # Silent mode flag, toggled with --silent
NO_SUMMARY_MODE=false              # Skip AI summary generation, toggled with --no-summary
NEORG_MODE=false                   # Use neorg output format instead of markdown, toggled with --neorg
SUMMARY_TYPE=""                    # Type of summary to generate, passed to ai_summary_as_markdown with --type
SUMMARY_PROMPT=""                  # Custom prompt to use for summary, passed to ai_summary_as_markdown with --prompt
SUMMARY_PRINCIPLE_MODE=false       # Whether to use principle mode, passed to ai_summary_as_markdown with --principle
SUMMARY_PROVIDER=""                # Provider to use for AI summary (perpy, claudpy, grokpy, geminpy, ollampy, openpy)
SUMMARY_MODEL=""                   # Model to use with the selected provider
TAGS=""                            # CSV list of tags to apply to the content
CRAWL_DEPTH=1                      # Default crawl depth (1 = just the specified page)
CRAWL_DOMAIN_RESTRICT=true         # Restrict crawl to the same domain by default
CRAWL_WAIT=1                       # Wait between retrievals (seconds) for politeness
CRAWL_EXCLUDE_PATTERN=""           # Pattern to exclude during crawling
CRAWL_INCLUDE_PATTERN=""           # Pattern to include during crawling
CRAWL_USER_AGENT="Mozilla/5.0 (X11; Linux x86_64) SBI/1.0" # User agent for crawling

# Error types and exit codes
# Exit codes follow a logical categorization to help with scripting and automation
readonly EXIT_SUCCESS=0            # Successful execution
readonly EXIT_GENERAL_ERROR=1      # General/unspecified error
readonly EXIT_USAGE_ERROR=2        # Command line usage error
readonly EXIT_FILE_NOT_FOUND=3     # File or directory not found
readonly EXIT_PERMISSION_DENIED=4  # Permission denied
readonly EXIT_NETWORK_ERROR=5      # Network-related error
readonly EXIT_DEPENDENCY_ERROR=6   # Missing dependency
readonly EXIT_CONVERSION_ERROR=7   # Format conversion error
readonly EXIT_EXTERNAL_TOOL_ERROR=8 # External tool failure
readonly EXIT_PROCESSING_ERROR=9   # Content processing error

# Error type definitions
readonly ERROR_TYPE_INPUT="INPUT_ERROR"           # Invalid input
readonly ERROR_TYPE_FILE="FILE_ERROR"             # File-related errors
readonly ERROR_TYPE_PERMISSION="PERMISSION_ERROR" # Permission issues
readonly ERROR_TYPE_NETWORK="NETWORK_ERROR"       # Network connectivity
readonly ERROR_TYPE_DEPENDENCY="DEPENDENCY_ERROR" # Missing dependencies
readonly ERROR_TYPE_CONVERSION="CONVERSION_ERROR" # Format conversion
readonly ERROR_TYPE_EXTERNAL="EXTERNAL_TOOL_ERROR" # External tools
readonly ERROR_TYPE_PROCESSING="PROCESSING_ERROR" # Content processing

# Function to handle debug logging
debug_log() {
    # Function: debug_log
    # Purpose: Log debug information with timestamps and log levels
    # Arguments:
    #   $1 - Log level (DEBUG, INFO, WARNING, ERROR)
    #   $2 - Message to log
    # Returns: None, writes to stderr and optionally to log file

    # Skip if debug mode is not enabled
    if [[ "$DEBUG_MODE" != true ]]; then
        return 0
    fi
    
    local level="$1"
    local message="$2"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    local line_info=""
    
    # Get caller information (file and line number)
    # BASH_SOURCE[1] is the script name of the caller
    # BASH_LINENO[0] is the line number of the caller
    if [[ "${#BASH_SOURCE[@]}" -gt 1 ]]; then
        local caller_file=$(basename "${BASH_SOURCE[1]}")
        local caller_line="${BASH_LINENO[0]}"
        line_info="[$caller_file:$caller_line]"
    fi
    
    # Format the log message
    local log_entry="[$timestamp] [$level]$line_info $message"
    
    # Output to stderr for console visibility
    echo "$log_entry" >&2
    
    # If a log file is specified, also write to that file
    if [[ -n "$DEBUG_LOG_FILE" ]]; then
        echo "$log_entry" >> "$DEBUG_LOG_FILE"
    fi
}

# Function to output progress information to stderr
show_progress() {
    # Function: show_progress
    # Purpose: Display progress information to the user (through stderr)
    # Arguments:
    #   $1 - Message to display
    # Returns: None, writes to stderr unless SILENT_MODE is true
    
    # Skip if silent mode is enabled
    if [[ "$SILENT_MODE" == true ]]; then
        return 0
    fi
    
    local message="$1"
    echo "$message" >&2
}

# Function to handle errors in a standardized way
handle_error() {
    # Function: handle_error
    # Purpose: Centralized error handling with categorization and recovery options
    # Arguments:
    #   $1 - Error type (e.g., INPUT_ERROR, FILE_ERROR) - use ERROR_TYPE_* constants
    #   $2 - Error message
    #   $3 - Exit code (optional - if omitted, the error is non-fatal)
    #   $4 - Severity (optional - defaults to "ERROR", can be "WARNING" or "FATAL")
    # Returns: Exits with specified code if exit_code is provided, otherwise returns
    
    local error_type="$1"
    local message="$2"
    local exit_code="${3:-}"  # Optional exit code (if omitted, error is non-fatal)
    local severity="${4:-ERROR}"  # Default severity is ERROR
    
    # Always log the error if debugging is enabled
    debug_log "$severity" "[$error_type] $message"
    
    # Format the error message with severity and type for user visibility
    local formatted_message="[$severity] $error_type: $message"
    echo "$formatted_message" >&2
    
    # Provide guidance on how to resolve common issues
    case "$error_type" in
        "$ERROR_TYPE_PERMISSION")
            echo "Suggestion: Check file permissions or run with elevated privileges" >&2
            ;;
        "$ERROR_TYPE_NETWORK")
            echo "Suggestion: Check your internet connection and try again" >&2
            ;;
        "$ERROR_TYPE_DEPENDENCY")
            echo "Suggestion: Install the required dependency and try again" >&2
            ;;
        "$ERROR_TYPE_FILE")
            echo "Suggestion: Verify the file path and ensure the file exists" >&2
            ;;
        "$ERROR_TYPE_INPUT")
            echo "Suggestion: Check command syntax or input format" >&2
            ;;
        "$ERROR_TYPE_CONVERSION")
            echo "Suggestion: Check file format compatibility or try a different conversion approach" >&2
            ;;
        "$ERROR_TYPE_EXTERNAL")
            echo "Suggestion: Check that external tools are properly installed and configured" >&2
            ;;
        "$ERROR_TYPE_PROCESSING")
            echo "Suggestion: Review content format or try with --debug flag for more information" >&2
            ;;
    esac
    
    # Exit with the specified code if this is a fatal error
    if [[ -n "$exit_code" ]]; then
        debug_log "FATAL" "Exiting with code $exit_code due to error: $message"
        exit "$exit_code"
    fi
    
    # For non-fatal errors, just return
    return 0
}

# Function to run ai_summary with the appropriate arguments
run_ai_summary() {
    # Function: run_ai_summary
    # Purpose: Run ai_summary_as_markdown or ai_summary_as_neorg with appropriate arguments based on global settings
    # Arguments:
    #   $1 - Input file/stream (uses stdin if not provided)
    #   $2 - Output file (uses stdout if not provided)
    # Returns: Exit code of ai_summary command

    local input_source="${1:-/dev/stdin}"
    local output_dest="${2:-/dev/stdout}"
    local args=""
    local summary_cmd="ai_summary_as_markdown"  # Default command

    # Use ai_summary_as_neorg if neorg mode is enabled
    if [[ "$NEORG_MODE" == true ]]; then
        summary_cmd="ai_summary_as_neorg"
        debug_log "DEBUG" "Using ai_summary_as_neorg due to --neorg flag"
    fi

    # Skip if NO_SUMMARY_MODE is true
    if [[ "$NO_SUMMARY_MODE" == true ]]; then
        debug_log "INFO" "Skipping AI summary due to --no-summary flag"
        if [[ "$input_source" != "/dev/stdin" ]] && [[ "$output_dest" != "/dev/stdout" ]]; then
            # Direct file copy instead of AI summary
            cat "$input_source" > "$output_dest"
            return $?
        else
            # Pass through stdin to stdout
            cat
            return $?
        fi
    fi

    # Build arguments based on the set flags
    if [[ -n "$SUMMARY_TYPE" ]]; then
        args="$args --type $SUMMARY_TYPE"
        debug_log "DEBUG" "Using summary type: $SUMMARY_TYPE"
    fi

    if [[ -n "$SUMMARY_PROMPT" ]]; then
        args="$args --prompt \"$SUMMARY_PROMPT\""
        debug_log "DEBUG" "Using custom prompt: $SUMMARY_PROMPT"
    fi

    if [[ "$SUMMARY_PRINCIPLE_MODE" == true ]]; then
        args="$args --principle"
        debug_log "DEBUG" "Using principle mode for summary"
    fi

    # Forward debug flag
    if [[ "$DEBUG_MODE" == true ]]; then
        args="$args --debug"
        debug_log "DEBUG" "Forwarding debug flag to AI summary command"
    fi

    # Forward provider if specified
    if [[ -n "$SUMMARY_PROVIDER" ]]; then
        args="$args --provider $SUMMARY_PROVIDER"
        debug_log "DEBUG" "Forwarding provider: $SUMMARY_PROVIDER"
    fi

    # Forward model if specified
    if [[ -n "$SUMMARY_MODEL" ]]; then
        args="$args --model $SUMMARY_MODEL"
        debug_log "DEBUG" "Forwarding model: $SUMMARY_MODEL"
    fi

    # Execute the command with the appropriate arguments
    debug_log "DEBUG" "Running $summary_cmd with args: $args"

    # Check if sanitize mode is enabled
    local sanitize_pipe=""
    if [[ "$SANITIZE_MODE" == true ]]; then
        sanitize_pipe="sanitize_data | "
        debug_log "INFO" "Sanitizing content using sanitize_data before processing"
    fi

    if [[ "$input_source" != "/dev/stdin" ]]; then
        if [[ "$output_dest" != "/dev/stdout" ]]; then
            # Both input and output are files
            if [[ -n "$args" ]]; then
                if [[ "$SANITIZE_MODE" == true ]]; then
                    eval "cat \"$input_source\" | sanitize_data | $summary_cmd $args > \"$output_dest\""
                else
                    eval "cat \"$input_source\" | $summary_cmd $args > \"$output_dest\""
                fi
            else
                if [[ "$SANITIZE_MODE" == true ]]; then
                    cat "$input_source" | sanitize_data | $summary_cmd > "$output_dest"
                else
                    cat "$input_source" | $summary_cmd > "$output_dest"
                fi
            fi
        else
            # Input is a file, output to stdout
            if [[ -n "$args" ]]; then
                if [[ "$SANITIZE_MODE" == true ]]; then
                    eval "cat \"$input_source\" | sanitize_data | $summary_cmd $args"
                else
                    eval "cat \"$input_source\" | $summary_cmd $args"
                fi
            else
                if [[ "$SANITIZE_MODE" == true ]]; then
                    cat "$input_source" | sanitize_data | $summary_cmd
                else
                    cat "$input_source" | $summary_cmd
                fi
            fi
        fi
    else
        if [[ "$output_dest" != "/dev/stdout" ]]; then
            # Input from stdin, output to a file
            if [[ -n "$args" ]]; then
                if [[ "$SANITIZE_MODE" == true ]]; then
                    eval "sanitize_data | $summary_cmd $args > \"$output_dest\""
                else
                    eval "$summary_cmd $args > \"$output_dest\""
                fi
            else
                if [[ "$SANITIZE_MODE" == true ]]; then
                    sanitize_data | $summary_cmd > "$output_dest"
                else
                    $summary_cmd > "$output_dest"
                fi
            fi
        else
            # Both input and output use stdin/stdout
            if [[ -n "$args" ]]; then
                if [[ "$SANITIZE_MODE" == true ]]; then
                    eval "sanitize_data | $summary_cmd $args"
                else
                    eval "$summary_cmd $args"
                fi
            else
                if [[ "$SANITIZE_MODE" == true ]]; then
                    sanitize_data | $summary_cmd
                else
                    $summary_cmd
                fi
            fi
        fi
    fi

    return $?
}

# Function to check for TUI dependencies
check_tui_dependencies() {
    # Function: check_tui_dependencies
    # Purpose: Check if required dependencies for TUI mode are installed
    # Arguments: None
    # Returns: 0 if all dependencies are installed, 1 otherwise
    
    # Check for dialog utility
    if ! command -v dialog &> /dev/null; then
        debug_log "ERROR" "Required utility 'dialog' not found for interactive mode"
        handle_error "$ERROR_TYPE_DEPENDENCY" "'dialog' utility is required for interactive mode. Please install dialog (e.g., 'sudo apt install dialog' or equivalent for your system)." "$EXIT_DEPENDENCY_ERROR"
        return 1
    fi
    
    debug_log "DEBUG" "All TUI dependencies are installed"
    return 0
}

# Function to check for web crawling dependencies
check_crawl_dependencies() {
    # Function: check_crawl_dependencies
    # Purpose: Check if required dependencies for web crawling are installed
    # Arguments: None
    # Returns: 0 if all dependencies are installed, 1 otherwise
    
    # Check for wget utility (primary crawler)
    if ! command -v wget &> /dev/null; then
        debug_log "ERROR" "Required utility 'wget' not found for web crawling"
        handle_error "$ERROR_TYPE_DEPENDENCY" "'wget' utility is required for web crawling. Please install wget (e.g., 'sudo apt install wget' or equivalent for your system)." "$EXIT_DEPENDENCY_ERROR"
        return 1
    fi
    
    # Check for additional utilities that enhance functionality
    local missing_utilities=()
    local html_converters=()
    
    # Check for html2text (used to convert HTML to readable text)
    if command -v html2text &> /dev/null; then
        html_converters+=("html2text")
    else
        missing_utilities+=("html2text")
    fi
    
    # Check for lynx (alternative HTML renderer)
    if command -v lynx &> /dev/null; then
        html_converters+=("lynx")
    else
        if [[ ${#html_converters[@]} -eq 0 ]]; then
            missing_utilities+=("lynx")
        fi
    fi
    
    # Check for w3m (another alternative HTML renderer)
    if command -v w3m &> /dev/null; then
        html_converters+=("w3m")
    else
        if [[ ${#html_converters[@]} -eq 0 ]]; then
            missing_utilities+=("w3m")
        fi
    fi
    
    # Report on available and missing utilities
    if [[ ${#html_converters[@]} -gt 0 ]]; then
        debug_log "INFO" "HTML conversion will use: ${html_converters[0]}"
    else
        debug_log "WARNING" "No HTML to text converters found. Will use basic text extraction."
        missing_utilities+=("any HTML to text converter")
    fi
    
    # Report on optional missing utilities
    if [[ ${#missing_utilities[@]} -gt 0 ]]; then
        debug_log "WARNING" "Some optional utilities for enhanced web crawling are not installed: ${missing_utilities[*]}"
        echo "Warning: Some optional utilities for enhanced web crawling are not installed: ${missing_utilities[*]}"
        echo "Web crawling will work, but content processing may be limited."
        echo "For better HTML processing, consider installing one of: html2text, lynx, or w3m"
    fi
    
    debug_log "DEBUG" "All required web crawling dependencies are installed"
    return 0
}

# Function to run SBI in interactive TUI mode
run_interactive_mode() {
    # Function: run_interactive_mode
    # Purpose: Run SBI in interactive Terminal User Interface mode
    # Arguments: None
    # Returns: Exit code indicating success (0) or failure (non-zero)
    
    debug_log "INFO" "Starting interactive TUI mode"
    
    # Check dependencies first
    if ! check_tui_dependencies; then
        debug_log "ERROR" "Dependency check failed for TUI mode"
        return 1
    fi
    
    # Initialize TUI environment
    export DIALOGRC="${XDG_CONFIG_HOME:-$HOME/.config}/sbi/dialogrc"
    
    # Display welcome screen
    dialog --title "SBI - Second Brain Ingest" \
           --msgbox "Welcome to SBI Interactive Mode\n\nUse this interface to manage your second brain knowledge base." 10 60
    
    # Main menu loop
    while true; do
        # Show main menu
        option=$(dialog --clear --title "SBI Main Menu" \
                      --menu "Choose an operation:" 15 60 8 \
                      "1" "Ingest New Content" \
                      "2" "Browse Knowledge Base" \
                      "3" "Search Content" \
                      "4" "Manage Categories" \
                      "5" "Configure Settings" \
                      "6" "Help" \
                      "0" "Exit" \
                      3>&1 1>&2 2>&3)
        
        # Handle exit or cancel
        if [[ $? -ne 0 || "$option" == "0" ]]; then
            clear
            echo "Exiting SBI Interactive Mode."
            return 0
        fi
        
        # Process selected option
        case "$option" in
            1)
                tui_ingest_content
                ;;
            2)
                tui_browse_knowledge_base
                ;;
            3)
                tui_search_content
                ;;
            4)
                tui_manage_categories
                ;;
            5)
                tui_configure_settings
                ;;
            6)
                tui_show_help
                ;;
        esac
    done
}

# Format directory listing for TUI display
list_structure_for_tui() {
    # Function: list_structure_for_tui
    # Purpose: Format directory listing for TUI display
    # Arguments:
    #   $1 - Directory to list
    #   $2 - Output file to write the formatted list
    # Returns: None, writes to the specified output file
    
    local dir="$1"
    local output_file="$2"
    
    # Clear output file
    > "$output_file"
    
    # List directories first, then files
    find "$dir" -mindepth 1 -maxdepth 1 -type d | sort | while read -r item; do
        local name=$(basename "$item")
        echo "\"$name\" \"[DIR] $(ls -1 "$item" | wc -l) items\"" >> "$output_file"
    done
    
    find "$dir" -mindepth 1 -maxdepth 1 -type f | sort | while read -r item; do
        local name=$(basename "$item")
        local filesize=$(du -h "$item" | cut -f1)
        echo "\"$name\" \"[FILE] $filesize\"" >> "$output_file"
    done
}

# Content ingestion interface for TUI
tui_ingest_content() {
    # Function: tui_ingest_content
    # Purpose: Interface for ingesting content in TUI mode
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Opening content ingestion interface"
    
    # Select ingestion method
    method=$(dialog --clear --title "Ingest Content" \
                  --menu "Select ingestion method:" 15 60 5 \
                  "1" "Select Local File" \
                  "2" "Input URL" \
                  "3" "Enter Text Directly" \
                  "4" "Paste from Clipboard" \
                  "0" "Back to Main Menu" \
                  3>&1 1>&2 2>&3)
    
    # Handle back/cancel
    if [[ $? -ne 0 || "$method" == "0" ]]; then
        debug_log "DEBUG" "TUI: User canceled content ingestion"
        return
    fi
    
    # Process based on selected method
    case "$method" in
        1)
            # File selection using file browser
            tui_select_local_file
            ;;
        2)
            # URL input
            tui_input_url
            ;;
        3)
            # Text input
            tui_input_text
            ;;
        4)
            # Clipboard paste
            tui_paste_clipboard
            ;;
    esac
}

# File selection utility for TUI
tui_select_local_file() {
    # Function: tui_select_local_file
    # Purpose: File selection interface for TUI
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Opening file selection interface"
    
    # Create temp file for selected file path
    temp_file=$(mktemp "${HOME}/.tmp/sbi-file-select-XXXXXX")
    
    # Use dialog's file selection
    dialog --title "Select File" --fselect "$HOME/" 14 60 2>"$temp_file"
    
    # Handle cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled file selection"
        rm -f "$temp_file"
        return
    fi
    
    # Get selected file
    selected_file=$(cat "$temp_file")
    rm -f "$temp_file"
    
    # Validate file
    if [[ ! -f "$selected_file" ]]; then
        dialog --title "Error" --msgbox "Invalid file selection: '$selected_file'" 6 60
        debug_log "ERROR" "TUI: Invalid file selection: $selected_file"
        return
    fi
    
    debug_log "INFO" "TUI: Selected file: $selected_file"
    
    # Process the file
    tui_process_ingestion "$selected_file"
}

# URL input utility for TUI
tui_input_url() {
    # Function: tui_input_url
    # Purpose: URL input interface for TUI
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Opening URL input interface"
    
    # Get URL input
    url=$(dialog --clear --title "Enter URL" \
                --inputbox "Enter URL to ingest:" 8 60 "https://" \
                3>&1 1>&2 2>&3)
    
    # Handle cancel
    if [[ $? -ne 0 || -z "$url" ]]; then
        debug_log "DEBUG" "TUI: User canceled URL input"
        return
    fi
    
    # Simple URL validation
    if [[ ! "$url" =~ ^https?:// ]]; then
        dialog --title "Error" --msgbox "Invalid URL format: '$url'\nURL must start with http:// or https://" 8 60
        debug_log "ERROR" "TUI: Invalid URL format: $url"
        return
    fi
    
    debug_log "INFO" "TUI: Input URL: $url"
    
    # Process the URL
    tui_process_ingestion "$url"
}

# Text input utility for TUI
tui_input_text() {
    # Function: tui_input_text
    # Purpose: Text input interface for TUI
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Opening text input interface"
    
    # Create temp file for text input
    temp_text=$(mktemp "${HOME}/.tmp/sbi-text-input-XXXXXX")
    
    # Use dialog's text editor
    dialog --title "Enter Text Content" --editbox "$temp_text" 20 80 2>"$temp_text"
    
    # Handle cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled text input"
        rm -f "$temp_text"
        return
    fi
    
    # Check if file has content
    if [[ ! -s "$temp_text" ]]; then
        dialog --title "Error" --msgbox "No text entered." 6 40
        debug_log "ERROR" "TUI: Empty text input"
        rm -f "$temp_text"
        return
    fi
    
    debug_log "INFO" "TUI: Text input received ($(wc -l < "$temp_text") lines)"
    
    # Process the text file
    tui_process_ingestion "$temp_text" "text"
}

# Clipboard paste utility for TUI
tui_paste_clipboard() {
    # Function: tui_paste_clipboard
    # Purpose: Clipboard paste interface for TUI
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Opening clipboard paste interface"
    
    # Check if we have xclip or wl-paste (for X11 or Wayland)
    if command -v xclip &> /dev/null; then
        clipboard_cmd="xclip -o -selection clipboard"
    elif command -v wl-paste &> /dev/null; then
        clipboard_cmd="wl-paste"
    else
        dialog --title "Error" --msgbox "Clipboard access requires xclip (X11) or wl-paste (Wayland).\nPlease install the appropriate tool for your system." 8 70
        debug_log "ERROR" "TUI: Clipboard access tools not found"
        return
    fi
    
    # Create temp file for clipboard content
    temp_clip=$(mktemp "${HOME}/.tmp/sbi-clipboard-XXXXXX")
    
    # Get clipboard content
    if ! $clipboard_cmd > "$temp_clip" 2>/dev/null; then
        dialog --title "Error" --msgbox "Failed to read clipboard content." 6 50
        debug_log "ERROR" "TUI: Failed to read clipboard"
        rm -f "$temp_clip"
        return
    fi
    
    # Check if clipboard has content
    if [[ ! -s "$temp_clip" ]]; then
        dialog --title "Error" --msgbox "Clipboard is empty." 6 40
        debug_log "ERROR" "TUI: Empty clipboard"
        rm -f "$temp_clip"
        return
    fi
    
    # Show preview and confirm
    local preview=$(head -n 10 "$temp_clip")
    local line_count=$(wc -l < "$temp_clip")
    
    dialog --title "Clipboard Content" --yesno "Preview of clipboard content (first 10 lines):\n\n$preview\n\n... ($line_count lines total)\n\nDo you want to ingest this content?" 20 70
    
    # Handle cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled clipboard ingestion"
        rm -f "$temp_clip"
        return
    fi
    
    debug_log "INFO" "TUI: Clipboard content received ($(wc -l < "$temp_clip") lines)"
    
    # Process the clipboard content
    tui_process_ingestion "$temp_clip" "text"
}

# Knowledge base browsing functionality for TUI
tui_browse_knowledge_base() {
    # Function: tui_browse_knowledge_base
    # Purpose: Browse the knowledge base in TUI mode
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Opening knowledge base browsing interface"
    
    # Create temp file for directory listing
    temp_dir_list=$(mktemp "${HOME}/.tmp/sbi-dir-list-XXXXXX")
    
    # Generate list of PARA categories for selection
    para_options=()
    para_options+=("00_inbox" "Temporary storage for unsorted notes")
    para_options+=("01_projects" "Active projects with defined outcomes")
    para_options+=("02_areas" "Ongoing responsibilities with standards")
    para_options+=("03_resources" "Topics and themes of interest")
    para_options+=("04_archives" "Inactive items from other categories")
    
    # Show PARA category selection
    para_choice=$(dialog --clear --title "Browse Knowledge Base" \
                       --menu "Select PARA category:" 15 60 5 \
                       "${para_options[@]}" \
                       3>&1 1>&2 2>&3)
    
    # Handle back/cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled PARA category selection"
        rm -f "$temp_dir_list"
        return
    fi
    
    debug_log "INFO" "TUI: Selected PARA category: $para_choice"
    
    # Start with the selected PARA directory
    current_dir="${NOTES_DIR}/${para_choice}"
    
    # Browse recursively through directories
    while true; do
        # Get directory listing
        list_structure_for_tui "$current_dir" "$temp_dir_list"
        
        # Get shortened path for display
        display_path="${current_dir#$NOTES_DIR/}"
        
        # Show directory content with options to navigate
        dir_choice=$(dialog --clear --title "Browsing: $display_path" \
                          --menu "Select item or action:" 20 70 15 \
                          ".." "Go Up One Level" \
                          $(cat "$temp_dir_list") \
                          3>&1 1>&2 2>&3)
        
        # Handle back/cancel
        if [[ $? -ne 0 ]]; then
            debug_log "DEBUG" "TUI: User canceled directory browsing"
            break
        fi
        
        debug_log "DEBUG" "TUI: Selected: $dir_choice"
        
        # Process selection
        if [[ "$dir_choice" == ".." ]]; then
            # Go up one level, unless we're already at PARA root
            if [[ "$current_dir" != "${NOTES_DIR}/${para_choice}" ]]; then
                current_dir=$(dirname "$current_dir")
                debug_log "DEBUG" "TUI: Navigating up to $current_dir"
            else
                # At PARA root, go back to PARA selection
                debug_log "DEBUG" "TUI: At PARA root, exiting browser"
                break
            fi
        elif [[ -d "${current_dir}/${dir_choice}" ]]; then
            # Navigate into selected directory
            current_dir="${current_dir}/${dir_choice}"
            debug_log "DEBUG" "TUI: Navigating into directory: $current_dir"
        elif [[ -f "${current_dir}/${dir_choice}" ]]; then
            # Show file options (view, edit, delete, etc.)
            tui_file_actions "${current_dir}/${dir_choice}"
        fi
    done
    
    # Clean up
    rm -f "$temp_dir_list"
}

# File actions for TUI browsing
tui_file_actions() {
    # Function: tui_file_actions
    # Purpose: Show file actions in TUI mode
    # Arguments:
    #   $1 - Path to the file
    # Returns: None
    
    local file_path="$1"
    local file_name=$(basename "$file_path")
    local file_extension="${file_name##*.}"
    
    debug_log "INFO" "TUI: File actions for $file_path"
    
    # Show file action menu
    while true; do
        action=$(dialog --clear --title "File: $file_name" \
                      --menu "Choose an action:" 15 60 7 \
                      "1" "View File" \
                      "2" "Edit File" \
                      "3" "Move/Rename File" \
                      "4" "Delete File" \
                      "5" "File Information" \
                      "0" "Back" \
                      3>&1 1>&2 2>&3)
        
        # Handle back/cancel
        if [[ $? -ne 0 || "$action" == "0" ]]; then
            debug_log "DEBUG" "TUI: User canceled file actions"
            return
        fi
        
        # Process selected action
        case "$action" in
            1)
                # View file
                debug_log "DEBUG" "TUI: Viewing file: $file_path"
                
                # Create temp file for display
                temp_view=$(mktemp "${HOME}/.tmp/sbi-view-XXXXXX")
                
                # Handle different file types differently
                if [[ "$file_extension" == "norg" ]]; then
                    # For norg files, do simple formatting for display (would use a proper neorg->text converter in production)
                    sed 's/^\* /=== /g; s/^\*\* /== /g; s/^\*\*\* /= /g' "$file_path" > "$temp_view"
                    dialog --title "Viewing: $file_name" --textbox "$temp_view" 22 78
                    rm -f "$temp_view"
                else
                    # For other files, use simple display
                    dialog --title "Viewing: $file_name" --textbox "$file_path" 22 78
                fi
                ;;
            2)
                # Edit file
                debug_log "DEBUG" "TUI: Editing file: $file_path"
                clear  # Clear screen for editor
                ${EDITOR:-vi} "$file_path"
                clear  # Clear screen after editor
                ;;
            3)
                # Move/rename file
                tui_move_file "$file_path"
                # If file was moved, we need to exit the file actions
                if [[ $? -eq 0 ]]; then
                    return
                fi
                ;;
            4)
                # Delete file
                debug_log "DEBUG" "TUI: Delete file prompt: $file_path"
                dialog --title "Confirm Delete" --yesno "Are you sure you want to delete '$file_name'?" 6 60
                if [[ $? -eq 0 ]]; then
                    debug_log "INFO" "TUI: Deleting file: $file_path"
                    if rm "$file_path"; then
                        dialog --title "Delete Successful" --msgbox "File '$file_name' has been deleted." 6 60
                        return  # Exit file actions after delete
                    else
                        dialog --title "Delete Failed" --msgbox "Failed to delete '$file_name'." 6 60
                    fi
                fi
                ;;
            5)
                # File information
                debug_log "DEBUG" "TUI: Showing file info: $file_path"
                file_info=$(stat --format="Name: %n\nSize: %s bytes\nModified: %y\nAccess: %a\nOwner: %U" "$file_path")
                dialog --title "File Information" --msgbox "$file_info" 10 60
                ;;
        esac
    done
}

# Category management functionality for TUI
tui_manage_categories() {
    # Function: tui_manage_categories
    # Purpose: Manage knowledge base categories in TUI mode
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Opening category management interface"
    
    while true; do
        # Show category management menu
        option=$(dialog --clear --title "Manage Categories" \
                      --menu "Choose an operation:" 15 60 5 \
                      "1" "View Category Structure" \
                      "2" "Create New Category" \
                      "3" "Move Content Between Categories" \
                      "4" "Generate Category Report" \
                      "0" "Back to Main Menu" \
                      3>&1 1>&2 2>&3)
        
        # Handle back/cancel
        if [[ $? -ne 0 || "$option" == "0" ]]; then
            debug_log "DEBUG" "TUI: User exited category management"
            return
        fi
        
        # Process selected option
        case "$option" in
            1)
                tui_view_category_structure
                ;;
            2)
                tui_create_new_category
                ;;
            3)
                tui_move_content_between_categories
                ;;
            4)
                tui_generate_category_report
                ;;
        esac
    done
}

# View category structure in TUI mode
tui_view_category_structure() {
    # Function: tui_view_category_structure
    # Purpose: View the knowledge base category structure in TUI mode
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Viewing category structure"
    
    # Create temp file for structure output
    temp_structure=$(mktemp "${HOME}/.tmp/sbi-structure-XXXXXX")
    
    # Show progress
    dialog --title "Generating Structure..." --infobox "Generating category structure report..." 3 60
    
    # Generate structure
    echo "Second Brain Knowledge Base Structure\n" > "$temp_structure"
    echo "Location: $NOTES_DIR\n" >> "$temp_structure"
    echo "PARA Categories:\n" >> "$temp_structure"
    
    # Loop through PARA categories
    for para in "${PARA_MAP[@]}"; do
        para_name=${para#*_}  # Remove prefix (00_, 01_, etc.)
        echo "== $para ($para_name) ==" >> "$temp_structure"
        
        # Count items in this category
        file_count=$(find "$NOTES_DIR/$para" -type f -name "*.norg" | wc -l)
        dir_count=$(find "$NOTES_DIR/$para" -mindepth 1 -type d | wc -l)
        
        echo "- Files: $file_count" >> "$temp_structure"
        echo "- Subcategories: $dir_count" >> "$temp_structure"
        echo "" >> "$temp_structure"
        
        # Show top-level subcategories
        if [[ $dir_count -gt 0 ]]; then
            echo "Subcategories:" >> "$temp_structure"
            find "$NOTES_DIR/$para" -mindepth 1 -maxdepth 2 -type d | sort | while read -r subdir; do
                subdir_name=${subdir#$NOTES_DIR/$para/}
                subdir_file_count=$(find "$subdir" -type f -name "*.norg" | wc -l)
                echo "  - $subdir_name ($subdir_file_count files)" >> "$temp_structure"
            done
            echo "" >> "$temp_structure"
        fi
    done
    
    # Show the structure
    dialog --title "Knowledge Base Structure" --textbox "$temp_structure" 22 78
    
    # Clean up
    rm -f "$temp_structure"
}

# Create new category in TUI mode
tui_create_new_category() {
    # Function: tui_create_new_category
    # Purpose: Create a new category in TUI mode
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Creating new category"
    
    # Create temp file for PARA options
    temp_para=$(mktemp "${HOME}/.tmp/sbi-para-create-XXXXXX")
    
    # Generate PARA options
    echo "\"01_projects\" \"Active projects with defined outcomes\"" > "$temp_para"
    echo "\"02_areas\" \"Ongoing responsibilities with standards\"" >> "$temp_para"
    echo "\"03_resources\" \"Topics and themes of interest\"" >> "$temp_para"
    echo "\"04_archives\" \"Inactive items from other categories\"" >> "$temp_para"
    
    # Select PARA category (excluding inbox)
    para_choice=$(dialog --clear --title "Create Category" \
                       --menu "Select PARA category for new subcategory:" 15 60 4 \
                       $(cat "$temp_para") \
                       3>&1 1>&2 2>&3)
    
    # Handle cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled PARA selection for new category"
        rm -f "$temp_para"
        return
    fi
    
    rm -f "$temp_para"
    
    # Get category path
    new_category=$(dialog --clear --title "Create Category" \
                         --inputbox "Enter new category path (e.g., 'personal/projects'):" 8 60 \
                         3>&1 1>&2 2>&3)
    
    # Handle cancel or empty
    if [[ $? -ne 0 || -z "$new_category" ]]; then
        debug_log "DEBUG" "TUI: User canceled or entered empty category path"
        return
    fi
    
    # Create the new category
    new_path="${NOTES_DIR}/${para_choice}/${new_category}"
    
    # Check if it already exists
    if [[ -d "$new_path" ]]; then
        dialog --title "Error" --msgbox "Category already exists: $new_category" 6 60
        debug_log "ERROR" "TUI: Category already exists: $new_path"
        return
    fi
    
    # Create the directory
    debug_log "INFO" "TUI: Creating category: $new_path"
    if mkdir -p "$new_path"; then
        dialog --title "Category Created" --msgbox "Created new category:\n$new_path" 7 60
        
        # Ask if user wants to create README
        dialog --title "Create README" --yesno "Do you want to create a README file in this category?" 6 60
        
        if [[ $? -eq 0 ]]; then
            # Create a README file
            readme_path="${new_path}/README.norg"
            
            {
                echo "* ${para_choice}/${new_category}"
                echo ""
                echo "Created on: $(date +"%Y-%m-%d %H:%M:%S")"
                echo ""
                echo "This directory contains..."
                echo ""
                echo "** Purpose"
                echo ""
                echo "** Contents"
                echo ""
            } > "$readme_path"
            
            debug_log "INFO" "TUI: Created README: $readme_path"
            dialog --title "README Created" --msgbox "Created README file in new category." 6 60
        fi
    else
        dialog --title "Error" --msgbox "Failed to create category: $new_category" 6 60
        debug_log "ERROR" "TUI: Failed to create category: $new_path"
    fi
}

# Move content between categories in TUI mode
tui_move_content_between_categories() {
    # Function: tui_move_content_between_categories
    # Purpose: Move content between categories in TUI mode
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Moving content between categories"
    
    # First select source PARA category
    source_para=$(dialog --clear --title "Move Content" \
                        --menu "Select source PARA category:" 15 60 5 \
                        "00_inbox" "Temporary storage for unsorted notes" \
                        "01_projects" "Active projects with defined outcomes" \
                        "02_areas" "Ongoing responsibilities with standards" \
                        "03_resources" "Topics and themes of interest" \
                        "04_archives" "Inactive items from other categories" \
                        3>&1 1>&2 2>&3)
    
    # Handle cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled source PARA selection"
        return
    fi
    
    # Create temp file for source subcategories
    temp_source=$(mktemp "${HOME}/.tmp/sbi-source-XXXXXX")
    
    # Add root level option
    echo "\"\" \"[Root level] $source_para\"" > "$temp_source"
    
    # List source subcategories
    find "${NOTES_DIR}/${source_para}" -mindepth 1 -type d | sort | while read -r path; do
        rel_path="${path#${NOTES_DIR}/${source_para}/}"
        echo "\"$rel_path\" \"$rel_path\"" >> "$temp_source"
    done
    
    # Select source subcategory
    source_subcat=$(dialog --clear --title "Move Content" \
                          --menu "Select source subcategory:" 20 70 15 \
                          $(cat "$temp_source") \
                          3>&1 1>&2 2>&3)
    
    # Handle cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled source subcategory selection"
        rm -f "$temp_source"
        return
    fi
    
    rm -f "$temp_source"
    
    # Build source path
    local source_path=""
    if [[ -n "$source_subcat" ]]; then
        source_path="${NOTES_DIR}/${source_para}/${source_subcat}"
    else
        source_path="${NOTES_DIR}/${source_para}"
    fi
    
    debug_log "INFO" "TUI: Selected source: $source_path"
    
    # Count files in the source
    file_count=$(find "$source_path" -maxdepth 1 -type f -name "*.norg" | wc -l)
    
    if [[ $file_count -eq 0 ]]; then
        dialog --title "No Files" --msgbox "No .norg files found in selected source." 6 60
        debug_log "INFO" "TUI: No files found in source: $source_path"
        return
    fi
    
    # Now select destination PARA category
    dest_para=$(dialog --clear --title "Move Content" \
                      --menu "Select destination PARA category:" 15 60 5 \
                      "00_inbox" "Temporary storage for unsorted notes" \
                      "01_projects" "Active projects with defined outcomes" \
                      "02_areas" "Ongoing responsibilities with standards" \
                      "03_resources" "Topics and themes of interest" \
                      "04_archives" "Inactive items from other categories" \
                      3>&1 1>&2 2>&3)
    
    # Handle cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled destination PARA selection"
        return
    fi
    
    # Create temp file for destination subcategories
    temp_dest=$(mktemp "${HOME}/.tmp/sbi-dest-XXXXXX")
    
    # Add root level option
    echo "\"\" \"[Root level] $dest_para\"" > "$temp_dest"
    
    # List destination subcategories
    find "${NOTES_DIR}/${dest_para}" -mindepth 1 -type d | sort | while read -r path; do
        rel_path="${path#${NOTES_DIR}/${dest_para}/}"
        echo "\"$rel_path\" \"$rel_path\"" >> "$temp_dest"
    done
    
    # Add create new option
    echo "\"CREATE_NEW\" \"+ Create new subcategory\"" >> "$temp_dest"
    
    # Select destination subcategory
    dest_subcat=$(dialog --clear --title "Move Content" \
                        --menu "Select destination subcategory:" 20 70 15 \
                        $(cat "$temp_dest") \
                        3>&1 1>&2 2>&3)
    
    # Handle cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled destination subcategory selection"
        rm -f "$temp_dest"
        return
    fi
    
    rm -f "$temp_dest"
    
    # Handle create new subcategory
    if [[ "$dest_subcat" == "CREATE_NEW" ]]; then
        new_subcat=$(dialog --clear --title "Create New Subcategory" \
                          --inputbox "Enter new subcategory path:" 8 60 \
                          3>&1 1>&2 2>&3)
        
        # Handle cancel or empty
        if [[ $? -ne 0 ]]; then
            debug_log "DEBUG" "TUI: User canceled new subcategory input"
            return
        fi
        
        # Use the new subcategory
        dest_subcat="$new_subcat"
        
        # Create the directory if it doesn't exist
        if [[ -n "$dest_subcat" ]]; then
            mkdir -p "${NOTES_DIR}/${dest_para}/${dest_subcat}"
            debug_log "INFO" "TUI: Created new subcategory: ${NOTES_DIR}/${dest_para}/${dest_subcat}"
        fi
    fi
    
    # Build destination path
    local dest_path=""
    if [[ -n "$dest_subcat" ]]; then
        dest_path="${NOTES_DIR}/${dest_para}/${dest_subcat}"
    else
        dest_path="${NOTES_DIR}/${dest_para}"
    fi
    
    debug_log "INFO" "TUI: Selected destination: $dest_path"
    
    # Create the destination directory if it doesn't exist
    if [[ ! -d "$dest_path" ]]; then
        mkdir -p "$dest_path"
        debug_log "DEBUG" "TUI: Created destination directory: $dest_path"
    fi
    
    # Show confirmation
    dialog --title "Confirm Move" \
          --yesno "Move $file_count files from:\n$source_path\n\nTo:\n$dest_path\n\nAre you sure?" 10 70
    
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled content move operation"
        return
    fi
    
    # Create temp file for move log
    temp_log=$(mktemp "${HOME}/.tmp/sbi-move-log-XXXXXX")
    
    # Perform the move operation
    debug_log "INFO" "TUI: Starting content move operation"
    
    # Show progress
    dialog --title "Moving Files..." --infobox "Moving $file_count files..." 3 40
    
    # Find and move files
    find "$source_path" -maxdepth 1 -type f -name "*.norg" | while read -r file; do
        filename=$(basename "$file")
        dest_file="$dest_path/$filename"
        
        # Check if destination file already exists
        if [[ -f "$dest_file" ]]; then
            # Create a unique filename
            dest_file="${dest_path}/$(date +%Y%m%d%H%M%S)-${filename}"
        fi
        
        # Move the file
        if mv "$file" "$dest_file"; then
            echo "Moved: $filename" >> "$temp_log"
            debug_log "DEBUG" "TUI: Moved file: $file -> $dest_file"
        else
            echo "Failed to move: $filename" >> "$temp_log"
            debug_log "ERROR" "TUI: Failed to move file: $file -> $dest_file"
        fi
    done
    
    # Show results
    dialog --title "Move Results" --textbox "$temp_log" 20 70
    
    # Clean up
    rm -f "$temp_log"
}

# Settings configuration interface for TUI
tui_configure_settings() {
    # Function: tui_configure_settings
    # Purpose: Configure settings in TUI mode
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Opening settings configuration interface"
    
    # Create config directory if it doesn't exist
    config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/sbi"
    mkdir -p "$config_dir"
    config_file="${config_dir}/config"
    
    # Load current settings or set defaults
    if [[ -f "$config_file" ]]; then
        debug_log "DEBUG" "TUI: Loading existing config from $config_file"
        source "$config_file"
    else
        debug_log "DEBUG" "TUI: No existing config found, using defaults"
    fi
    
    # Set default values if not already set
    CUSTOM_NOTES_DIR="${CUSTOM_NOTES_DIR:-$NOTES_DIR}"
    DEFAULT_PARA_CATEGORY="${DEFAULT_PARA_CATEGORY:-00_inbox}"
    EDITOR_CMD="${EDITOR_CMD:-${EDITOR:-vi}}"
    THEME="${THEME:-default}"
    DEBUG_LOG_PATH="${DEBUG_LOG_PATH:-}"
    
    # Show settings menu
    while true; do
        # Update current settings display
        current_settings=$(cat << EOF
Current Settings:
----------------
Notes Directory:      ${CUSTOM_NOTES_DIR}
Default PARA Category: ${DEFAULT_PARA_CATEGORY}
Editor Command:       ${EDITOR_CMD}
TUI Theme:            ${THEME}
Debug Log Path:       ${DEBUG_LOG_PATH:-[None]}
EOF
)
        
        # Show settings menu with current values
        option=$(dialog --clear --title "Configure Settings" \
                      --menu "$current_settings\n\nChoose a setting to modify:" 20 70 7 \
                      "1" "Notes Directory" \
                      "2" "Default PARA Category" \
                      "3" "Editor Command" \
                      "4" "TUI Theme" \
                      "5" "Debug Log Path" \
                      "6" "Save Settings" \
                      "0" "Back without Saving" \
                      3>&1 1>&2 2>&3)
        
        # Handle back/cancel
        if [[ $? -ne 0 || "$option" == "0" ]]; then
            debug_log "DEBUG" "TUI: User exited settings without saving"
            return
        fi
        
        # Process selected option
        case "$option" in
            1)
                # Change notes directory
                new_dir=$(dialog --clear --title "Notes Directory" \
                              --inputbox "Enter path to notes directory:" 8 60 "$CUSTOM_NOTES_DIR" \
                              3>&1 1>&2 2>&3)
                
                # Handle cancel
                if [[ $? -eq 0 && -n "$new_dir" ]]; then
                    # Verify directory exists or can be created
                    if [[ ! -d "$new_dir" ]]; then
                        dialog --title "Directory Not Found" --yesno "Directory doesn't exist:\n$new_dir\n\nCreate it?" 8 60
                        if [[ $? -eq 0 ]]; then
                            mkdir -p "$new_dir"
                            if [[ $? -ne 0 ]]; then
                                dialog --title "Error" --msgbox "Failed to create directory:\n$new_dir" 7 60
                                continue
                            fi
                        else
                            continue
                        fi
                    fi
                    
                    # Update setting
                    CUSTOM_NOTES_DIR="$new_dir"
                    debug_log "DEBUG" "TUI: Updated notes directory to: $CUSTOM_NOTES_DIR"
                fi
                ;;
            2)
                # Change default PARA category
                new_para=$(dialog --clear --title "Default PARA Category" \
                                --menu "Select default PARA category:" 15 60 5 \
                                "00_inbox" "Temporary storage for unsorted notes" \
                                "01_projects" "Active projects with defined outcomes" \
                                "02_areas" "Ongoing responsibilities with standards" \
                                "03_resources" "Topics and themes of interest" \
                                "04_archives" "Inactive items from other categories" \
                                3>&1 1>&2 2>&3)
                
                # Handle cancel
                if [[ $? -eq 0 && -n "$new_para" ]]; then
                    DEFAULT_PARA_CATEGORY="$new_para"
                    debug_log "DEBUG" "TUI: Updated default PARA category to: $DEFAULT_PARA_CATEGORY"
                fi
                ;;
            3)
                # Change editor command
                new_editor=$(dialog --clear --title "Editor Command" \
                                 --inputbox "Enter editor command:" 8 60 "$EDITOR_CMD" \
                                 3>&1 1>&2 2>&3)
                
                # Handle cancel
                if [[ $? -eq 0 && -n "$new_editor" ]]; then
                    # Try to verify the editor command is valid
                    if ! command -v $(echo "$new_editor" | cut -d' ' -f1) &> /dev/null; then
                        dialog --title "Warning" --yesno "Editor command '$(echo "$new_editor" | cut -d' ' -f1)' not found.\nUse anyway?" 8 60
                        if [[ $? -ne 0 ]]; then
                            continue
                        fi
                    fi
                    
                    EDITOR_CMD="$new_editor"
                    debug_log "DEBUG" "TUI: Updated editor command to: $EDITOR_CMD"
                fi
                ;;
            4)
                # Change TUI theme
                new_theme=$(dialog --clear --title "TUI Theme" \
                                --menu "Select theme:" 15 60 5 \
                                "default" "Default theme" \
                                "dark" "Dark theme" \
                                "light" "Light theme" \
                                "custom" "Custom theme" \
                                3>&1 1>&2 2>&3)
                
                # Handle cancel
                if [[ $? -eq 0 && -n "$new_theme" ]]; then
                    THEME="$new_theme"
                    debug_log "DEBUG" "TUI: Updated theme to: $THEME"
                    
                    # Handle custom theme
                    if [[ "$new_theme" == "custom" ]]; then
                        # We would need to implement theme customization here
                        # For now, just show a placeholder
                        dialog --title "Custom Theme" --msgbox "Custom theme support is not fully implemented yet.\nCustom theme configuration will be stored in:\n${config_dir}/dialogrc" 8 70
                    else
                        # Apply theme immediately
                        case "$new_theme" in
                            dark)
                                export DIALOGRC="${config_dir}/dialog-dark"
                                {
                                    echo "screen_color = (BLACK,BLACK,ON)"
                                    echo "dialog_color = (WHITE,BLACK,OFF)"
                                    echo "title_color = (GREEN,BLACK,ON)"
                                    echo "border_color = (WHITE,BLACK,ON)"
                                    echo "button_active_color = (WHITE,BLUE,ON)"
                                    echo "button_inactive_color = (WHITE,BLACK,OFF)"
                                    echo "button_key_active_color = (WHITE,BLUE,ON)"
                                    echo "button_key_inactive_color = (RED,BLACK,OFF)"
                                    echo "button_label_active_color = (YELLOW,BLUE,ON)"
                                    echo "button_label_inactive_color = (BLACK,WHITE,ON)"
                                    echo "inputbox_color = (BLACK,WHITE,OFF)"
                                    echo "inputbox_border_color = (BLACK,WHITE,OFF)"
                                    echo "searchbox_color = (BLACK,WHITE,OFF)"
                                    echo "searchbox_title_color = (BLUE,WHITE,ON)"
                                    echo "searchbox_border_color = (WHITE,WHITE,ON)"
                                    echo "position_indicator_color = (BLUE,WHITE,ON)"
                                    echo "menubox_color = (BLACK,BLACK,OFF)"
                                    echo "menubox_border_color = (WHITE,BLACK,ON)"
                                    echo "item_color = (WHITE,BLACK,OFF)"
                                    echo "item_selected_color = (WHITE,BLUE,ON)"
                                    echo "tag_color = (YELLOW,BLACK,ON)"
                                    echo "tag_selected_color = (YELLOW,BLUE,ON)"
                                    echo "tag_key_color = (RED,BLACK,OFF)"
                                    echo "tag_key_selected_color = (RED,BLUE,ON)"
                                    echo "check_color = (BLACK,WHITE,OFF)"
                                    echo "check_selected_color = (WHITE,BLUE,ON)"
                                    echo "uarrow_color = (GREEN,BLACK,ON)"
                                    echo "darrow_color = (GREEN,BLACK,ON)"
                                } > "${config_dir}/dialog-dark"
                                ;;
                            light)
                                export DIALOGRC="${config_dir}/dialog-light"
                                {
                                    echo "screen_color = (WHITE,WHITE,ON)"
                                    echo "dialog_color = (BLACK,WHITE,OFF)"
                                    echo "title_color = (BLUE,WHITE,ON)"
                                    echo "border_color = (BLACK,WHITE,ON)"
                                    echo "button_active_color = (WHITE,BLUE,ON)"
                                    echo "button_inactive_color = (BLACK,WHITE,OFF)"
                                    echo "button_key_active_color = (WHITE,BLUE,ON)"
                                    echo "button_key_inactive_color = (RED,WHITE,OFF)"
                                    echo "button_label_active_color = (YELLOW,BLUE,ON)"
                                    echo "button_label_inactive_color = (BLACK,WHITE,ON)"
                                    echo "inputbox_color = (BLACK,WHITE,OFF)"
                                    echo "inputbox_border_color = (BLACK,WHITE,OFF)"
                                    echo "searchbox_color = (BLACK,WHITE,OFF)"
                                    echo "searchbox_title_color = (BLUE,WHITE,ON)"
                                    echo "searchbox_border_color = (BLACK,WHITE,ON)"
                                    echo "position_indicator_color = (BLUE,WHITE,ON)"
                                    echo "menubox_color = (BLACK,WHITE,OFF)"
                                    echo "menubox_border_color = (BLACK,WHITE,ON)"
                                    echo "item_color = (BLACK,WHITE,OFF)"
                                    echo "item_selected_color = (WHITE,BLUE,ON)"
                                    echo "tag_color = (BLUE,WHITE,ON)"
                                    echo "tag_selected_color = (YELLOW,BLUE,ON)"
                                    echo "tag_key_color = (RED,WHITE,OFF)"
                                    echo "tag_key_selected_color = (RED,BLUE,ON)"
                                    echo "check_color = (BLACK,WHITE,OFF)"
                                    echo "check_selected_color = (WHITE,BLUE,ON)"
                                    echo "uarrow_color = (GREEN,WHITE,ON)"
                                    echo "darrow_color = (GREEN,WHITE,ON)"
                                } > "${config_dir}/dialog-light"
                                ;;
                            default|*)
                                export DIALOGRC=""
                                ;;
                        esac
                    fi
                fi
                ;;
            5)
                # Change debug log path
                new_log_path=$(dialog --clear --title "Debug Log Path" \
                                  --inputbox "Enter debug log file path (leave empty for none):" 8 70 "${DEBUG_LOG_PATH:-}" \
                                  3>&1 1>&2 2>&3)
                
                # Handle cancel
                if [[ $? -eq 0 ]]; then
                    # If path is not empty, verify parent directory exists
                    if [[ -n "$new_log_path" ]]; then
                        log_dir=$(dirname "$new_log_path")
                        if [[ ! -d "$log_dir" ]]; then
                            dialog --title "Directory Not Found" --yesno "Log directory doesn't exist:\n$log_dir\n\nCreate it?" 8 60
                            if [[ $? -eq 0 ]]; then
                                mkdir -p "$log_dir"
                                if [[ $? -ne 0 ]]; then
                                    dialog --title "Error" --msgbox "Failed to create directory:\n$log_dir" 7 60
                                    continue
                                fi
                            else
                                continue
                            fi
                        fi
                        
                        # Test if we can write to the file
                        if ! touch "$new_log_path" 2>/dev/null; then
                            dialog --title "Error" --msgbox "Cannot write to log file:\n$new_log_path" 7 60
                            continue
                        fi
                    fi
                    
                    DEBUG_LOG_PATH="$new_log_path"
                    debug_log "DEBUG" "TUI: Updated debug log path to: ${DEBUG_LOG_PATH:-[None]}"
                fi
                ;;
            6)
                # Save settings
                debug_log "INFO" "TUI: Saving settings to $config_file"
                {
                    echo "# SBI Configuration"
                    echo "# Generated on: $(date)"
                    echo "CUSTOM_NOTES_DIR=\"$CUSTOM_NOTES_DIR\""
                    echo "DEFAULT_PARA_CATEGORY=\"$DEFAULT_PARA_CATEGORY\""
                    echo "EDITOR_CMD=\"$EDITOR_CMD\""
                    echo "THEME=\"$THEME\""
                    echo "DEBUG_LOG_PATH=\"$DEBUG_LOG_PATH\""
                } > "$config_file"
                
                dialog --title "Settings Saved" --msgbox "Settings have been saved to:\n$config_file" 7 60
                
                # Apply settings immediately
                NOTES_DIR="$CUSTOM_NOTES_DIR"
                DEFAULT_PARA="$DEFAULT_PARA_CATEGORY"
                
                # Set debug log file if specified
                if [[ -n "$DEBUG_LOG_PATH" ]]; then
                    DEBUG_LOG_FILE="$DEBUG_LOG_PATH"
                    debug_log "INFO" "Debug logging to file: $DEBUG_LOG_FILE"
                fi
                
                return 0
                ;;
        esac
    done
}

# Generate category report in TUI mode
tui_generate_category_report() {
    # Function: tui_generate_category_report
    # Purpose: Generate a report about categories in TUI mode
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Generating category report"
    
    # Create temp file for report
    temp_report=$(mktemp "${HOME}/.tmp/sbi-report-XXXXXX")
    
    # Show progress
    dialog --title "Generating Report..." --infobox "Generating comprehensive category report..." 3 60
    
    # Generate report header
    {
        echo "# KNOWLEDGE BASE CATEGORY REPORT"
        echo ""
        echo "Generated on: $(date +"%Y-%m-%d %H:%M:%S")"
        echo "Base location: $NOTES_DIR"
        echo ""
        echo "## SUMMARY"
        echo ""
        
        # Count total files and categories
        total_files=$(find "$NOTES_DIR" -type f -name "*.norg" | wc -l)
        total_categories=$(find "$NOTES_DIR" -mindepth 2 -type d | wc -l)
        
        echo "Total .norg files: $total_files"
        echo "Total categories: $total_categories"
        echo ""
        
        # Add PARA breakdown
        echo "## PARA BREAKDOWN"
        echo ""
        echo "| Category | Files | Subcategories | Last Updated |"
        echo "|----------|-------|---------------|--------------|"
    } > "$temp_report"
    
    # Loop through PARA categories for breakdown
    for para in "${PARA_MAP[@]}"; do
        para_path="$NOTES_DIR/$para"
        
        # Get stats
        files=$(find "$para_path" -type f -name "*.norg" | wc -l)
        subcats=$(find "$para_path" -mindepth 1 -type d | wc -l)
        
        # Get latest file timestamp
        latest_file=$(find "$para_path" -type f -name "*.norg" -printf "%T@ %p\n" 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
        
        if [[ -n "$latest_file" ]]; then
            latest_date=$(stat -c %y "$latest_file" | cut -d' ' -f1)
        else
            latest_date="N/A"
        fi
        
        # Add to report
        echo "| $para | $files | $subcats | $latest_date |" >> "$temp_report"
    done
    
    # Add detailed breakdown for each PARA category
    for para in "${PARA_MAP[@]}"; do
        para_path="$NOTES_DIR/$para"
        para_name=${para#*_}  # Remove prefix (00_, 01_, etc.)
        
        echo "" >> "$temp_report"
        echo "## $para_name (${para})" >> "$temp_report"
        echo "" >> "$temp_report"
        
        # Find subcategories
        subcats=$(find "$para_path" -mindepth 1 -type d | sort)
        
        if [[ -z "$subcats" ]]; then
            echo "No subcategories found." >> "$temp_report"
        else
            echo "| Subcategory | Files |" >> "$temp_report"
            echo "|-------------|-------|" >> "$temp_report"
            
            echo "$subcats" | while read -r subcat; do
                subcat_name=${subcat#$para_path/}
                files=$(find "$subcat" -type f -name "*.norg" | wc -l)
                echo "| $subcat_name | $files |" >> "$temp_report"
            done
        fi
        
        # Add count of files at root level
        root_files=$(find "$para_path" -maxdepth 1 -type f -name "*.norg" | wc -l)
        echo "" >> "$temp_report"
        echo "Files at root level: $root_files" >> "$temp_report"
    done
    
    # Show the report
    dialog --title "Knowledge Base Category Report" --textbox "$temp_report" 22 78
    
    # Ask if user wants to save the report
    dialog --title "Save Report" --yesno "Do you want to save this report to a file?" 6 60
    
    if [[ $? -eq 0 ]]; then
        # Get filename for report
        report_name=$(dialog --clear --title "Save Report" \
                           --inputbox "Enter filename (will be saved in reports directory):" 8 60 \
                           "category-report-$(date +"%Y-%m-%d").md" \
                           3>&1 1>&2 2>&3)
        
        # Handle cancel or empty
        if [[ $? -ne 0 || -z "$report_name" ]]; then
            debug_log "DEBUG" "TUI: User canceled report saving"
            rm -f "$temp_report"
            return
        fi
        
        # Create reports directory if it doesn't exist
        reports_dir="${NOTES_DIR}/reports"
        mkdir -p "$reports_dir"
        
        # Save the report
        cp "$temp_report" "${reports_dir}/${report_name}"
        
        dialog --title "Report Saved" --msgbox "Report saved to:\n${reports_dir}/${report_name}" 7 60
    fi
    
    # Clean up
    rm -f "$temp_report"
}

# Search functionality for TUI
tui_search_content() {
    # Function: tui_search_content
    # Purpose: Search for content within the knowledge base
    # Arguments: None
    # Returns: None
    
    debug_log "INFO" "TUI: Opening search interface"
    
    # Get search query
    search_term=$(dialog --clear --title "Search Content" \
                       --inputbox "Enter search term:" 8 60 \
                       3>&1 1>&2 2>&3)
    
    # Handle cancel
    if [[ $? -ne 0 || -z "$search_term" ]]; then
        debug_log "DEBUG" "TUI: User canceled search or entered empty term"
        return
    fi
    
    debug_log "INFO" "TUI: Searching for term: $search_term"
    
    # Create temp file for search results
    temp_results=$(mktemp "${HOME}/.tmp/sbi-search-XXXXXX")
    
    # Show progress while searching
    dialog --title "Searching..." --infobox "Searching for '$search_term'..." 3 50
    
    # Perform search (grep through all .norg files)
    {
        find "$NOTES_DIR" -type f -name "*.norg" -exec grep -l "$search_term" {} \; < /dev/null | sort > "$temp_results"
    } 2>/dev/null
    
    # Count results
    result_count=$(wc -l < "$temp_results")
    debug_log "INFO" "TUI: Search found $result_count results"
    
    if [[ "$result_count" -eq 0 ]]; then
        # No results found
        dialog --title "Search Results" --msgbox "No results found for '$search_term'." 6 50
        rm -f "$temp_results"
        return
    fi
    
    # Format results for display
    temp_formatted=$(mktemp "${HOME}/.tmp/sbi-search-fmt-XXXXXX")
    
    # Format search results for dialog menu
    while read -r file_path; do
        # Get relative path from notes dir
        rel_path="${file_path#$NOTES_DIR/}"
        
        # Get first line of the file as title (strip leading * if it's a Neorg header)
        title=$(head -1 "$file_path" | sed 's/^\* //')
        
        # Add formatted entry to menu
        echo "\"$rel_path\" \"$title\"" >> "$temp_formatted"
    done < "$temp_results"
    
    # Show results
    while true; do
        selected_file=$(dialog --clear --title "Search Results: $result_count found" \
                           --menu "Select a file to view:" 20 70 15 \
                           "." "Return to Main Menu" \
                           $(cat "$temp_formatted") \
                           3>&1 1>&2 2>&3)
        
        # Handle cancel or main menu
        if [[ $? -ne 0 || "$selected_file" == "." ]]; then
            debug_log "DEBUG" "TUI: User canceled search results selection"
            break
        fi
        
        debug_log "INFO" "TUI: Selected search result: $selected_file"
        
        # Show options for the selected file
        action=$(dialog --clear --title "Found: $selected_file" \
                       --menu "Choose an action:" 12 70 4 \
                       "1" "View File" \
                       "2" "View File with Search Context" \
                       "3" "Edit File" \
                       "0" "Back to Results" \
                       3>&1 1>&2 2>&3)
        
        # Handle cancel
        if [[ $? -ne 0 || "$action" == "0" ]]; then
            debug_log "DEBUG" "TUI: User canceled file action selection"
            continue
        fi
        
        # Full path to the file
        file_path="${NOTES_DIR}/${selected_file}"
        
        case "$action" in
            1)
                # View file
                debug_log "DEBUG" "TUI: Viewing search result file: $file_path"
                dialog --title "Viewing: $selected_file" --textbox "$file_path" 22 78
                ;;
            2)
                # View with search context
                debug_log "DEBUG" "TUI: Viewing search result with context: $file_path"
                
                # Create temp file with grep results
                temp_grep=$(mktemp "${HOME}/.tmp/sbi-grep-XXXXXX")
                
                # Get file content with highlighted search term (5 lines of context)
                grep -n -A 5 -B 5 "$search_term" "$file_path" > "$temp_grep"
                
                # Add a header to show what we're displaying
                {
                    echo "Showing occurrences of '$search_term' in $selected_file with context:"
                    echo "--------------------------------------------------------------------------"
                    echo ""
                    cat "$temp_grep"
                } > "${temp_grep}.display"
                
                # Display the results
                dialog --title "Search Context: $selected_file" --textbox "${temp_grep}.display" 22 78
                
                # Clean up
                rm -f "$temp_grep" "${temp_grep}.display"
                ;;
            3)
                # Edit file
                debug_log "DEBUG" "TUI: Editing search result file: $file_path"
                clear  # Clear screen for editor
                ${EDITOR:-vi} "$file_path"
                clear  # Clear screen after editor
                ;;
        esac
    done
    
    # Clean up
    rm -f "$temp_results" "$temp_formatted"
}

# Move/rename file in TUI mode
tui_move_file() {
    # Function: tui_move_file
    # Purpose: Move or rename a file in TUI mode
    # Arguments:
    #   $1 - Path to the file to move/rename
    # Returns: 0 if successful, 1 otherwise
    
    local file_path="$1"
    local file_name=$(basename "$file_path")
    local current_dir=$(dirname "$file_path")
    
    debug_log "INFO" "TUI: Move/rename file: $file_path"
    
    # Ask for operation type
    local op_type=$(dialog --clear --title "Move/Rename File" \
                         --menu "Choose operation:" 10 60 2 \
                         "1" "Rename file (stay in same directory)" \
                         "2" "Move to different PARA category/directory" \
                         3>&1 1>&2 2>&3)
    
    # Handle cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled move/rename operation"
        return 1
    fi
    
    case "$op_type" in
        1)
            # Rename file
            debug_log "DEBUG" "TUI: Rename file operation"
            
            # Ask for new filename
            local new_name=$(dialog --clear --title "Rename File" \
                                  --inputbox "Enter new filename:" 8 60 "$file_name" \
                                  3>&1 1>&2 2>&3)
            
            # Handle cancel or empty
            if [[ $? -ne 0 || -z "$new_name" ]]; then
                debug_log "DEBUG" "TUI: User canceled filename input"
                return 1
            fi
            
            # Create new path
            local new_path="${current_dir}/${new_name}"
            
            # Check if destination already exists
            if [[ -e "$new_path" && "$new_path" != "$file_path" ]]; then
                dialog --title "Error" --msgbox "File '$new_name' already exists in this directory." 6 60
                debug_log "ERROR" "TUI: Rename destination already exists: $new_path"
                return 1
            fi
            
            # Perform the rename
            debug_log "INFO" "TUI: Renaming $file_path to $new_path"
            if mv "$file_path" "$new_path"; then
                dialog --title "Rename Successful" --msgbox "File renamed to '$new_name'." 6 60
                return 0  # Success
            else
                dialog --title "Rename Failed" --msgbox "Failed to rename file." 6 60
                debug_log "ERROR" "TUI: Failed to rename file"
                return 1
            fi
            ;;
        2)
            # Move to different directory
            debug_log "DEBUG" "TUI: Move to different directory operation"
            
            # Create temp file for PARA selection
            local temp_para=$(mktemp "${HOME}/.tmp/sbi-para-XXXXXX")
            
            # Generate PARA options
            echo "\"00_inbox\" \"Temporary storage for unsorted notes\"" > "$temp_para"
            echo "\"01_projects\" \"Active projects with defined outcomes\"" >> "$temp_para"
            echo "\"02_areas\" \"Ongoing responsibilities with standards\"" >> "$temp_para"
            echo "\"03_resources\" \"Topics and themes of interest\"" >> "$temp_para"
            echo "\"04_archives\" \"Inactive items from other categories\"" >> "$temp_para"
            
            # Select PARA category
            local para_choice=$(dialog --clear --title "Select Destination Category" \
                                     --menu "Move file to which PARA category?" 15 60 5 \
                                     $(cat "$temp_para") \
                                     3>&1 1>&2 2>&3)
            
            # Handle cancel
            if [[ $? -ne 0 ]]; then
                debug_log "DEBUG" "TUI: User canceled PARA selection"
                rm -f "$temp_para"
                return 1
            fi
            
            rm -f "$temp_para"
            
            # Handle subcategory selection if not in inbox
            local subcategory=""
            if [[ "$para_choice" != "00_inbox" ]]; then
                # Create temp file for subcategories
                local temp_subcat=$(mktemp "${HOME}/.tmp/sbi-subcat-XXXXXX")
                
                # Add root level option
                echo "\"\" \"[Root level] No subcategory\"" > "$temp_subcat"
                
                # Find existing subcategories
                find "${NOTES_DIR}/${para_choice}" -mindepth 1 -maxdepth 3 -type d | sort | while read -r subdir; do
                    local rel_path="${subdir#${NOTES_DIR}/${para_choice}/}"
                    echo "\"$rel_path\" \"$rel_path\"" >> "$temp_subcat"
                done
                
                # Add option to create new subcategory
                echo "\"CREATE_NEW\" \"+ Create new subcategory\"" >> "$temp_subcat"
                
                # Select subcategory
                subcategory=$(dialog --clear --title "Select Destination Subcategory" \
                                   --menu "Move file to which subcategory?" 20 70 15 \
                                   $(cat "$temp_subcat") \
                                   3>&1 1>&2 2>&3)
                
                # Handle cancel
                if [[ $? -ne 0 ]]; then
                    debug_log "DEBUG" "TUI: User canceled subcategory selection"
                    rm -f "$temp_subcat"
                    return 1
                fi
                
                rm -f "$temp_subcat"
                
                # Handle create new subcategory
                if [[ "$subcategory" == "CREATE_NEW" ]]; then
                    subcategory=$(dialog --clear --title "Create New Subcategory" \
                                       --inputbox "Enter new subcategory path:" 8 60 \
                                       3>&1 1>&2 2>&3)
                    
                    # Handle cancel or empty
                    if [[ $? -ne 0 ]]; then
                        debug_log "DEBUG" "TUI: User canceled new subcategory input"
                        return 1
                    fi
                    
                    # Create new directory
                    if [[ -n "$subcategory" ]]; then
                        mkdir -p "${NOTES_DIR}/${para_choice}/${subcategory}"
                        debug_log "INFO" "TUI: Created new subcategory: ${NOTES_DIR}/${para_choice}/${subcategory}"
                    fi
                fi
            fi
            
            # Build destination path
            local dest_dir=""
            if [[ -n "$subcategory" ]]; then
                dest_dir="${NOTES_DIR}/${para_choice}/${subcategory}"
            else
                dest_dir="${NOTES_DIR}/${para_choice}"
            fi
            
            local dest_path="${dest_dir}/${file_name}"
            
            debug_log "INFO" "TUI: Move destination: $dest_path"
            
            # Check if destination already exists
            if [[ -e "$dest_path" ]]; then
                dialog --title "Error" --msgbox "File '$file_name' already exists in the destination directory." 6 70
                debug_log "ERROR" "TUI: Move destination already exists: $dest_path"
                return 1
            fi
            
            # Perform the move
            debug_log "INFO" "TUI: Moving $file_path to $dest_path"
            if mv "$file_path" "$dest_path"; then
                dialog --title "Move Successful" --msgbox "File moved to:\n$dest_path" 7 60
                return 0  # Success
            else
                dialog --title "Move Failed" --msgbox "Failed to move file." 6 60
                debug_log "ERROR" "TUI: Failed to move file"
                return 1
            fi
            ;;
    esac
    
    return 1  # Default failure
}

# Process the ingestion in TUI mode
tui_process_ingestion() {
    # Function: tui_process_ingestion
    # Purpose: Process the content ingestion in TUI mode
    # Arguments:
    #   $1 - Input file or URL
    #   $2 - Input type (optional, default: "file")
    # Returns: None
    
    local input="$1"
    local input_type="${2:-file}"  # Default to file type
    local temp_dir=$(mktemp -d "${HOME}/.tmp/sbi-tui-ingest-XXXXXX")
    
    debug_log "INFO" "TUI: Processing ingestion - input: $input, type: $input_type"
    
    # Show PARA category selection
    para_choice=$(dialog --clear --title "Select PARA Category" \
                        --menu "Where should this content be stored?" 15 60 6 \
                        "00_inbox" "Temporary storage for unsorted notes" \
                        "01_projects" "Active projects with defined outcomes" \
                        "02_areas" "Ongoing responsibilities with standards" \
                        "03_resources" "Topics and themes of interest" \
                        "04_archives" "Inactive items from other categories" \
                        "detect" "Auto-detect based on content" \
                        3>&1 1>&2 2>&3)
    
    # Handle cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled PARA selection"
        rm -rf "$temp_dir"
        return
    fi
    
    debug_log "INFO" "TUI: Selected PARA category: $para_choice"
    
    # Determine target PARA directory
    local TARGET_PARA=""
    
    # If auto-detect, perform detection
    if [[ "$para_choice" == "detect" ]]; then
        dialog --title "Detecting Category" --infobox "Analyzing content to detect appropriate category..." 3 60
        
        # This is a simplified detection - in a real implementation,
        # you would use the existing auto-detection functionality
        local content_preview=""
        
        case "$input_type" in
            text)
                content_preview=$(head -n 20 "$input")
                ;;
            *)
                if [[ -f "$input" ]]; then
                    content_preview=$(head -n 20 "$input")
                fi
                ;;
        esac
        
        # Simple keyword-based detection logic (placeholder)
        if [[ "$content_preview" =~ project|plan|timeline ]]; then
            TARGET_PARA="01_projects"
        elif [[ "$content_preview" =~ health|finance|career ]]; then
            TARGET_PARA="02_areas"
        elif [[ "$content_preview" =~ reference|topic|learn ]]; then
            TARGET_PARA="03_resources"
        elif [[ "$content_preview" =~ archive|complete|old ]]; then
            TARGET_PARA="04_archives"
        else
            TARGET_PARA="00_inbox"
        fi
        
        debug_log "INFO" "TUI: Auto-detected PARA category: $TARGET_PARA"
        dialog --title "Category Detected" --msgbox "Content will be stored in: $TARGET_PARA" 6 60
    else
        TARGET_PARA="$para_choice"
    fi
    
    # Ask for subcategory if not inbox
    local subcategory=""
    if [[ "$TARGET_PARA" != "00_inbox" ]]; then
        # First get base directory structure
        local temp_cats=$(mktemp "${HOME}/.tmp/sbi-categories-XXXXXX")
        
        # List subdirectories
        find "${NOTES_DIR}/${TARGET_PARA}" -mindepth 1 -maxdepth 2 -type d | sort | while read -r path; do
            local rel_path="${path#${NOTES_DIR}/${TARGET_PARA}/}"
            echo "\"$rel_path\" \"$(basename "$rel_path")\"" >> "$temp_cats"
        done
        
        # Check if we have subcategories
        if [[ -s "$temp_cats" ]]; then
            # Ask user to select subcategory or create new
            subcategory=$(dialog --clear --title "Select Subcategory" \
                                --menu "Choose subcategory or create new:" 15 60 10 \
                                "." "No subcategory (root level)" \
                                "+" "Create new subcategory" \
                                $(cat "$temp_cats") \
                                3>&1 1>&2 2>&3)
            
            # Handle cancel
            if [[ $? -ne 0 ]]; then
                debug_log "DEBUG" "TUI: User canceled subcategory selection"
                rm -f "$temp_cats"
                rm -rf "$temp_dir"
                return
            fi
            
            # Handle new subcategory creation
            if [[ "$subcategory" == "+" ]]; then
                new_subcat=$(dialog --clear --title "Create Subcategory" \
                                  --inputbox "Enter new subcategory path\n(can use paths like personal/projects):" 8 60 \
                                  3>&1 1>&2 2>&3)
                
                # Handle cancel or empty
                if [[ $? -ne 0 || -z "$new_subcat" ]]; then
                    subcategory="."  # Use root level
                else
                    subcategory="$new_subcat"
                    debug_log "INFO" "TUI: Creating new subcategory: $subcategory"
                    
                    # Create the directory
                    mkdir -p "${NOTES_DIR}/${TARGET_PARA}/${subcategory}"
                fi
            fi
            
            # Handle root level
            if [[ "$subcategory" == "." ]]; then
                subcategory=""
            fi
        fi
        
        rm -f "$temp_cats"
    fi
    
    debug_log "INFO" "TUI: Selected subcategory: ${subcategory:-none}"
    
    # Build target directory path
    local TARGET_DIR=""
    if [[ -n "$subcategory" ]]; then
        TARGET_DIR="${NOTES_DIR}/${TARGET_PARA}/${subcategory}"
    else
        TARGET_DIR="${NOTES_DIR}/${TARGET_PARA}"
    fi
    
    debug_log "INFO" "TUI: Target directory: $TARGET_DIR"
    
    # Create target directory if it doesn't exist
    if [[ ! -d "$TARGET_DIR" ]]; then
        mkdir -p "$TARGET_DIR"
        debug_log "DEBUG" "TUI: Created target directory: $TARGET_DIR"
    fi
    
    # Ask for filename (default based on input)
    local default_name=""
    if [[ "$input_type" == "text" ]]; then
        default_name="note-$(date +"%Y-%m-%d-%H%M%S")"
    elif [[ "$input" =~ ^https?:// ]]; then
        # For URLs, use domain name as part of the default name
        local domain=$(echo "$input" | sed -e 's/^https\?:\/\///' -e 's/\/.*$//')
        default_name="$domain-$(date +"%Y-%m-%d")"
    else
        # For files, use the basename without extension
        default_name=$(basename "${input%.*}")
    fi
    
    # Clean up filename (remove special characters)
    default_name=$(echo "$default_name" | tr ' ' '_' | tr -d '[:punct:]' | tr -cd '[:alnum:]_-')
    
    # Get custom filename
    filename=$(dialog --clear --title "Set Filename" \
                     --inputbox "Enter filename for the ingested content:\n(without extension, will use .norg)" 8 60 "$default_name" \
                     3>&1 1>&2 2>&3)
    
    # Handle cancel
    if [[ $? -ne 0 ]]; then
        debug_log "DEBUG" "TUI: User canceled filename input"
        rm -rf "$temp_dir"
        return
    fi
    
    # Clean up filename
    filename=$(echo "$filename" | tr ' ' '_' | tr -cd '[:alnum:]_-')
    
    if [[ -z "$filename" ]]; then
        filename="note-$(date +"%Y%m%d%H%M%S")"
        debug_log "DEBUG" "TUI: Empty filename, using default: $filename"
    fi
    
    # Set target filename with extension based on output format
    local file_ext=".md"
    if [[ "$NEORG_MODE" == true ]]; then
        file_ext=".norg"
        debug_log "DEBUG" "Using .norg extension due to --neorg flag"
    fi
    local TARGET_FILE="${TARGET_DIR}/${filename}${file_ext}"
    debug_log "INFO" "TUI: Target file: $TARGET_FILE"
    
    # Check if file already exists
    if [[ -f "$TARGET_FILE" ]]; then
        dialog --title "File Exists" --yesno "File already exists:\n$TARGET_FILE\n\nDo you want to append to it?" 8 70
        
        if [[ $? -ne 0 ]]; then
            # If user doesn't want to append, ask for a new filename
            filename="${filename}-$(date +"%Y%m%d%H%M%S")"
            TARGET_FILE="${TARGET_DIR}/${filename}${file_ext}"
            debug_log "DEBUG" "TUI: File exists, using new name: $filename"
        else
            debug_log "DEBUG" "TUI: File exists, appending to it"
        fi
    fi
    
    # Process the input based on its type
    dialog --title "Processing Content" --infobox "Processing content, please wait..." 3 60
    
    local success=false
    
    if [[ "$input_type" == "text" ]]; then
        # For text input, format as a simple note
        {
            echo "* $filename"
            echo ""
            echo "Created on: $(date +"%Y-%m-%d %H:%M:%S")"
            echo ""
            cat "$input"
        # Determine output extension and format content accordingly
        local output_ext=".md"
        local content_file="$temp_dir/content.md"
        if [[ "$NEORG_MODE" == true ]]; then
            output_ext=".norg"
            content_file="$temp_dir/content.norg"
        fi
        } > "$content_file"
        
        # Check if we need to append
        if [[ -f "$TARGET_FILE" ]]; then
            if [[ "$NEORG_MODE" == true ]]; then
                echo -e "\n* Appended on $(date +"%Y-%m-%d %H:%M:%S")\n" >> "$TARGET_FILE"
            else
                echo -e "\n## Appended on $(date +"%Y-%m-%d %H:%M:%S")\n" >> "$TARGET_FILE"
            fi
            cat "$content_file" >> "$TARGET_FILE"
            echo -e "\n" >> "$TARGET_FILE"
        else
            cp "$content_file" >> "$TARGET_FILE"
            echo -e "\n" >> "$TARGET_FILE"
        fi
        
        success=true
        
    elif [[ "$input" =~ ^https?:// ]]; then
        # For URLs, show a placeholder message 
        # In a real implementation, this would use the existing URL processing code
        dialog --title "URL Processing" --msgbox "URL processing would be handled by existing SBI functionality.\n\nIn this TUI example, we're creating a placeholder note for the URL: $input" 8 70
        
        {
            echo "* $filename"
            echo ""
            echo "Created on: $(date +"%Y-%m-%d %H:%M:%S")"
            echo ""
            echo "URL: $input"
            echo ""
            echo "This is a placeholder for URL content."
            echo "In a complete implementation, this would contain the processed content from the URL."
        } > "$TARGET_FILE"
        
        success=true
        
    else
        # For files, show a placeholder message
        # In a real implementation, this would use existing file processing logic
        dialog --title "File Processing" --msgbox "File processing would be handled by existing SBI functionality.\n\nIn this TUI example, we're creating a placeholder note for the file: $input" 8 70
        
        {
            echo "* $filename"
            echo ""
            echo "Created on: $(date +"%Y-%m-%d %H:%M:%S")"
            echo ""
            echo "Source file: $input"
            echo ""
            echo "This is a placeholder for file content."
            echo "In a complete implementation, this would contain the processed content from the file."
        } > "$TARGET_FILE"
        
        success=true
    fi
    
    # Show result
    if [[ "$success" == true ]]; then
        dialog --title "Processing Complete" --msgbox "Content has been successfully processed and saved to:\n\n$TARGET_FILE" 8 70
        debug_log "INFO" "TUI: Successfully created: $TARGET_FILE"
    else
        dialog --title "Processing Failed" --msgbox "Failed to process the content." 6 50
        debug_log "ERROR" "TUI: Failed to process content for $TARGET_FILE"
    fi
    
    # Clean up
    rm -rf "$temp_dir"
    
    # Remove original temp input file if it exists and it's a temp file
    if [[ "$input_type" == "text" && "$input" =~ /.tmp/sbi- ]]; then
        rm -f "$input"
        debug_log "DEBUG" "TUI: Removed temporary input file: $input"
    fi
}

# Show help in TUI mode
tui_show_help() {
    # Function: tui_show_help
    # Purpose: Display help information in TUI mode
    # Arguments: None
    # Returns: None
    
    local help_text="
SECOND BRAIN INGEST (SBI) - INTERACTIVE MODE HELP

SBI is a utility for ingesting various content types into a second brain 
knowledge management system organized using the PARA methodology (Projects, 
Areas, Resources, Archives).

NAVIGATION:
- Use arrow keys to move between options
- Press Enter to select an option
- Press Esc or Cancel to go back to the previous screen

MAIN MENU OPTIONS:

1. Ingest New Content
   - Add files, URLs, or text to your knowledge base
   - Supports various content types (text, audio, video, web, etc.)
   - Choose PARA category or let SBI detect it
   - Crawl entire websites to capture comprehensive knowledge
   - Process site exports (SingleFile, ZIP, TAR)

2. Browse Knowledge Base
   - Navigate through your PARA structure
   - View, edit, move, or delete files
   - See content previews

3. Search Content
   - Search for specific terms across your knowledge base
   - Results shown with context
   - Jump directly to matching files

4. Manage Categories
   - View the complete category structure
   - Create new categories
   - Move content between categories
   - Generate reports on category usage

5. Configure Settings
   - Set default locations and preferences
   - Configure editor options
   - Customize TUI appearance
   - Set web crawling parameters

PARA ORGANIZATION:
- 00_inbox: Temporary storage for unsorted notes
- 01_projects: Active projects with defined outcomes
- 02_areas: Ongoing responsibilities with standards
- 03_resources: Topics and themes of interest
- 04_archives: Inactive items from other categories

WEB CRAWLING:
- Crawl entire websites with customizable depth
- Domain restriction to prevent unintended external crawling
- Polite crawling with rate limiting and robots.txt compliance
- Processing of complete site exports
- Automatic organization of content into your knowledge base

KEYBOARD SHORTCUTS:
- Tab: Move between elements
- Space: Select/deselect items in checklists
- Enter: Confirm selection
- Esc: Cancel/back
"
    
    dialog --title "SBI Help" --msgbox "$help_text" 30 76
}

show_help() {
    cat << EOF
Usage: sbi [OPTIONS] FILE1 [FILE2 ...]

Ingest files into second brain with PARA organization.

Options:
  -h, --help              Show this help message
  -i, --interactive       Enter interactive TUI mode for navigating and managing content
  -p, --para CATEGORY     Specify PARA category (inbox, project, area, resource, archive, detect)
  -c, --category PATH     Specify subcategory path (e.g., "personal" or "technical/linux")
  -b, --branch NAME       Use git worktree branch (updates NOTES_DIR to ~/Documents/notes/trees/NAME)
  -l, --list              List the second brain directory structure
  -L, --list-files        List the second brain directory structure including files
  -f, --full-path         Show full paths in directory listings
  -n, --no-summary        Skip AI summary generation, directly output content as Markdown
  -s, --sanitize          Sanitize sensitive data in content before processing
  --neorg                 Output in Neorg format instead of Markdown format
  --type TYPE             Specify summary type (meeting, book, general, custom)
  --prompt PROMPT         Specify custom prompt or append to built-in prompt
  --principle             Focus on principles rather than literal values in summary
  --provider PROVIDER     Specify AI provider (perpy, claudpy, grokpy, geminpy, ollampy, openpy)
  --model MODEL           Specify model to use with the selected provider
  --tags TAGS             CSV list of tags to apply to the content (e.g., "work,project,urgent")
  --format FORMAT         Specify format for stdin content (e.g., "txt", "md", "json")
  -e, --edit              Edit content before writing to file
  --name-seed NAME        Use NAME as seed for filename (for stdin content)
  --debug                 Enable debug logging with timestamps and log levels
  --silent                Suppress progress output (all non-error messages)

Web Crawling Options:
  --crawl                 Enable web crawling mode for websites
  --crawl-archive         Save complete website archive (not just summary)
  --export                Process a site export file (SingleFile, ZIP, TAR)
  --depth NUM             Specify crawl depth (default: 1, use 0 for infinite)
  --no-domain-restrict    Follow links to external domains during crawl
  --wait SECONDS          Set wait time between requests (default: 1 second)
  --include PATTERN       Only include URLs matching the pattern
  --exclude PATTERN       Exclude URLs matching the pattern
  --user-agent STRING     Use custom user agent for crawling

Examples:
  sbi document.md                          # Ingest to inbox
  sbi --para project document.md           # Ingest to projects
  sbi --para resource --category technical/linux document.md  # Ingest to specific path
  sbi --para detect document.md            # Auto-detect PARA category
  sbi --branch feature-xyz document.md     # Ingest to git worktree branch at ~/Documents/notes/trees/feature-xyz
  sbi --list                               # List directory structure
  echo "* My neorg content" | sbi          # Pipe neorg content directly
  cat data.json | sbi --format json        # Pipe content with specified format
  echo "Draft note" | sbi --edit           # Open editor to modify before saving
  echo "Meeting notes" | sbi --name-seed "team meeting" # Use custom filename
  sbi recording.mp3                        # Transcribe audio and create summary
  sbi meeting.mp4                          # Extract audio, transcribe, and summarize
  sbi https://youtu.be/dQw4w9WgXcQ        # Download YouTube audio, transcribe, and summarize
  sbi https://example.com/article          # Download web page, summarize, and save as Markdown
  sbi document.pdf                         # Convert PDF, generate summary, and save as Markdown
  sbi book.epub                            # Convert ebook, generate summary, and save as Markdown
  sbi document.docx                        # Convert Office document, generate summary, and save as Markdown
  sbi presentation.pptx                    # Convert presentation, generate summary, and save as Markdown
  sbi --type meeting meeting.mp3          # Transcribe audio and use meeting-specific summarization
  sbi --type book --prompt "Focus on key lessons" book.epub   # Convert book with custom prompt
  sbi --principle article.md              # Summarize article with focus on principles
  sbi --provider claudpy document.md      # Use Claude AI for summarization
  sbi --provider grokpy --model grok-3-beta document.md  # Use Grok AI with specific model
  sbi --no-summary document.md             # Convert markdown directly without generating AI summary
  sbi --sanitize document.md              # Sanitize sensitive data before generating summary
  sbi --neorg document.md                  # Generate summary in Neorg format instead of Markdown
  sbi --debug document.md                  # Ingest with debug logging enabled
  sbi --interactive                        # Launch interactive TUI mode for browsing and managing content
  
Web Crawling Examples:
  sbi --crawl https://example.com          # Crawl website and create summary (depth 1, same domain only)
  sbi --crawl --crawl-archive https://example.com # Crawl website and save complete archive
  sbi --crawl --depth 2 https://example.com # Crawl with depth 2
  sbi --crawl --no-domain-restrict https://example.com # Crawl and follow external links
  sbi --crawl --wait 3 https://example.com # Crawl with 3 seconds between requests
  sbi --crawl --include "*.html" https://example.com # Only crawl HTML files
  sbi --crawl --exclude "*/assets/*" https://example.com # Skip asset directories
  sbi --export site-export.html            # Process a SingleFile HTML export
  sbi --export --crawl-archive site-export.zip # Process and save complete ZIP export
EOF
    exit 0
}

list_structure() {
    # Function: list_structure
    # Purpose: Display the directory structure of the Second Brain
    # Arguments:
    #   $1 - Optional PARA category filter (inbox, project, area, resource, archive)
    #   $2 - Optional subcategory path filter
    #   $3 - Optional boolean to include files in listing (true/false)
    #   $4 - Optional boolean to show full paths (true/false)
    # Returns: Prints directory structure to stdout and exits
    
    local filter_para=""       # PARA category to filter by
    local filter_category=""   # Subcategory path to filter by
    local include_files=false  # Whether to include files in the listing
    local show_full_path=false # Whether to show full paths instead of relative paths
    
    # Parse arguments for filtering
    if [[ $# -ge 1 ]]; then
        filter_para="$1"  # First arg is PARA category
    fi
    
    if [[ $# -ge 2 ]]; then
        filter_category="$2"  # Second arg is subcategory path
    fi
    
    if [[ $# -ge 3 && "$3" == "true" ]]; then
        include_files=true  # Third arg controls file inclusion
    fi
    
    if [[ $# -ge 4 && "$4" == "true" ]]; then
        show_full_path=true  # Fourth arg controls path format
    fi
    
    # Check for required utilities
    if ! command -v find &> /dev/null || ! command -v sort &> /dev/null; then
        handle_error "$ERROR_TYPE_DEPENDENCY" "Required tools 'find' and 'sort' not found" "$EXIT_DEPENDENCY_ERROR"
    fi
    
    echo "Second Brain Structure at: $NOTES_DIR"
    
    # Make sure NOTES_DIR exists
    if [[ ! -d "$NOTES_DIR" ]]; then
        handle_error "$ERROR_TYPE_FILE" "Notes directory '$NOTES_DIR' does not exist" "$EXIT_FILE_NOT_FOUND"
    fi
    
    # Map PARA type to folder name
    local target_para=""
    if [[ -n "$filter_para" ]]; then
        case "$filter_para" in
            inbox)
                target_para="00_inbox"
                ;;
            project)
                target_para="01_projects"
                ;;
            area)
                target_para="02_areas"
                ;;
            resource)
                target_para="03_resources"
                ;;
            archive)
                target_para="04_archives"
                ;;
            *)
                handle_error "$ERROR_TYPE_INPUT" "Invalid PARA type. Must be one of: inbox, project, area, resource, archive" "$EXIT_USAGE_ERROR"
                ;;
        esac
        
        # Check if the PARA directory exists
        if [[ ! -d "$NOTES_DIR/$target_para" ]]; then
            handle_error "$ERROR_TYPE_FILE" "PARA directory '$target_para' does not exist" "$EXIT_FILE_NOT_FOUND"
        fi
        
        # If category is specified, check if that path exists
        if [[ -n "$filter_category" ]]; then
            local category_path="$NOTES_DIR/$target_para/$filter_category"
            if [[ ! -d "$category_path" ]]; then
                handle_error "$ERROR_TYPE_FILE" "Category path '$filter_category' does not exist under '$target_para'" "$EXIT_FILE_NOT_FOUND"
            fi
            
            # Print filtered directory structure with category
            echo "Directory structure for $target_para/$filter_category:"
            
            # List all directories under the specified category
            if [[ "$show_full_path" == true ]]; then
                echo "$target_para/$filter_category/"
            fi
            
            # Start with base indentation level based on category depth
            local base_depth=$(echo "$filter_category" | tr -cd '/' | wc -c)
            
            # Find type based on whether to include files
            local find_type="-type d"
            if [[ "$include_files" == true ]]; then
                find_type=""  # No type filter to include both files and directories
            fi
            
            # List directories and optionally files under the specified category
            find "$category_path" $find_type -print | sort | while read -r path; do
                # Skip the category directory itself
                if [[ "$path" == "$category_path" ]]; then
                    continue
                fi
                
                # Get relative path from category directory
                rel_path="${path#$category_path/}"
                
                # Skip empty entries
                if [[ -z "$rel_path" ]]; then
                    continue
                fi
                
                # Calculate directory depth for indentation (relative to category)
                depth=$(echo "$rel_path" | tr -cd '/' | wc -c)
                indent=$(printf '%*s' "$((depth*2))" '')
                
                # Determine what to display based on full path option
                if [[ "$show_full_path" == true ]]; then
                    # Show the full path from the notes directory
                    display_path="${path#$NOTES_DIR/}"
                    
                    if [[ -d "$path" ]]; then
                        echo "${display_path}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${display_path}"
                    fi
                else
                    # Show just the item name with indentation
                    item_name=$(basename "$path")
                    
                    if [[ -d "$path" ]]; then
                        echo "${indent}${item_name}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${indent}${item_name}"
                    fi
                fi
            done
        else
            # Print filtered directory structure for PARA only
            echo "Directory structure for $target_para:"
            
            # List PARA directory itself when using full path
            if [[ "$show_full_path" == true ]]; then
                echo "$target_para/"
            fi
            
            # Find type based on whether to include files
            local find_type="-type d"
            if [[ "$include_files" == true ]]; then
                find_type=""  # No type filter to include both files and directories
            fi
            
            # List directories and optionally files under the specified PARA
            find "$NOTES_DIR/$target_para" -mindepth 1 $find_type -print | sort | while read -r path; do
                # Get relative path from PARA directory
                rel_path="${path#$NOTES_DIR/$target_para/}"
                
                # Skip empty entries
                if [[ -z "$rel_path" ]]; then
                    continue
                fi
                
                # Calculate directory depth for indentation
                depth=$(echo "$rel_path" | tr -cd '/' | wc -c)
                indent=$(printf '%*s' "$((depth*2))" '')
                
                # Determine what to display based on full path option
                if [[ "$show_full_path" == true ]]; then
                    # Show the full path from the notes directory
                    display_path="${path#$NOTES_DIR/}"
                    
                    if [[ -d "$path" ]]; then
                        echo "${display_path}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${display_path}"
                    fi
                else
                    # Show just the item name with indentation
                    item_name=$(basename "$path")
                    
                    if [[ -d "$path" ]]; then
                        echo "${indent}${item_name}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${indent}${item_name}"
                    fi
                fi
            done
        fi
    else
        # Show full directory structure (all PARA folders)
        echo "Directory structure:"
        
        # List all PARA directories
        for para in 00_inbox 01_projects 02_areas 03_resources 04_archives; do
            para_dir="$NOTES_DIR/$para"
            
            # Skip if the directory doesn't exist
            if [[ ! -d "$para_dir" ]]; then
                continue
            fi
            
            # Print the top-level PARA folder, optionally with full path
            if [[ "$show_full_path" == true ]]; then
                echo "$para/"
            else
                echo "$para"
            fi
            
            # Find type based on whether to include files
            local find_type="-type d"
            if [[ "$include_files" == true ]]; then
                find_type=""  # No type filter to include both files and directories
            fi
            
            # List directories and optionally files with proper indentation
            find "$para_dir" -mindepth 1 $find_type -print | sort | while read -r path; do
                # Get relative path from PARA directory
                rel_path="${path#$para_dir/}"
                
                # Skip empty entries
                if [[ -z "$rel_path" ]]; then
                    continue
                fi
                
                # Calculate directory depth for indentation
                depth=$(echo "$rel_path" | tr -cd '/' | wc -c)
                indent=$(printf '%*s' "$((depth*2 + 2))" '')
                
                # Determine what to display based on full path option
                if [[ "$show_full_path" == true ]]; then
                    # Show the full path from the notes directory
                    display_path="${path#$NOTES_DIR/}"
                    
                    if [[ -d "$path" ]]; then
                        echo "${display_path}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${display_path}"
                    fi
                else
                    # Show just the item name with indentation
                    item_name=$(basename "$path")
                    
                    if [[ -d "$path" ]]; then
                        echo "${indent}${item_name}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${indent}${item_name}"
                    fi
                fi
            done
        done
    fi
    
    exit 0
}

detect_para_category() {
    # Function: detect_para_category
    # Purpose: Use AI to detect the appropriate PARA category for content
    # Arguments:
    #   $1 - The file to analyze
    # Returns: Prints the detected category (inbox, project, area, resource, archive)
    #          and returns 0 if successful
    
    local file="$1"
    local content
    
    # Check if perpy exists (AI tool for text analysis)
    if ! command -v perpy &> /dev/null; then
        handle_error "$ERROR_TYPE_DEPENDENCY" "'perpy' script not found for AI category detection. Defaulting to inbox" "" "WARNING"
        echo "inbox"
        return
    fi
    
    # Read the file content
    content=$(cat "$file")
    
    # Create a prompt for perpy to determine the PARA category
    # We're asking for a single-word response from the defined PARA categories
    # This helps ensure consistent categorization
    local category
    local query="Please analyze this content and determine which PARA category it belongs to. Respond with EXACTLY ONE WORD from these options: project, area, resource, archive. DO NOT include any explanation.\n\n${content}"

    # Send query to perpy and handle response
    # - Remove newlines
    # - Convert to lowercase
    # - Trim whitespace
    category=$(perpy <<< "${query}" | tr -d '\n' | tr '[:upper:]' '[:lower:]' | xargs)
    
    # Validate and clean response to ensure it's one of our expected categories
    # Use pattern matching to handle partial matches or extra text
    case "$category" in
        *project*)
            echo "project"  # Active projects with defined outcomes
            ;;
        *area*)
            echo "area"     # Ongoing responsibilities with standards
            ;;
        *resource*)
            echo "resource" # Topics and themes of interest
            ;;
        *archive*)
            echo "archive"  # Inactive items from other categories
            ;;
        *)
            echo "inbox"    # Default to inbox if we can't determine category
            ;;
    esac
}

# Function to edit content using vipe or direct editor if edit flag is set
edit_with_vipe() {
    # Function: edit_with_vipe
    # Purpose: Edit file content with vipe or fallback to direct editor
    # Arguments:
    #   $1 - Input file path
    #   $2 - Output file path
    # Returns: None, modifies output_file with edited content
    
    local input_file="$1"   # Source file to read
    local output_file="$2"  # Destination file to write
    
    if [[ "$EDIT_FLAG" == true ]]; then
        # Only attempt editing if edit flag is set
        
        # Check if vipe is installed (moreutils package)
        if ! command -v vipe &> /dev/null; then
            echo "Warning: 'vipe' utility not found. Skipping edit phase."
            cp "$input_file" "$output_file"
            return
        fi
        
        # Use vipe to edit the content in the pipeline
        # vipe allows editing content within a pipe using $EDITOR
        # If vipe fails, fall back to direct editor
        if ! cat "$input_file" | vipe > "$output_file" 2>/dev/null; then
            echo "Warning: vipe failed. Falling back to direct editor."
            # Fall back to using the default editor directly on the input file
            EDIT_TMP="$input_file"
            ${EDITOR:-vi} "$EDIT_TMP"  # Use $EDITOR if set, otherwise default to vi
            cp "$EDIT_TMP" "$output_file"
        fi
    else
        # No edit requested, just copy the file without modification
        cp "$input_file" "$output_file"
    fi
}

convert_to_neorg() {
    # Function: convert_to_neorg
    # Purpose: Convert various file formats to Neorg format
    # Arguments:
    #   $1 - Input file path
    #   $2 - Output file path
    # Returns: 0 on success, non-zero on failure
    
    local input_file="$1"    # Source file to convert
    local output_file="$2"   # Destination file for neorg content
    local file_ext="${input_file##*.}"  # File extension to determine format
    local temp_output        # Temporary file for conversion
    local temp_sanitized     # Temporary file for sanitized content
    
    # Special case for stdin with format already specified or any stdin in edit mode
    # We've already handled this content appropriately earlier
    if [[ "$STDIN_MODE" == true && "$input_file" == "$TEMP_FILE" ]]; then
        # Just copy the content as-is - we've already handled editing in the stdin processing 
        # and/or formatted it as a code block
        cp "$input_file" "$output_file"
        return 0
    fi
    
    # Handle HTML files with conversion to Markdown (or to Neorg via Markdown if in neorg mode)
    if [[ "$file_ext" == "html" || "$file_ext" == "htm" || "$file_ext" == "HTML" || "$file_ext" == "HTM" ]]; then
        # Check if markitdown is available (preferred) or fall back to pandoc
        if command -v markitdown &> /dev/null; then
            debug_log "INFO" "Converting HTML using markitdown"
            
            # Create temporary files for intermediate steps
            temp_markdown=$(mktemp "${HOME}/.tmp/sbi-html-md-XXXXXX")
            
            # Convert HTML to Markdown using markitdown
            if markitdown "$input_file" > "$temp_markdown" 2>/dev/null; then
                debug_log "DEBUG" "Successfully converted HTML to Markdown"
                
                # If not in neorg mode, just use the markdown directly
                if [[ "$NEORG_MODE" != true ]]; then
                    debug_log "INFO" "Using markdown directly (default behavior)"
                    
                    # Apply sanitization if requested
                    if [[ "$SANITIZE_MODE" == true ]]; then
                        debug_log "INFO" "Sanitizing markdown content using sanitize_data"
                        cat "$temp_markdown" | sanitize_data > "$output_file"
                    else
                        cp "$temp_markdown" "$output_file"
                    fi
                    
                    # Edit if requested
                    if [[ "$EDIT_FLAG" == true ]]; then
                        ${EDITOR:-vi} "$output_file"
                    fi
                    
                    # Clean up temporary files
                    rm -f "$temp_markdown"
                    return 0
                    
                # Otherwise, convert to Neorg via mton
                elif command -v mton &> /dev/null; then
                    debug_log "INFO" "Converting Markdown to Neorg using mton"
                    temp_output=$(mktemp "${HOME}/.tmp/sbi-convert-XXXXXX")
                    
                    # Read the markdown content and pass it to mton for Neorg conversion
                    local content
                    
                    # If sanitize mode is enabled, sanitize the content
                    if [[ "$SANITIZE_MODE" == true ]]; then
                        debug_log "INFO" "Sanitizing content during conversion using sanitize_data"
                        content=$(cat "$temp_markdown" | sanitize_data)
                    else
                        content=$(cat "$temp_markdown")
                    fi
                    
                    # Convert Markdown to Neorg
                    if mton <<< "${content}" > "$temp_output"; then
                        debug_log "DEBUG" "Successfully converted Markdown to Neorg"
                        
                        # Edit the converted content if requested
                        if [[ "$EDIT_FLAG" == true ]]; then
                            edit_with_vipe "$temp_output" "$output_file"
                        else
                            cp "$temp_output" "$output_file"
                        fi
                        
                        # Clean up temporary files
                        rm -f "$temp_markdown" "$temp_output"
                        return 0
                    else
                        debug_log "ERROR" "Failed to convert Markdown to Neorg with mton"
                        echo "Warning: Failed to convert Markdown to Neorg. Falling back to code block."
                    fi
                    
                    # Clean up on failure
                    rm -f "$temp_output"
                else
                    debug_log "WARNING" "mton not available for Neorg conversion"
                    echo "Warning: 'mton' not found for Neorg conversion. Falling back to code block."
                fi
            else
                debug_log "ERROR" "Failed to convert HTML to Markdown with markitdown"
                echo "Warning: Failed to convert HTML to Markdown with markitdown. Falling back to code block."
            fi
            
            # Clean up temporary files on failure
            rm -f "$temp_markdown"
        
        # Fallback to pandoc if markitdown is not available
        elif command -v pandoc &> /dev/null; then
            debug_log "INFO" "markitdown not available, using pandoc as fallback"
            
            # Create temporary files for intermediate steps
            temp_markdown=$(mktemp "${HOME}/.tmp/sbi-html-md-XXXXXX")
            
            # Convert HTML to Markdown using pandoc with improved options
            if pandoc -f html -t gfm --wrap=none --strip-comments "$input_file" -o "$temp_markdown" 2>/dev/null; then
                debug_log "DEBUG" "Successfully converted HTML to Markdown using pandoc (GFM format)"
                
                # Post-process the markdown to clean up any remaining HTML artifacts
                sed -i 's/<span[^>]*>//g; s/<\/span>//g; s/<div[^>]*>//g; s/<\/div>//g' "$temp_markdown" 2>/dev/null
                debug_log "DEBUG" "Cleaned up HTML artifacts from converted markdown"
                
                # If not in neorg mode, just use the markdown directly
                if [[ "$NEORG_MODE" != true ]]; then
                    debug_log "INFO" "Using markdown directly (default behavior)"
                    
                    # Apply sanitization if requested
                    if [[ "$SANITIZE_MODE" == true ]]; then
                        debug_log "INFO" "Sanitizing markdown content using sanitize_data"
                        cat "$temp_markdown" | sanitize_data > "$output_file"
                    else
                        cp "$temp_markdown" "$output_file"
                    fi
                    
                    # Edit if requested
                    if [[ "$EDIT_FLAG" == true ]]; then
                        ${EDITOR:-vi} "$output_file"
                    fi
                    
                    # Clean up temporary files
                    rm -f "$temp_markdown"
                    return 0
                    
                # Otherwise, convert to Neorg via mton
                elif command -v mton &> /dev/null; then
                    debug_log "INFO" "Converting Markdown to Neorg using mton"
                    temp_output=$(mktemp "${HOME}/.tmp/sbi-convert-XXXXXX")
                    
                    # Read the markdown content and pass it to mton for Neorg conversion
                    local content
                    
                    # If sanitize mode is enabled, sanitize the content
                    if [[ "$SANITIZE_MODE" == true ]]; then
                        debug_log "INFO" "Sanitizing content during conversion using sanitize_data"
                        content=$(cat "$temp_markdown" | sanitize_data)
                    else
                        content=$(cat "$temp_markdown")
                    fi
                    
                    # Convert Markdown to Neorg
                    if mton <<< "${content}" > "$temp_output"; then
                        debug_log "DEBUG" "Successfully converted Markdown to Neorg"
                        
                        # Edit the converted content if requested
                        if [[ "$EDIT_FLAG" == true ]]; then
                            edit_with_vipe "$temp_output" "$output_file"
                        else
                            cp "$temp_output" "$output_file"
                        fi
                        
                        # Clean up temporary files
                        rm -f "$temp_markdown" "$temp_output"
                        return 0
                    else
                        debug_log "ERROR" "Failed to convert Markdown to Neorg with mton"
                        echo "Warning: Failed to convert Markdown to Neorg. Falling back to code block."
                    fi
                    
                    # Clean up on failure
                    rm -f "$temp_output"
                else
                    debug_log "WARNING" "mton not available for Neorg conversion"
                    echo "Warning: 'mton' not found for Neorg conversion. Falling back to code block."
                fi
            else
                debug_log "ERROR" "Failed to convert HTML to Markdown with pandoc"
                echo "Warning: Failed to convert HTML to Markdown with pandoc. Falling back to code block."
            fi
            
            # Clean up temporary files on failure
            rm -f "$temp_markdown"
        else
            debug_log "WARNING" "Neither markitdown nor pandoc available for HTML conversion"
            echo "Warning: Neither 'markitdown' nor 'pandoc' found for HTML conversion. Falling back to code block."
        fi
    fi

    # Handle Markdown files with special conversion
    if [[ "$file_ext" == "md" || "$file_ext" == "markdown" || "$file_ext" == "MD" ]]; then
        # Check if mton (Markdown to Neorg converter) exists
        if command -v mton &> /dev/null; then
            # Create temp file for intermediate result
            temp_output=$(mktemp "${HOME}/.tmp/sbi-convert-XXXXXX")
            
            # Read the content and pass it to mton for conversion
            local content
            
            # If sanitize mode is enabled, sanitize the content
            if [[ "$SANITIZE_MODE" == true ]]; then
                debug_log "INFO" "Sanitizing content during conversion using sanitize_data"
                content=$(cat "$input_file" | sanitize_data)
            else
                content=$(cat "$input_file")
            fi
            
            mton <<< "${content}" > "$temp_output"
            
            # Edit the converted content if requested
            if [[ "$EDIT_FLAG" == true ]]; then
                edit_with_vipe "$temp_output" "$output_file"
            else
                cp "$temp_output" "$output_file"
            fi
            
            # Clean up temporary files
            rm -f "$temp_output"
            return 0
        else
            echo "Warning: 'mton' script not found for Markdown conversion. Falling back to code block."
        fi
    fi
    
    # For all other formats (or if mton fails), put content in a Neorg code block
    # This preserves the original format while still making it Neorg-compatible
    temp_output=$(mktemp "${HOME}/.tmp/sbi-convert-XXXXXX")
    
    # Check if sanitize mode is enabled
    if [[ "$SANITIZE_MODE" == true ]]; then
        debug_log "INFO" "Sanitizing content in code block using sanitize_data"
        {
            echo "@code $file_ext"  # Start Neorg code block with file extension as language
            cat "$input_file" | sanitize_data  # Include the sanitized file content
            echo "@end"             # End Neorg code block
        } > "$temp_output"
    else
        {
            echo "@code $file_ext"  # Start Neorg code block with file extension as language
            cat "$input_file"       # Include the file content
            echo "@end"             # End Neorg code block
        } > "$temp_output"
    fi
    
    # Edit if requested
    if [[ "$EDIT_FLAG" == true ]]; then
        edit_with_vipe "$temp_output" "$output_file"
    else
        cp "$temp_output" "$output_file"
    fi
    
    # Clean up temporary files
    rm -f "$temp_output"
    return 0  # Indicate successful conversion
}

is_neorg_file() {
    # Function: is_neorg_file
    # Purpose: Determine if a file is already in Neorg format
    # Arguments:
    #   $1 - File path to check
    # Returns: 0 if the file is Neorg, 1 otherwise
    
    local file="$1"
    local file_ext="${file##*.}"
    
    # Check if it's a .norg file by extension
    if [[ "$file_ext" == "norg" ]]; then
        return 0  # It's a .norg file, so definitely Neorg format
    fi
    
    # Special case for stdin content:
    # If it's our temp file from stdin AND no format was specified,
    # we assume it's already in neorg format
    if [[ "$STDIN_MODE" == true && "$file" == "$TEMP_FILE" && -z "$STDIN_FORMAT" ]]; then
        return 0  # Stdin with no format specified is assumed to be Neorg
    fi
    
    # For all other cases, assume it's not a Neorg file
    # Even if format is specified for stdin, the convert_to_neorg function
    # will handle it properly, so no need for special case here
    return 1  # Not a Neorg file
}

# Function to detect audio files by extension
is_audio_file() {
    # Function: is_audio_file
    # Purpose: Detect if a file is an audio file based on its extension
    # Arguments:
    #   $1 - File path to check
    # Returns: 0 if file is audio, 1 otherwise
    
    local file="$1"
    local file_ext="${file##*.}"  # Extract extension
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')  # Case-insensitive matching
    
    # Common audio file extensions
    case "$file_ext_lower" in
        mp3|wav|ogg|flac|m4a|aac|wma|opus)
            return 0  # File is a recognized audio format
            ;;
        *)
            return 1  # Not a recognized audio file
            ;;
    esac
}

# Function to detect video files by extension
is_video_file() {
    # Function: is_video_file
    # Purpose: Detect if a file is a video file based on its extension
    # Arguments:
    #   $1 - File path to check
    # Returns: 0 if file is video, 1 otherwise
    
    local file="$1"
    local file_ext="${file##*.}"  # Extract extension
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')  # Case-insensitive matching
    
    # Common video file extensions
    case "$file_ext_lower" in
        mp4|mkv|avi|mov|wmv|flv|webm|m4v|mpg|mpeg)
            return 0  # File is a recognized video format
            ;;
        *)
            return 1  # Not a recognized video file
            ;;
    esac
}

# Function to detect ebook files by extension
is_ebook_file() {
    # Function: is_ebook_file
    # Purpose: Detect if a file is an ebook based on its extension
    # Arguments:
    #   $1 - File path to check
    # Returns: 0 if file is an ebook, 1 otherwise
    
    local file="$1"
    local file_ext="${file##*.}"  # Extract extension
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')  # Case-insensitive matching
    
    # Common ebook file extensions
    case "$file_ext_lower" in
        # Multiple ebook formats supported
        epub|mobi|azw|azw3|fb2|lit|prc|pdb)
            return 0  # File is a recognized ebook format
            ;;
        *)
            return 1  # Not a recognized ebook file
            ;;
    esac
}

# Function to detect PDF files by extension
is_pdf_file() {
    # Function: is_pdf_file
    # Purpose: Detect if a file is a PDF based on its extension
    # Arguments:
    #   $1 - File path to check
    # Returns: 0 if file is PDF, 1 otherwise
    
    local file="$1"
    local file_ext="${file##*.}"  # Extract extension
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')  # Case-insensitive matching
    
    # Check for PDF extension
    if [[ "$file_ext_lower" == "pdf" ]]; then
        return 0  # File is a PDF
    else
        return 1  # Not a PDF file
    fi
}

# Function to detect office document files by extension
is_office_file() {
    # Function: is_office_file
    # Purpose: Detect if a file is an office document based on its extension
    # Arguments:
    #   $1 - File path to check
    # Returns: 0 if file is an office document, 1 otherwise
    
    local file="$1"
    local file_ext="${file##*.}"  # Extract extension
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')  # Case-insensitive matching
    
    # Common office document extensions
    case "$file_ext_lower" in
        # Microsoft Office and Open Document formats
        docx|pptx|odt|odp)
            return 0  # File is a recognized office document format
            ;;
        *)
            return 1  # Not a recognized office document
            ;;
    esac
}

is_generic_text_format() {
    # Function: is_generic_text_format
    # Purpose: Detect if a file is a generic text format (CSV, JSON, XML)
    # Arguments:
    #   $1 - File path to check
    # Returns: 0 if file is a recognized generic text format, 1 otherwise
    
    local file="$1"
    local file_ext="${file##*.}"  # Extract extension
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')  # Case-insensitive matching
    
    # Generic text format extensions
    case "$file_ext_lower" in
        csv|json|xml)
            return 0  # File is a recognized generic text format
            ;;
        *)
            return 1  # Not a recognized generic text format
            ;;
    esac
}

is_excel_file() {
    # Function: is_excel_file
    # Purpose: Detect if a file is an Excel spreadsheet
    # Arguments:
    #   $1 - File path to check
    # Returns: 0 if file is an Excel file, 1 otherwise
    
    local file="$1"
    local file_ext="${file##*.}"  # Extract extension
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')  # Case-insensitive matching
    
    # Excel file extensions
    case "$file_ext_lower" in
        xlsx|xls|xlsm|xlsb|xltx|xltm)
            return 0  # File is a recognized Excel format
            ;;
        *)
            return 1  # Not a recognized Excel format
            ;;
    esac
}

# Function to detect email files by extension (.eml or .msg)
is_email_file() {
    # Function: is_email_file
    # Purpose: Detect if a file is an email file based on its extension
    # Arguments:
    #   $1 - File path to check
    # Returns: 0 if file is an email file, 1 otherwise
    
    local file="$1"
    local file_ext="${file##*.}"  # Extract extension
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')  # Case-insensitive matching
    
    # Check for email file extensions
    case "$file_ext_lower" in
        eml|msg)
            return 0  # File is a recognized email format
            ;;
        *)
            return 1  # Not a recognized email file
            ;;
    esac
}

# Function to detect if a string is a URL
is_url() {
    # Function: is_url
    # Purpose: Detect if a string is a valid URL
    # Arguments:
    #   $1 - String to check
    # Returns: 0 if string is a URL, 1 otherwise
    
    local input="$1"
    
    # Basic URL pattern matching for HTTP/HTTPS URLs
    # This is a simple regex to match URLs starting with http:// or https://
    if [[ "$input" =~ ^https?:// ]]; then
        return 0  # String is a URL
    else
        return 1  # Not a URL
    fi
}

# Function to detect YouTube URLs specifically
is_youtube_url() {
    # Function: is_youtube_url
    # Purpose: Detect if a URL is from YouTube
    # Arguments:
    #   $1 - URL to check
    # Returns: 0 if URL is from YouTube, 1 otherwise

    local url="$1"

    # Match common YouTube URL patterns
    # Using grep with regex for more reliable pattern matching
    # - youtube.com/watch (standard YouTube URL)
    # - youtube.com/shorts/ (YouTube Shorts URL)
    # - youtu.be/ (YouTube short URL)
    if echo "$url" | grep -q -E 'youtube\.com/watch|youtube\.com/shorts|youtu\.be/'; then
        return 0  # URL is from YouTube
    else
        return 1  # Not a YouTube URL
    fi
}

# Function to extract a clean filename from a URL
extract_filename_from_url() {
    local url="$1"
    local filename=""
    
    # Remove protocol (http://, https://)
    url="${url#http://}"
    url="${url#https://}"
    
    # Remove query string and fragment
    url="${url%%\?*}"
    url="${url%%#*}"
    
    # Remove trailing slash
    url="${url%/}"
    
    # Get the last path component
    filename="${url##*/}"
    
    # If empty or the filename is the same as the cleaned URL (no path), use "index"
    if [[ -z "$filename" || "$filename" == "$url" ]]; then
        # This means we have just a domain with no path
        filename="index"
    fi
    
    # Clean up the filename - remove any remaining dots at the beginning
    filename="${filename#.}"
    
    # If filename ends with .html or .htm, remove the extension
    filename="${filename%.html}"
    filename="${filename%.htm}"
    
    # If after removing extensions the filename is empty, use "index"
    if [[ -z "$filename" ]]; then
        filename="index"
    fi
    
    # Convert to safe filename - replace non-alphanumeric chars (except dots, underscores, hyphens) with underscores
    filename=$(echo "$filename" | sed 's/[^a-zA-Z0-9._-]/_/g' | tr -s '_')
    
    # Remove trailing underscores
    filename="${filename%_}"
    
    echo "$filename"
}

# Function to download a generic URL and convert to markdown
download_url_as_markdown() {
    local url="$1"
    local output_file="$2"
    
    show_progress "Processing web page from URL: $url"
    
    # Create temp directory for processing
    local temp_dir=$(mktemp -d "${HOME}/.tmp/sbi-url-XXXXXX")
    local html_file="${temp_dir}/page.html"
    local md_file="${temp_dir}/page.md"
    
    # Check if markitdown is available - it can handle URLs directly
    if command -v markitdown &> /dev/null; then
        show_progress "Fetching and converting web page using markitdown..."
        if ! markitdown "$url" -o "$md_file"; then
            handle_error "$ERROR_TYPE_CONVERSION" "Failed to fetch/convert web page with markitdown" "" "WARNING"
            # Fall back to curl + pandoc method
            show_progress "Falling back to curl + pandoc method..."
            
            # Check if curl is installed
            if ! command -v curl &> /dev/null; then
                handle_error "$ERROR_TYPE_DEPENDENCY" "curl not found. Please install it to download web pages" "" "ERROR"
                rm -rf "$temp_dir"
                return 1
            fi
            
            # Download the webpage with curl
            show_progress "Fetching web page content with curl..."
            if ! curl -s -L --max-redirs 5 --connect-timeout 10 --max-time 30 -A "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36" "$url" > "$html_file"; then
                handle_error "$ERROR_TYPE_NETWORK" "Failed to download web page from URL: $url" "" "ERROR"
                rm -rf "$temp_dir"
                return 1
            fi
            
            # Try to convert with pandoc or alternatives
            if command -v pandoc &> /dev/null; then
                show_progress "Converting HTML to Markdown using pandoc..."
                if ! pandoc -f html -t markdown_strict "$html_file" -o "$md_file"; then
                    handle_error "$ERROR_TYPE_CONVERSION" "Failed to convert HTML to Markdown with pandoc" "" "ERROR"
                    rm -rf "$temp_dir"
                    return 1
                fi
            elif command -v distrobox &> /dev/null; then
                show_progress "Attempting to use pandoc via distrobox..."
                if ! distrobox enter dev -- pandoc -f html -t markdown_strict "$html_file" -o "$md_file"; then
                    handle_error "$ERROR_TYPE_CONVERSION" "Failed to convert HTML to Markdown with pandoc via distrobox" "" "ERROR"
                    rm -rf "$temp_dir"
                    return 1
                fi
            else
                handle_error "$ERROR_TYPE_CONVERSION" "No HTML to Markdown converters available" "" "ERROR"
                rm -rf "$temp_dir"
                return 1
            fi
        fi
    else
        # markitdown not available, use curl + pandoc method
        show_progress "markitdown not found, using curl to fetch web page..."
        
        # Check if curl is installed
        if ! command -v curl &> /dev/null; then
            handle_error "$ERROR_TYPE_DEPENDENCY" "curl not found. Please install it to download web pages" "" "ERROR"
            rm -rf "$temp_dir"
            return 1
        fi
        
        # Download the webpage with curl
        show_progress "Fetching web page content..."
        if ! curl -s -L --max-redirs 5 --connect-timeout 10 --max-time 30 -A "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36" "$url" > "$html_file"; then
            handle_error "$ERROR_TYPE_NETWORK" "Failed to download web page from URL: $url" "" "ERROR"
            rm -rf "$temp_dir"
            return 1
        fi
        
        # Convert HTML to Markdown using available tools
        
        # Convert HTML to Markdown using available tools
        if command -v pandoc &> /dev/null; then
            show_progress "Converting HTML to Markdown using pandoc..."
            if ! pandoc -f html -t markdown_strict "$html_file" -o "$md_file"; then
                handle_error "$ERROR_TYPE_CONVERSION" "Failed to convert HTML to Markdown with pandoc" "" "ERROR"
                rm -rf "$temp_dir"
                return 1
            fi
        elif command -v distrobox &> /dev/null; then
            show_progress "Attempting to use pandoc via distrobox..."
            if ! distrobox enter dev -- pandoc -f html -t markdown_strict "$html_file" -o "$md_file"; then
                handle_error "$ERROR_TYPE_CONVERSION" "Failed to convert HTML to Markdown with pandoc via distrobox" "" "ERROR"
                rm -rf "$temp_dir"
                return 1
            fi
        # Last resort: Use a very simple HTML to text conversion with lynx or w3m
        elif command -v lynx &> /dev/null; then
        show_progress "Using lynx for basic HTML to text conversion..."
        if ! lynx -dump -nolist "$html_file" > "$md_file"; then
            handle_error "$ERROR_TYPE_CONVERSION" "Failed to convert HTML to text with lynx" "" "ERROR"
            rm -rf "$temp_dir"
            return 1
        fi
    elif command -v w3m &> /dev/null; then
        show_progress "Using w3m for basic HTML to text conversion..."
        if ! w3m -dump "$html_file" > "$md_file"; then
            handle_error "$ERROR_TYPE_CONVERSION" "Failed to convert HTML to text with w3m" "" "ERROR"
            rm -rf "$temp_dir"
            return 1
        fi
        else
            handle_error "$ERROR_TYPE_DEPENDENCY" "No HTML to Markdown conversion tools found (pandoc, lynx, or w3m)" "" "ERROR"
            # Store the URL in the metadata
            echo "$url" > "${output_file}.url"
            # Copy the raw HTML as a fallback
            cp "$html_file" "$output_file"
            rm -rf "$temp_dir"
            return 1
        fi
    fi
    
    # Extract title from HTML for potential use as filename
    local title=$(grep -oP '(?<=<title>).*?(?=</title>)' "$html_file" | head -1 | sed 's/[^a-zA-Z0-9 ]/-/g' | tr -s ' ' '_')
    
    # Store URL and title in metadata files
    echo "$url" > "${output_file}.url"
    if [[ -n "$title" ]]; then
        echo "$title" > "${output_file}.title"
    fi
    
    # Copy the markdown to the output file
    cp "$md_file" "$output_file"
    
    # Clean up
    rm -rf "$temp_dir"
    
    show_progress "Successfully downloaded and converted URL to Markdown: $output_file"
    return 0
}

# Function to download audio from YouTube URL
download_youtube_audio() {
    local url="$1"
    local output_file="$2"
    
    show_progress "Downloading audio from YouTube URL: $url"
    
    # Check if yt-dlp is installed
    if ! command -v yt-dlp &> /dev/null; then
        handle_error "$ERROR_TYPE_DEPENDENCY" "yt-dlp not found. Please install it to download YouTube videos" "$EXIT_DEPENDENCY_ERROR"
    fi
    
    # Create temporary directory for yt-dlp 
    local dl_dir=$(dirname "$output_file")
    
    # Download best audio quality and convert to ogg
    # Use more reliable options: specify extension explicitly and use output template
    local base_name=$(basename "$output_file")
    
    # For better reliability:
    # 1. Using wav format which is more widely supported by transcribe_audio
    # 2. Use explicit output template with the wav extension
    # 3. Add --no-playlist to avoid playlist processing
    # 4. Add --no-check-certificate for some problematic URLs
    # 5. Add verbose output for debugging
    echo "Running yt-dlp to download audio in WAV format..."
    if ! yt-dlp -f "bestaudio" -x --audio-format wav --audio-quality 0 \
              --no-playlist --no-check-certificate --verbose \
              -o "${dl_dir}/${base_name}.wav" "$url"; then
        handle_error "$ERROR_TYPE_NETWORK" "Failed to download audio from YouTube URL: $url" "" "ERROR"
        return 1
    fi
    
    echo "yt-dlp completed. Checking for downloaded file..."
    # First check for the expected WAV file
    if [[ -f "${dl_dir}/${base_name}.wav" ]]; then
        echo "Found WAV file: ${dl_dir}/${base_name}.wav"
        cp "${dl_dir}/${base_name}.wav" "${output_file}"
        echo "Copied WAV file to: ${output_file}"
    else
        # Fallback: find any file that might have been created
        echo "WAV file not found at expected location. Searching for alternatives..."
        local found_file=$(find "$dl_dir" -name "${base_name}.*" -type f | head -1)
        
        # If we found something, use it
        if [[ -n "$found_file" && -f "$found_file" ]]; then
            echo "Found alternative file: ${found_file}"
            cp "$found_file" "${output_file}"
            echo "Copied alternative file to: ${output_file}"
        else
            echo "Error: Downloaded file not found."
            return 1
        fi
    fi
    
    # Final verification
    if [[ ! -f "$output_file" ]]; then
        handle_error "$ERROR_TYPE_PROCESSING" "Failed to process downloaded file from YouTube: $url" "" "ERROR"
        
        # Recovery option: Create placeholder file with URL information
        # This allows the user to retry manually later
        show_progress "Creating placeholder file with YouTube URL for manual recovery..."
        {
            echo "YouTube URL: $url"
            echo "Failed download attempt on: $(date)"
            echo "To manually download, run:"
            echo "yt-dlp -f \"bestaudio\" -x --audio-format wav \"$url\""
        } > "${output_file}.recovery"
        
        return 1
    fi
    
    echo "Successfully downloaded audio to: $output_file"
    return 0
}

# Function to process audio files (transcribe and summarize)
process_audio_file() {
    local input_file="$1"
    local output_file="$2"
    local filename_base="$3"
    
    show_progress "Processing audio file: $input_file"
    
    # Create temp directory for processing
    local temp_dir=$(mktemp -d "${HOME}/.tmp/sbi-audio-XXXXXX")
    
    # Generate transcript with transcribe_audio
    show_progress "Transcribing audio..."
    local transcript_file="${temp_dir}/transcript.txt"
    local transcription_uuid=""
    
    # Build transcribe_audio command with optional arguments
    local transcribe_cmd="transcribe_audio"
    [[ -n "$SUMMARY_TYPE" ]] && transcribe_cmd="$transcribe_cmd --type $SUMMARY_TYPE"
    [[ -n "$TAGS" ]] && transcribe_cmd="$transcribe_cmd --tags '$TAGS'"
    transcribe_cmd="$transcribe_cmd \"$input_file\""
    
    # Run the command and capture output
    local transcribe_output
    if ! transcribe_output=$(eval "$transcribe_cmd" 2>&1); then
        handle_error "$ERROR_TYPE_EXTERNAL" "Audio transcription failed using transcribe_audio tool" "" "ERROR"
        
        # Recovery option: Create placeholder file with instructions
        show_progress "Creating simple text note with recovery instructions..."
        {
            echo "* Failed Transcription: ${filename_base}"
            echo 
            echo "Source audio: ${input_file}"
            echo "Attempted processing on: $(date +"%Y-%m-%d %H:%M:%S")"
            echo
            echo "The audio file could not be transcribed automatically."
            echo "You can try manual transcription with:"
            echo "@code bash"
            echo "transcribe_audio \"$input_file\""
            echo "@end"
        } > "$output_file"
        
        rm -rf "$temp_dir"
        return 0  # Return success to allow the placeholder to be saved
    fi
    
    # Check if transcript was generated
    if [[ ! -f "${input_file}.txt" ]]; then
        handle_error "$ERROR_TYPE_PROCESSING" "Expected transcript file not found at ${input_file}.txt" "" "ERROR"
        
        # Recovery option similar to above
        show_progress "Creating simple text note with recovery instructions..."
        {
            echo "* Failed Transcription: ${filename_base}"
            echo 
            echo "Source audio: ${input_file}"
            echo "Attempted processing on: $(date +"%Y-%m-%d %H:%M:%S")"
            echo
            echo "The audio transcription process completed but no transcript was generated."
            echo "You can try manual transcription with:"
            echo "@code bash"
            echo "transcribe_audio \"$input_file\""
            echo "@end"
        } > "$output_file"
        
        rm -rf "$temp_dir"
        return 0  # Return success to allow the placeholder to be saved
    fi
    
    # Parse UUID from output if present (use tail -1 to get only the last UUID in case of duplicates)
    if echo "$transcribe_output" | grep -q "Transcription ID:"; then
        transcription_uuid=$(echo "$transcribe_output" | grep "Transcription ID:" | tail -1 | sed 's/.*ID: //' | tr -d ' ')
        debug_log "INFO" "Captured transcription UUID: $transcription_uuid"
    fi
    
    # Fetch transcript using UUID if available, otherwise fall back to file method
    if [[ -n "$transcription_uuid" ]]; then
        debug_log "DEBUG" "Fetching transcript using UUID: $transcription_uuid"
        show_progress "Fetching transcript from database..."
        
        # Use transcriptions view to get the transcript content
        if ! transcriptions view "$transcription_uuid" > "$transcript_file" 2>&1; then
            handle_error "$ERROR_TYPE_EXTERNAL" "Failed to fetch transcript from database" "" "ERROR"
            
            # Fall back to file method
            debug_log "WARN" "Falling back to file-based transcript retrieval"
            if [[ -f "${input_file}.txt" ]]; then
                mv "${input_file}.txt" "$transcript_file"
            else
                rm -rf "$temp_dir"
                return 1
            fi
        else
            debug_log "INFO" "Successfully fetched transcript from database"
        fi
    else
        # No UUID available, use traditional file method
        debug_log "DEBUG" "No UUID captured, using file-based method"
        if [[ -f "${input_file}.txt" ]]; then
            debug_log "DEBUG" "Moving transcript from ${input_file}.txt to $transcript_file"
            mv "${input_file}.txt" "$transcript_file"
        else
            handle_error "$ERROR_TYPE_FILE" "No transcript UUID and no .txt file found" "" "ERROR"
            rm -rf "$temp_dir"
            return 1
        fi
    fi
    
    # Verify the transcript file exists and is not empty
    if [[ ! -f "$transcript_file" ]]; then
        handle_error "$ERROR_TYPE_FILE" "Transcript file not found after retrieval" "" "ERROR"
        rm -rf "$temp_dir"
        return 1
    fi
    
    if [[ ! -s "$transcript_file" ]]; then
        handle_error "$ERROR_TYPE_PROCESSING" "Transcript file is empty" "" "ERROR"
        debug_log "ERROR" "Transcript file exists but is empty: $transcript_file"
        rm -rf "$temp_dir"
        return 1
    fi
    
    debug_log "INFO" "Transcript file size: $(wc -c < "$transcript_file") bytes"
    
    # Check if we should bypass AI summary generation
    if [[ "$NO_SUMMARY_MODE" == true ]]; then
        show_progress "No-summary mode enabled, skipping AI summary generation for audio"
        
        # Create a simple Neorg document with just the transcript
        {
            echo "* Audio Transcript: ${filename_base}"
            echo
            echo "Source audio: ${input_file}"
            echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
            [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
            [[ -n "$transcription_uuid" ]] && echo "Transcription UUID: $transcription_uuid"
            echo
            echo "* Transcript"
            echo
            cat "$transcript_file"
        } > "$output_file"
        
        # Clean up and return
        rm -rf "$temp_dir"
        return 0
    fi
    
    # Generate summary in neorg format (only if NO_SUMMARY_MODE is false)
    show_progress "Generating summary..."
    debug_log "DEBUG" "Calling run_ai_summary with transcript_file=$transcript_file output_file=$output_file"
    debug_log "DEBUG" "First 100 chars of transcript: $(head -c 100 "$transcript_file" | tr '\n' ' ')"
    run_ai_summary "${transcript_file}" "$output_file"
    
    # Add source information to the beginning of the file
    # Determine output extension based on mode
    local output_ext=".md"
    if [[ "$NEORG_MODE" == true ]]; then
        output_ext=".norg"
    fi
    local temp_output="${temp_dir}/output${output_ext}"
    
    # Check if this is from a YouTube URL
    local youtube_url=""
    if [[ -f "${input_file}.yturl" ]]; then
        youtube_url=$(cat "${input_file}.yturl")
    fi
    
    {
        echo "* Audio Summary: ${filename_base}"
        echo
        if [[ -n "$youtube_url" ]]; then
            echo "Source: YouTube video"
            echo "URL: ${youtube_url}"
        else
            echo "Source audio: ${input_file}"
        fi
        echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
        [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
        [[ -n "$transcription_uuid" ]] && echo "Transcription UUID: $transcription_uuid"
        echo
        echo "* Summary"
        echo
        cat "$output_file"
    } > "$temp_output"
    
    # Replace output file with our enhanced version
    mv "$temp_output" "$output_file"
    
    # Clean up
    rm -rf "$temp_dir"
    
    echo "Audio processing complete."
    return 0
}

# Function to convert ebook/PDF to markdown
convert_document_to_markdown() {
    local input_file="$1"
    local output_file="$2"
    
    show_progress "Converting document to markdown: $input_file"
    
    # Create temp directory for processing
    local temp_dir=$(mktemp -d $HOME/.tmp/sbi-doc-convert-XXXXXX)
    
    # Flag to indicate if we should use pdftotext instead of pandoc
    local use_pdftotext=false
    # Flag to indicate if we should use markitdown
    local use_markitdown=false
    
    # Get file extension and determine input format for pandoc
    local file_ext="${input_file##*.}"
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')
    local pandoc_input_format=""
    
    # Map file extensions to pandoc input formats
    case "$file_ext_lower" in
        epub)
            # Check if markitdown is available for EPUB files
            if command -v markitdown &> /dev/null; then
                use_markitdown=true
            else
                pandoc_input_format="epub"
            fi
            ;;
        pdf)
            # Don't use pandoc for PDF files - will use markitdown or pdftotext instead
            pandoc_input_format="pdf"
            # First check if markitdown is available
            if command -v markitdown &> /dev/null; then
                use_markitdown=true
            else
                # Otherwise use pdftotext
                use_pdftotext=true
            fi
            ;;
        mobi|azw|azw3)
            # Pandoc doesn't directly support these formats
            # Try using epub as a fallback (might not work)
            pandoc_input_format="epub"
            echo "Warning: Pandoc might not fully support $file_ext_lower format."
            ;;
        docx)
            pandoc_input_format="docx"
            ;;
        pptx)
            # Check if markitdown is available for PowerPoint files
            if command -v markitdown &> /dev/null; then
                use_markitdown=true
            else
                pandoc_input_format="pptx"
            fi
            ;;
        *)
            # For other formats, try to use the extension as the format
            pandoc_input_format="$file_ext_lower"
            echo "Using $file_ext_lower as pandoc input format (may not be supported)."
            ;;
    esac
    
    # First try markitdown for PDF or PowerPoint files
    if [[ "$use_markitdown" == true ]]; then
        local file_type="file"
        if [[ "$file_ext_lower" == "pdf" ]]; then
            file_type="PDF"
        elif [[ "$file_ext_lower" == "pptx" ]]; then
            file_type="PowerPoint"
        fi
        
        echo "Using markitdown for $file_type conversion..."
        if ! markitdown "$input_file" -o "$output_file"; then
            handle_error "$ERROR_TYPE_CONVERSION" "markitdown conversion failed for file: $input_file" "" "WARNING"
            # Continue to try other methods as a fallback
            if [[ "$file_ext_lower" == "pdf" ]]; then
                use_pdftotext=true
            fi
        else
            # Skip other processing
            echo "$file_type processing complete with markitdown."
            return 0
        fi
    fi
    
    # If markitdown not available or failed, try pdftotext
    if [[ "$use_pdftotext" == true ]] && command -v pdftotext &> /dev/null; then
        echo "Using pdftotext for PDF conversion..."
        if ! pdftotext -layout "$input_file" "$temp_dir/temp.txt"; then
            handle_error "$ERROR_TYPE_CONVERSION" "pdftotext conversion failed for file: $input_file" "" "WARNING"
            # Continue to try pandoc as a fallback
        else
            # Convert plain text to simple markdown
            {
                # Add title from filename
                echo "# $(basename "${input_file%.*}")"
                echo
                # Add file info
                echo "*Converted from PDF file: $(basename "$input_file")*"
                echo
                # Add content with paragraph breaks
                cat "$temp_dir/temp.txt"
            } > "$output_file"
            # Skip pandoc processing
            echo "PDF processing complete with pdftotext."
            return 0
        fi
    # If pdftotext failed or for non-PDF files, check if pandoc is installed
    elif command -v pandoc &> /dev/null; then
        echo "Using pandoc for conversion with format: $pandoc_input_format..."
        if ! pandoc -f "$pandoc_input_format" -t markdown_strict --extract-media="${temp_dir}/media" "$input_file" -o "$output_file"; then
            handle_error "$ERROR_TYPE_CONVERSION" "Pandoc conversion failed for file: $input_file (format: $pandoc_input_format)" "" "WARNING"
            # Try fallback to distrobox
            echo "Trying pandoc via distrobox..."
            if command -v distrobox &> /dev/null; then
                if ! distrobox enter dev -- pandoc -f "$pandoc_input_format" -t markdown_strict --extract-media="${temp_dir}/media" "$input_file" -o "$output_file"; then
                    handle_error "$ERROR_TYPE_CONVERSION" "Distrobox pandoc conversion also failed for file: $input_file" "" "ERROR"
                    
                    # For EPUB files, try unzipping and extracting content directly as a last resort
                    if [[ "$file_ext_lower" == "epub" ]] && command -v unzip &> /dev/null; then
                        echo "Attempting direct EPUB extraction as last resort..."
                        local epub_dir="${temp_dir}/epub_extract"
                        mkdir -p "$epub_dir"
                        
                        if unzip -q "$input_file" -d "$epub_dir"; then
                            # Try to find and extract content from OPF file
                            local opf_file=$(find "$epub_dir" -name "*.opf" | head -1)
                            local content_files=$(grep -o 'href="[^"]*\.x\?html\?"' "$opf_file" 2>/dev/null | sed 's/href="//;s/"$//' | sort)
                            
                            if [[ -n "$content_files" ]]; then
                                echo "# $(basename "${input_file%.*}")" > "$output_file"
                                echo >> "$output_file"
                                echo "*Extracted from EPUB file: $(basename "$input_file")*" >> "$output_file"
                                echo >> "$output_file"
                                
                                # Extract text from HTML files
                                for html_file in $content_files; do
                                    # Get the directory of the OPF file
                                    local opf_dir=$(dirname "$opf_file")
                                    local full_path="$opf_dir/$html_file"
                                    
                                    # If the file exists, extract text
                                    if [[ -f "$full_path" ]]; then
                                        # Use lynx or w3m to convert HTML to text
                                        if command -v lynx &> /dev/null; then
                                            lynx -dump -nolist "$full_path" >> "$output_file"
                                        elif command -v w3m &> /dev/null; then
                                            w3m -dump "$full_path" >> "$output_file"
                                        else
                                            # Last resort: crude HTML tag removal
                                            sed -e 's/<[^>]*>//g' "$full_path" >> "$output_file"
                                        fi
                                        echo >> "$output_file"
                                        echo "---" >> "$output_file"
                                        echo >> "$output_file"
                                    fi
                                done
                                
                                # If we succeeded in extracting something
                                if [[ -s "$output_file" ]]; then
                                    echo "Successfully extracted content directly from EPUB."
                                    rm -rf "$epub_dir"
                                else
                                    rm -rf "$temp_dir"
                                    return 1
                                fi
                            else
                                rm -rf "$temp_dir"
                                return 1
                            fi
                        else
                            rm -rf "$temp_dir"
                            return 1
                        fi
                    else
                        rm -rf "$temp_dir"
                        return 1
                    fi
                fi
            else
                # If direct extraction failed or wasn't attempted
                echo "Error: No fallback conversion method available."
                rm -rf "$temp_dir"
                return 1
            fi
        fi
    # Try using distrobox with pandoc if system pandoc isn't available
    elif command -v distrobox &> /dev/null; then
        echo "Using pandoc via distrobox with format: $pandoc_input_format..."
        if ! distrobox enter dev -- pandoc -f "$pandoc_input_format" -t markdown_strict --extract-media="${temp_dir}/media" "$input_file" -o "$output_file"; then
            echo "Error: Distrobox pandoc conversion failed."
            
            # For PDFs, try markitdown first if available
            if [[ "$file_ext_lower" == "pdf" ]] && command -v markitdown &> /dev/null; then
                echo "Falling back to markitdown for PDF conversion..."
                if ! markitdown "$input_file" -o "$output_file"; then
                    echo "Warning: markitdown conversion failed, trying pdftotext..."
                    # If markitdown fails, try pdftotext
                    if command -v pdftotext &> /dev/null && [[ "$use_pdftotext" != true ]]; then
                        if ! pdftotext -layout "$input_file" "$temp_dir/temp.txt"; then
                            echo "Error: pdftotext conversion failed."
                            rm -rf "$temp_dir"
                            return 1
                        fi
                        # Convert plain text to simple markdown
                        {
                            # Add title from filename
                            echo "# $(basename "${input_file%.*}")"
                            echo
                            # Add file info
                            echo "*Converted from PDF file: $(basename "$input_file")*"
                            echo
                            # Add content with paragraph breaks
                            cat "$temp_dir/temp.txt"
                        } > "$output_file"
                    else
                        echo "Error: PDF conversion failed."
                        rm -rf "$temp_dir"
                        return 1
                    fi
                fi
            # If markitdown not available, try pdftotext
            elif [[ "$file_ext_lower" == "pdf" ]] && command -v pdftotext &> /dev/null && [[ "$use_pdftotext" != true ]]; then
                echo "Falling back to pdftotext for PDF conversion..."
                if ! pdftotext -layout "$input_file" "$temp_dir/temp.txt"; then
                    echo "Error: pdftotext conversion failed."
                    rm -rf "$temp_dir"
                    return 1
                fi
                # Convert plain text to simple markdown
                {
                    # Add title from filename
                    echo "# $(basename "${input_file%.*}")"
                    echo
                    # Add file info
                    echo "*Converted from PDF file: $(basename "$input_file")*"
                    echo
                    # Add content with paragraph breaks
                    cat "$temp_dir/temp.txt"
                } > "$output_file"
            else
                rm -rf "$temp_dir"
                return 1
            fi
        fi
    # For PDFs, try markitdown first if available
    elif [[ "$file_ext_lower" == "pdf" ]] && command -v markitdown &> /dev/null && [[ "$use_markitdown" != true ]]; then
        echo "Using markitdown for PDF conversion..."
        if ! markitdown "$input_file" -o "$output_file"; then
            echo "Warning: markitdown conversion failed, trying pdftotext..."
            # Try pdftotext as fallback
            if command -v pdftotext &> /dev/null; then
                use_pdftotext=true
                # Continue to the next section that will handle pdftotext
            else
                echo "Error: No PDF conversion tools available."
                rm -rf "$temp_dir"
                return 1
            fi
        else
            echo "PDF processing complete with markitdown."
            return 0
        fi
    # For PDFs, try pdftotext if markitdown is not available or failed
    elif [[ "$file_ext_lower" == "pdf" ]] && command -v pdftotext &> /dev/null && [[ "$use_pdftotext" != true ]]; then
        echo "Using pdftotext for PDF conversion..."
        if ! pdftotext -layout "$input_file" "$temp_dir/temp.txt"; then
            echo "Error: pdftotext conversion failed."
            rm -rf "$temp_dir"
            return 1
        fi
        # Convert plain text to simple markdown
        {
            # Add title from filename
            echo "# $(basename "${input_file%.*}")"
            echo
            # Add file info
            echo "*Converted from PDF file: $(basename "$input_file")*"
            echo
            # Add content with paragraph breaks
            awk 'BEGIN{print ""}; {print $0"\n"}' "$temp_dir/temp.txt"
        } > "$output_file"
    # Try using pdf2txt.py from pdfminer if available
    elif [[ "$file_ext_lower" == "pdf" ]] && command -v pdf2txt.py &> /dev/null; then
        echo "Using pdf2txt.py for PDF conversion..."
        if ! pdf2txt.py -o "$temp_dir/temp.txt" "$input_file"; then
            echo "Error: pdf2txt.py conversion failed."
            rm -rf "$temp_dir"
            return 1
        fi
        # Convert plain text to simple markdown
        {
            # Add title from filename
            echo "# $(basename "${input_file%.*}")"
            echo
            # Add file info
            echo "*Converted from PDF file: $(basename "$input_file")*"
            echo
            # Add content with paragraph breaks
            awk 'BEGIN{print ""}; {print $0"\n"}' "$temp_dir/temp.txt"
        } > "$output_file"
    # Try unzip-based approach for EPUB as a standalone fallback
    elif [[ "$file_ext_lower" == "epub" ]] && command -v unzip &> /dev/null; then
        echo "Attempting direct EPUB extraction as standalone method..."
        local epub_dir="${temp_dir}/epub_extract"
        mkdir -p "$epub_dir"
        
        if unzip -q "$input_file" -d "$epub_dir"; then
            # Try to find and extract content from OPF file
            local opf_file=$(find "$epub_dir" -name "*.opf" | head -1)
            
            if [[ -n "$opf_file" && -f "$opf_file" ]]; then
                local content_files=$(grep -o 'href="[^"]*\.x\?html\?"' "$opf_file" 2>/dev/null | sed 's/href="//;s/"$//' | sort)
                
                if [[ -z "$content_files" ]]; then
                    # Try an alternative approach to find HTML files
                    content_files=$(find "$epub_dir" -name "*.html" -o -name "*.xhtml" | sort)
                fi
                
                if [[ -n "$content_files" ]]; then
                    echo "# $(basename "${input_file%.*}")" > "$output_file"
                    echo >> "$output_file"
                    echo "*Extracted from EPUB file: $(basename "$input_file")*" >> "$output_file"
                    echo >> "$output_file"
                    
                    # Extract text from HTML files
                    for html_file in $content_files; do
                        if [[ -f "$html_file" ]]; then
                            local file_to_process="$html_file"
                        else
                            # Path might be relative to OPF directory
                            local opf_dir=$(dirname "$opf_file")
                            local file_to_process="$opf_dir/$html_file"
                        fi
                        
                        # If the file exists, extract text
                        if [[ -f "$file_to_process" ]]; then
                            # Use lynx or w3m to convert HTML to text
                            if command -v lynx &> /dev/null; then
                                lynx -dump -nolist "$file_to_process" >> "$output_file"
                            elif command -v w3m &> /dev/null; then
                                w3m -dump "$file_to_process" >> "$output_file"
                            else
                                # Last resort: crude HTML tag removal
                                sed -e 's/<[^>]*>//g' "$file_to_process" >> "$output_file"
                            fi
                            echo >> "$output_file"
                            echo "---" >> "$output_file"
                            echo >> "$output_file"
                        fi
                    done
                    
                    # If we succeeded in extracting something
                    if [[ -s "$output_file" ]]; then
                        echo "Successfully extracted content directly from EPUB."
                    else
                        echo "Error: Failed to extract readable content from EPUB."
                        rm -rf "$temp_dir"
                        return 1
                    fi
                else
                    echo "Error: No content files found in EPUB."
                    rm -rf "$temp_dir"
                    return 1
                fi
            else
                echo "Error: Could not find OPF file in EPUB."
                rm -rf "$temp_dir"
                return 1
            fi
        else
            echo "Error: Failed to unzip EPUB file."
            rm -rf "$temp_dir"
            return 1
        fi
    else
        echo "Error: No conversion tools available. Please install pandoc, pdftotext, or pdf2txt.py."
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Verify conversion worked
    if [[ ! -s "$output_file" ]]; then
        handle_error "$ERROR_TYPE_CONVERSION" "Conversion produced an empty file for: $input_file" "" "ERROR"
        
        # Recovery option: Create basic info file
        echo "Creating basic document info file as fallback..."
        {
            echo "---"
            echo "title: $(basename "${input_file%.*}")"
            echo "source_file: $(basename "$input_file")"
            echo "source_format: ${input_file##*.}"
            echo "conversion_failed: true"
            echo "converted_on: $(date +"%Y-%m-%d %H:%M:%S")"
            echo "---"
            echo
            echo "# Conversion Failed: $(basename "${input_file%.*}")"
            echo
            echo "The document could not be converted properly. The original file is located at:"
            echo
            echo "    $(realpath "$input_file")"
            echo
            echo "## Manual Conversion Options"
            echo
            echo "You can try manual conversion with one of these methods:"
            echo
            echo "1. Using pandoc directly: `pandoc -f ${file_ext_lower} -t markdown_strict \"$input_file\" -o output.md`"
            echo "2. Using an online converter service"
            echo "3. Opening the document and manually copying the content"
        } > "$output_file"
        
        # Don't exit - return success to allow saving the recovery info
        rm -rf "$temp_dir"
        return 0
    fi
    
    # Add document metadata - prepend to the converted file
    local temp_output="${temp_dir}/output.md"
    
    {
        echo "---"
        echo "title: $(basename "${input_file%.*}")"
        echo "source_file: $(basename "$input_file")"
        echo "source_format: ${input_file##*.}"
        echo "converted_on: $(date +"%Y-%m-%d %H:%M:%S")"
        echo "---"
        echo
        cat "$output_file"
    } > "$temp_output"
    
    # Replace output file with enhanced version
    mv "$temp_output" "$output_file"
    
    # Clean up temp directory
    rm -rf "$temp_dir"
    
    echo "Document conversion complete: $output_file"
    return 0
}

# Function to process document content (ebook/PDF/office)
# Process Excel spreadsheets
process_excel_file() {
    local input_file="$1"
    local output_file="$2"
    local filename_base="$3"
    
    show_progress "Processing Excel spreadsheet: $input_file"
    
    # Create a temporary directory
    local temp_dir=$(mktemp -d ~/.tmp/excel-processing-XXXXX)
    local temp_md="$temp_dir/temp.md"
    
    # Extract file extension for reference
    local file_ext="${input_file##*.}"
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')
    
    # Determine Excel type for messages
    local excel_type="Excel spreadsheet"
    case "$file_ext_lower" in
        xlsx) excel_type="Excel XLSX" ;;
        xls) excel_type="Excel XLS" ;;
        xlsm) excel_type="Excel Macro-Enabled" ;;
        xlsb) excel_type="Excel Binary" ;;
        xltx|xltm) excel_type="Excel Template" ;;
    esac
    
    # Set title from filename base or directly from input file
    local title
    if [[ -n "$filename_base" ]]; then
        title="$filename_base"
    else
        title="$(basename "${input_file%.*}")"
    fi
    
    # Check if markitdown is available
    if command -v markitdown &> /dev/null; then
        show_progress "Using markitdown for Excel conversion..."
        
        # Convert to markdown using markitdown
        if ! markitdown "$input_file" -o "$temp_md"; then
            handle_error "$ERROR_TYPE_CONVERSION" "markitdown conversion failed for Excel file: $input_file" "" "WARNING"
            # Create basic markdown representation
            {
                echo "# $title"
                echo
                echo "*Converted from $excel_type file: $(basename "$input_file")*"
                echo
                echo "Excel file could not be converted. Please use an Excel application to view the original file."
                echo
                echo "Original file path: $input_file"
            } > "$temp_md"
        fi
    else
        # If markitdown not available, create basic markdown representation
        show_progress "markitdown not available. Creating basic Excel reference..."
        {
            echo "# $title"
            echo
            echo "*Excel file: $(basename "$input_file")*"
            echo
            echo "Excel file could not be converted because markitdown is not available."
            echo
            echo "Original file path: $input_file"
        } > "$temp_md"
    fi
    
    # Handle different output formats based on flags
    if [[ "$NO_SUMMARY_MODE" == true ]]; then
        if [[ "$NEORG_MODE" == true ]]; then
            # --no-summary --neorg: Convert markdown to neorg
            show_progress "Converting to Neorg format (no summary)..."
            if command -v mton &> /dev/null; then
                cat "$temp_md" | mton > "$output_file"
            else
                handle_error "$ERROR_TYPE_CONVERSION" "mton tool not available for markdown to neorg conversion" "" "WARNING"
                # Basic fallback - create a code block
                {
                    echo "@document.meta"
                    echo "title: $title"
                    echo "description: Excel spreadsheet"
                    echo "created: $(date +"%Y-%m-%d")"
                    echo "@end"
                    echo ""
                    echo "* $title"
                    echo ""
                    echo "Source: $excel_type file"
                    echo "Filename: $(basename "$input_file")"
                    echo "Processed on: $(date +'%Y-%m-%d %H:%M:%S')"
                    [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
                    echo ""
                    echo "Excel file could not be converted for direct viewing."
                    echo "Original file path: $input_file"
                } > "$output_file"
            fi
        else
            # --no-summary: Just use the markdown as is
            show_progress "Saving direct markdown conversion (no summary)..."
            cp "$temp_md" "$output_file"
        fi
    else
        # Generate summary
        if [[ "$NEORG_MODE" == true ]]; then
            # --neorg: Use ai_summary_as_neorg
            show_progress "Generating Neorg summary with AI..."
            
            # Pass all relevant options to summarization script
            local summary_options=""
            [[ -n "$SUMMARY_TYPE" ]] && summary_options+=" --type $SUMMARY_TYPE"
            [[ -n "$CUSTOM_PROMPT" ]] && summary_options+=" --prompt \"$CUSTOM_PROMPT\""
            [[ "$PRINCIPLE_MODE" == true ]] && summary_options+=" --principle"
            [[ -n "$MODEL" ]] && summary_options+=" --model $MODEL" 
            [[ -n "$PROVIDER" ]] && summary_options+=" --provider $PROVIDER"
            
            # Run the summarization script
            if ! ai_summary_as_neorg "$temp_md" $summary_options > "$output_file"; then
                handle_error "$ERROR_TYPE_PROCESSING" "Failed to generate neorg summary" "" "WARNING"
                # Fallback - convert markdown to neorg
                if command -v mton &> /dev/null; then
                    cat "$temp_md" | mton > "$output_file"
                else
                    # Last resort fallback
                    {
                        echo "@document.meta"
                        echo "title: $title"
                        echo "description: Excel spreadsheet"
                        echo "created: $(date +"%Y-%m-%d")"
                        echo "@end"
                        echo ""
                        echo "* $title"
                        echo ""
                        echo "Source: $excel_type file"
                        echo "Filename: $(basename "$input_file")"
                        echo "Processed on: $(date +'%Y-%m-%d %H:%M:%S')"
                        echo ""
                        echo "Excel file could not be converted for direct viewing."
                        echo "Original file path: $input_file"
                    } > "$output_file"
                fi
            fi
        else
            # Default: Use ai_summary_as_markdown
            show_progress "Generating markdown summary with AI..."
            
            # Pass all relevant options to summarization script
            local summary_options=""
            [[ -n "$SUMMARY_TYPE" ]] && summary_options+=" --type $SUMMARY_TYPE"
            [[ -n "$CUSTOM_PROMPT" ]] && summary_options+=" --prompt \"$CUSTOM_PROMPT\""
            [[ "$PRINCIPLE_MODE" == true ]] && summary_options+=" --principle"
            [[ -n "$MODEL" ]] && summary_options+=" --model $MODEL"
            [[ -n "$PROVIDER" ]] && summary_options+=" --provider $PROVIDER"
            
            # Run the summarization script
            if ! ai_summary_as_markdown "$temp_md" $summary_options > "$output_file"; then
                handle_error "$ERROR_TYPE_PROCESSING" "Failed to generate markdown summary" "" "WARNING"
                # Fallback to just the converted markdown
                cp "$temp_md" "$output_file"
            fi
        fi
    fi
    
    # Clean up
    rm -rf "$temp_dir"
    
    return 0
}

# Process generic text format (CSV, JSON, XML)
# Function to process email files (.eml and .msg)
process_email_file() {
    local input_file="$1"
    local output_file="$2"
    local filename_base="$3"
    
    show_progress "Processing email file: $input_file"
    
    # Create a temporary directory
    local temp_dir=$(mktemp -d ~/.tmp/email-processing-XXXXX)
    local temp_md="${temp_dir}/email.md"
    
    # Extract file extension for reference
    local file_ext="${input_file##*.}"
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')
    
    # Determine email format for messages
    local email_type="email"
    if [[ "$file_ext_lower" == "eml" ]]; then
        email_type="EML"
    elif [[ "$file_ext_lower" == "msg" ]]; then
        email_type="MSG (Outlook)"
    fi
    
    show_progress "Converting $email_type email to markdown..."
    
    # Use email_to_markdown to convert the email file
    if ! email_to_markdown -i "$input_file" -o "$temp_md"; then
        handle_error "$ERROR_TYPE_CONVERSION" "Failed to convert email file: $input_file" "" "WARNING"
        
        # Create basic markdown representation as fallback
        {
            echo "# Email: $(basename "${input_file%.*}")"
            echo ""
            echo "*Source: $email_type file*"
            echo "*Filename: $(basename "$input_file")*"
            echo "*Date: $(date +'%Y-%m-%d %H:%M:%S')*"
            echo ""
            echo "Email file could not be converted. Please view the original file with an appropriate email viewer."
            echo ""
            echo "Original file path: $input_file"
        } > "$temp_md"
    fi
    
    # Handle different output formats based on flags
    if [[ "$NO_SUMMARY_MODE" == true ]]; then
        if [[ "$NEORG_MODE" == true ]]; then
            # --no-summary --neorg: Convert markdown to neorg
            show_progress "Converting to Neorg format (no summary)..."
            if ! mton < "$temp_md" > "$output_file"; then
                handle_error "$ERROR_TYPE_CONVERSION" "Failed to convert markdown to Neorg using mton" "" "WARNING"
                
                # Create simple Neorg file as fallback
                {
                    echo "* Email: $(basename "${input_file%.*}")"
                    echo ""
                    echo "Source: $email_type file"
                    echo "Filename: $(basename "$input_file")"
                    echo "Date: $(date +'%Y-%m-%d %H:%M:%S')"
                    [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
                    echo ""
                    echo "@code"
                    cat "$temp_md"
                    echo "@end"
                } > "$output_file"
            fi
        else 
            # --no-summary: Just use the markdown as is
            show_progress "Saving direct markdown conversion (no summary)..."
            cp "$temp_md" "$output_file"
        fi
    else
        # Generate summary with AI
        if [[ "$NEORG_MODE" == true ]]; then
            # --neorg: Use ai_summary_as_neorg
            show_progress "Generating Neorg summary with AI..."
            run_ai_summary "$temp_md" "$output_file"
        else
            # Default: Use ai_summary_as_markdown
            show_progress "Generating markdown summary with AI..."
            run_ai_summary "$temp_md" "$output_file"
        fi
    fi
    
    # Clean up
    rm -rf "$temp_dir"
    
    return 0
}

process_generic_text_format() {
    local input_file="$1"
    local output_file="$2"
    local filename_base="$3"
    
    show_progress "Processing generic text format: $input_file"
    
    # Create a temporary directory
    local temp_dir=$(mktemp -d ~/.tmp/generic-text-processing-XXXXX)
    local temp_md="$temp_dir/temp.md"
    
    # Extract file extension for reference
    local file_ext="${input_file##*.}"
    local file_ext_lower=$(echo "$file_ext" | tr '[:upper:]' '[:lower:]')
    
    # Determine file type name for messages
    local file_type="file"
    case "$file_ext_lower" in
        csv) file_type="CSV" ;;
        json) file_type="JSON" ;;
        xml) file_type="XML" ;;
    esac
    
    # Set title from filename base or directly from input file
    local title
    if [[ -n "$filename_base" ]]; then
        title="$filename_base"
    else
        title="$(basename "${input_file%.*}")"
    fi
    
    # Check if markitdown is available
    if command -v markitdown &> /dev/null; then
        show_progress "Using markitdown for $file_type conversion..."
        
        # Convert to markdown using markitdown
        if ! markitdown "$input_file" -o "$temp_md"; then
            handle_error "$ERROR_TYPE_CONVERSION" "markitdown conversion failed for file: $input_file" "" "WARNING"
            # Create basic markdown representation
            {
                echo "# $title"
                echo
                echo "*Converted from $file_type file: $(basename "$input_file")*"
                echo
                echo '```'${file_ext_lower}
                cat "$input_file"
                echo '```'
            } > "$temp_md"
        fi
    else
        # If markitdown not available, create basic markdown representation
        show_progress "markitdown not available. Creating basic $file_type representation..."
        {
            echo "# $title"
            echo
            echo "*Converted from $file_type file: $(basename "$input_file")*"
            echo
            echo '```'${file_ext_lower}
            cat "$input_file"
            echo '```'
        } > "$temp_md"
    fi
    
    # Handle different output formats based on flags
    if [[ "$NO_SUMMARY_MODE" == true ]]; then
        if [[ "$NEORG_MODE" == true ]]; then
            # --no-summary --neorg: Convert markdown to neorg
            show_progress "Converting to Neorg format (no summary)..."
            if command -v mton &> /dev/null; then
                cat "$temp_md" | mton > "$output_file"
            else
                handle_error "$ERROR_TYPE_CONVERSION" "mton tool not available for markdown to neorg conversion" "" "WARNING"
                # Basic fallback - create a code block
                {
                    echo "@document.meta"
                    echo "title: $title"
                    echo "description: Converted $file_type file"
                    echo "created: $(date +"%Y-%m-%d")"
                    echo "@end"
                    echo ""
                    echo "* $title"
                    echo ""
                    echo "Source: $file_type file"
                    echo "Filename: $(basename "$input_file")"
                    echo "Processed on: $(date +'%Y-%m-%d %H:%M:%S')"
                    [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
                    echo ""
                    echo "@code $file_ext_lower"
                    cat "$input_file"
                    echo "@end"
                } > "$output_file"
            fi
        else
            # --no-summary: Just use the markdown as is
            show_progress "Saving direct markdown conversion (no summary)..."
            cp "$temp_md" "$output_file"
        fi
    else
        # Generate summary
        if [[ "$NEORG_MODE" == true ]]; then
            # --neorg: Use ai_summary_as_neorg
            show_progress "Generating Neorg summary with AI..."
            
            # Pass all relevant options to summarization script
            local summary_options=""
            [[ -n "$SUMMARY_TYPE" ]] && summary_options+=" --type $SUMMARY_TYPE"
            [[ -n "$CUSTOM_PROMPT" ]] && summary_options+=" --prompt \"$CUSTOM_PROMPT\""
            [[ "$PRINCIPLE_MODE" == true ]] && summary_options+=" --principle"
            [[ -n "$MODEL" ]] && summary_options+=" --model $MODEL" 
            [[ -n "$PROVIDER" ]] && summary_options+=" --provider $PROVIDER"
            
            # Run the summarization script
            if ! ai_summary_as_neorg "$temp_md" $summary_options > "$output_file"; then
                handle_error "$ERROR_TYPE_PROCESSING" "Failed to generate neorg summary" "" "WARNING"
                # Fallback - convert markdown to neorg
                if command -v mton &> /dev/null; then
                    cat "$temp_md" | mton > "$output_file"
                else
                    # Last resort fallback
                    {
                        echo "@document.meta"
                        echo "title: $title"
                        echo "description: Converted $file_type file"
                        echo "created: $(date +"%Y-%m-%d")"
                        echo "@end"
                        echo ""
                        echo "* $title"
                        echo ""
                        echo "Source: $file_type file"
                        echo "Filename: $(basename "$input_file")"
                        echo "Processed on: $(date +'%Y-%m-%d %H:%M:%S')"
                        echo ""
                        echo "@code $file_ext_lower"
                        cat "$input_file"
                        echo "@end"
                    } > "$output_file"
                fi
            fi
        else
            # Default: Use ai_summary_as_markdown
            show_progress "Generating markdown summary with AI..."
            
            # Pass all relevant options to summarization script
            local summary_options=""
            [[ -n "$SUMMARY_TYPE" ]] && summary_options+=" --type $SUMMARY_TYPE"
            [[ -n "$CUSTOM_PROMPT" ]] && summary_options+=" --prompt \"$CUSTOM_PROMPT\""
            [[ "$PRINCIPLE_MODE" == true ]] && summary_options+=" --principle"
            [[ -n "$MODEL" ]] && summary_options+=" --model $MODEL"
            [[ -n "$PROVIDER" ]] && summary_options+=" --provider $PROVIDER"
            
            # Run the summarization script
            if ! ai_summary_as_markdown "$temp_md" $summary_options > "$output_file"; then
                handle_error "$ERROR_TYPE_PROCESSING" "Failed to generate markdown summary" "" "WARNING"
                # Fallback to just the converted markdown
                cp "$temp_md" "$output_file"
            fi
        fi
    fi
    
    # Clean up
    rm -rf "$temp_dir"
    
    return 0
}

process_document_content() {
    local input_file="$1"
    local output_file="$2"
    local filename_base="$3"
    
    show_progress "Processing document: $input_file"
    
    # Create temp directory for processing
    local temp_dir=$(mktemp -d $HOME/.tmp/sbi-document-XXXXXX)
    local md_file="${temp_dir}/content.md"
    local doc_type="${input_file##*.}"
    
    # For markdown files, just copy the content instead of converting
    if [[ "${doc_type,,}" == "md" || "${doc_type,,}" == "markdown" ]]; then
        show_progress "File is already in markdown format, skipping conversion"
        
        # If sanitize mode is enabled, sanitize the content
        if [[ "$SANITIZE_MODE" == true ]]; then
            debug_log "INFO" "Sanitizing markdown content using sanitize_data"
            cat "$input_file" | sanitize_data > "$md_file"
        else
            cp "$input_file" "$md_file"
        fi
    # For other documents, convert to markdown
    elif ! convert_document_to_markdown "$input_file" "$md_file"; then
        handle_error "$ERROR_TYPE_CONVERSION" "Document conversion failed: $input_file" "" "WARNING"
        
        # Create recovery content
        show_progress "Creating basic document info as fallback..."
        {
            echo "* Document Information: ${filename_base}"
            echo 
            echo "Source: ${doc_type} document"
            echo "Filename: $(basename "$input_file")"
            echo "Path: $(realpath "$input_file")"
            echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
            [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
            echo
            echo "* Conversion Failed"
            echo
            echo "The document could not be converted properly. You can try:"
            echo
            echo "1. Converting it manually using appropriate tools"
            echo "2. Opening and copying the content directly"
            echo
            echo "Original file path:"
            echo "@code bash"
            echo "$(realpath "$input_file")"
            echo "@end"
        } > "$output_file"
        
        rm -rf "$temp_dir"
        return 0  # Return success to allow saving the recovery info
    fi
    
    # Get document title from markdown metadata or filename
    local doc_title=$(grep -m 1 "^title: " "$md_file" | sed 's/^title: //' || echo "$filename_base")
    
    # Check if we should bypass AI summary generation
    if [[ "$NO_SUMMARY_MODE" == true ]]; then
        show_progress "No-summary mode enabled, skipping AI summary generation"
        
        # Handle output format based on flags
        if [[ "$NEORG_MODE" == true ]]; then
            # Convert to neorg if mton is available
            if command -v mton &> /dev/null; then
                show_progress "Converting markdown directly to Neorg format using mton"
                if cat "$md_file" | mton > "$output_file"; then
                    show_progress "Successfully converted markdown to Neorg format"
                    # Clean up and return
                    rm -rf "$temp_dir"
                    return 0
                else
                    handle_error "$ERROR_TYPE_CONVERSION" "mton conversion failed for: $input_file" "" "WARNING"
                    # Continue with normal workflow as fallback
                fi
            else
                handle_error "$ERROR_TYPE_DEPENDENCY" "'mton' tool not found for direct Markdown to Neorg conversion" "" "WARNING"
                # Continue with normal workflow as fallback
            fi
        else
            # Default: use markdown directly
            show_progress "Saving markdown content directly"
            cp "$md_file" "$output_file"
            # Clean up and return
            rm -rf "$temp_dir"
            return 0
            # Continue with normal workflow as fallback
        fi
    fi
    
    # Generate AI summary (only reached if NO_SUMMARY_MODE is false or direct conversion failed)
    show_progress "Generating AI summary of document content..."
    # Determine output extension based on mode
    local output_ext=".md"
    if [[ "$NEORG_MODE" == true ]]; then
        output_ext=".norg"
    fi
    local ai_summary="${temp_dir}/summary${output_ext}"
    
    if command -v ai_summary_as_neorg &> /dev/null; then
        if ! run_ai_summary "$md_file" "$ai_summary"; then
            handle_error "$ERROR_TYPE_PROCESSING" "AI summary generation failed. Creating basic summary." "" "WARNING"
            {
                echo "AI summary generation failed for this document."
                echo "Please refer to the original file for content."
            } > "$ai_summary"
        fi
    else
        handle_error "$ERROR_TYPE_DEPENDENCY" "'ai_summary_as_neorg' not found. Creating basic structure." "" "WARNING"
        {
            echo "AI summary tool not available."
            echo "Please refer to the original file for content."
        } > "$ai_summary"
    fi
    
    # Create content preview (first section or few pages)
    head -n 50 "$md_file" > "${temp_dir}/preview.md"
    
    # Create the final neorg file with document summary and metadata
    {
        # Document title and metadata
        echo "* Document Summary: ${doc_title}"
        echo
        echo "Source: ${doc_type} document"
        echo "Filename: $(basename "$input_file")"
        echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
        [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
        echo
        
        # AI Summary section
        echo "* AI Summary"
        echo
        cat "$ai_summary"
        echo
        
        # Preview section
        echo "* Content Preview"
        echo
        echo "This is just a preview of the document. The original file contains more content."
        echo
        
        # Convert preview to neorg if mton is available
        if command -v mton &> /dev/null; then
            mton < "${temp_dir}/preview.md" || {
                # Fallback if mton fails
                echo "@code markdown"
                cat "${temp_dir}/preview.md"
                echo "@end"
            }
        else
            # Fallback if mton is not available
            echo "@code markdown"
            cat "${temp_dir}/preview.md"
            echo "@end"
        fi
        
        # Reference to original document
        echo
        echo "* Original Document"
        echo
        echo "The original document is located at:"
        echo "@code bash"
        realpath "$input_file"
        echo "@end"
        
    } > "$output_file"
    
    # Clean up
    rm -rf "$temp_dir"
    
    echo "Document processing complete."
    return 0
}

# Function to process web content from URL
# Function to crawl a website using wget
crawl_website() {
    # Function: crawl_website
    # Purpose: Crawl a website using wget and organize the content
    # Arguments:
    #   $1 - Source URL to crawl
    #   $2 - Output directory for crawled content
    # Returns: 0 if successful, non-zero otherwise
    
    local source_url="$1"
    local output_dir="$2"
    
    # Validate URL
    if [[ ! "$source_url" =~ ^https?:// ]]; then
        debug_log "ERROR" "Invalid URL for crawling: $source_url"
        handle_error "$ERROR_TYPE_INPUT" "Invalid URL for crawling. Must start with http:// or https://" "$EXIT_USAGE_ERROR"
        return 1
    fi
    
    # Create output directory if it doesn't exist
    mkdir -p "$output_dir"
    
    # Parse the domain from the URL for domain restriction
    local domain=$(echo "$source_url" | sed -e 's|^https\?://||' -e 's|/.*$||')
    debug_log "INFO" "Crawling website: $source_url (domain: $domain)"
    
    # Build the wget command based on user options
    local wget_cmd="wget"
    
    # Basic options
    wget_cmd+=" --recursive"  # Follow links recursively
    wget_cmd+=" --convert-links"  # Convert links for offline viewing
    wget_cmd+=" --page-requisites"  # Get all assets needed to display the page
    wget_cmd+=" --no-parent"  # Don't follow links to parent directories
    wget_cmd+=" --no-verbose"  # Reduce output verbosity
    
    # Set crawl depth
    wget_cmd+=" --level=$CRAWL_DEPTH"
    
    # Domain restriction
    if [[ "$CRAWL_DOMAIN_RESTRICT" == "true" ]]; then
        wget_cmd+=" --domains=$domain"
    fi
    
    # Wait between retrievals for politeness
    wget_cmd+=" --wait=$CRAWL_WAIT"
    
    # User agent
    wget_cmd+=" --user-agent='$CRAWL_USER_AGENT'"
    
    # Accept/reject patterns
    if [[ -n "$CRAWL_INCLUDE_PATTERN" ]]; then
        wget_cmd+=" --accept='$CRAWL_INCLUDE_PATTERN'"
    fi
    
    if [[ -n "$CRAWL_EXCLUDE_PATTERN" ]]; then
        wget_cmd+=" --reject='$CRAWL_EXCLUDE_PATTERN'"
    fi
    
    # Respect robots.txt
    wget_cmd+=" --execute robots=on"
    
    # Output directory
    wget_cmd+=" --directory-prefix=$output_dir"
    
    # Create metadata file about the crawl
    local metadata_file="$output_dir/crawl_metadata.txt"
    {
        echo "Source URL: $source_url"
        echo "Crawl Date: $(date +"%Y-%m-%d %H:%M:%S")"
        [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
        echo "Depth: $CRAWL_DEPTH"
        echo "Domain Restriction: $CRAWL_DOMAIN_RESTRICT"
        echo "Wait Time: $CRAWL_WAIT seconds"
        echo "User Agent: $CRAWL_USER_AGENT"
        echo "Include Pattern: $CRAWL_INCLUDE_PATTERN"
        echo "Exclude Pattern: $CRAWL_EXCLUDE_PATTERN"
    } > "$metadata_file"
    
    # Execute the wget command
    debug_log "DEBUG" "Executing wget command: $wget_cmd $source_url"
    echo "Crawling website: $source_url"
    echo "This may take some time depending on the site size and crawl depth..."
    
    if ! eval "$wget_cmd '$source_url'"; then
        debug_log "ERROR" "Website crawling failed for: $source_url"
        handle_error "$ERROR_TYPE_NETWORK" "Website crawling failed for: $source_url" "$EXIT_NETWORK_ERROR"
        return 1
    fi
    
    debug_log "INFO" "Website crawling completed for: $source_url"
    echo "Website crawled successfully."
    
    # Create an index file with a list of all crawled pages
    local index_file="$output_dir/crawl_index.txt"
    
    show_progress "Creating index of crawled pages..."
    echo "# Crawled Pages from $source_url" > "$index_file"
    echo "Crawl date: $(date +"%Y-%m-%d %H:%M:%S")" >> "$index_file"
    echo "Total files: $(find "$output_dir" -type f -name "*.html" | wc -l)" >> "$index_file"
    echo "" >> "$index_file"
    echo "## Pages:" >> "$index_file"
    
    # Find all HTML files and add them to the index
    find "$output_dir" -type f -name "*.html" | sort | while read -r html_file; do
        # Extract the title from the HTML file
        local title=$(grep -oP "(?<=<title>).*?(?=</title>)" "$html_file" || echo "Untitled")
        local rel_path="${html_file#$output_dir/}"
        echo "- [$title]($rel_path)" >> "$index_file"
    done
    
    echo "Website crawl completed successfully. Results saved to: $output_dir"
    return 0
}

# Function to process site export files (SingleFile, etc.)
process_site_export() {
    # Function: process_site_export
    # Purpose: Process site export files (SingleFile, static site exports, etc.)
    # Arguments:
    #   $1 - Input directory or file containing the site export
    #   $2 - Output directory for processed content
    #   $3 - Base filename for the knowledge base entry
    # Returns: 0 if successful, non-zero otherwise
    
    local input_path="$1"
    local output_dir="$2"
    local filename_base="$3"
    
    show_progress "Processing site export: $input_path"
    
    # Create output directory if it doesn't exist
    mkdir -p "$output_dir"
    
    # Create temp directory for processing
    local temp_dir=$(mktemp -d $HOME/.tmp/sbi-export-XXXXXX)
    
    # Determine if input is a file or directory
    if [[ -f "$input_path" ]]; then
        # SingleFile HTML or archive file
        local export_type=""
        
        # Check file extension to determine type
        if [[ "$input_path" =~ \.html?$ ]]; then
            export_type="singlefile"
        elif [[ "$input_path" =~ \.zip$ ]]; then
            export_type="zip"
        elif [[ "$input_path" =~ \.tar(\.gz)?$ ]]; then
            export_type="tar"
        else
            export_type="unknown"
        fi
        
        debug_log "INFO" "Processing site export of type: $export_type"
        
        case "$export_type" in
            singlefile)
                # SingleFile HTML file - just copy to output
                cp "$input_path" "$output_dir/index.html"
                # Extract title and store as metadata
                local title=$(grep -oP "(?<=<title>).*?(?=</title>)" "$input_path" || echo "Untitled Site Export")
                echo "$title" > "$output_dir/export_title.txt"
                # Create basic metadata file
                {
                    echo "Export Type: SingleFile HTML"
                    echo "Source File: $input_path"
                    echo "Export Date: $(date +"%Y-%m-%d %H:%M:%S")"
                    echo "Title: $title"
                } > "$output_dir/export_metadata.txt"
                ;;
                
            zip)
                # ZIP archive - extract to output directory
                show_progress "Extracting ZIP archive..."
                if ! unzip -q "$input_path" -d "$output_dir"; then
                    debug_log "ERROR" "Failed to extract ZIP file: $input_path"
                    handle_error "$ERROR_TYPE_PROCESSING" "Failed to extract ZIP file: $input_path" "$EXIT_PROCESSING_ERROR"
                    return 1
                fi
                # Create basic metadata file
                {
                    echo "Export Type: ZIP Archive"
                    echo "Source File: $input_path"
                    echo "Export Date: $(date +"%Y-%m-%d %H:%M:%S")"
                    echo "Files: $(find "$output_dir" -type f | wc -l)"
                } > "$output_dir/export_metadata.txt"
                ;;
                
            tar)
                # TAR archive - extract to output directory
                show_progress "Extracting TAR archive..."
                if [[ "$input_path" =~ \.tar\.gz$ ]]; then
                    if ! tar -xzf "$input_path" -C "$output_dir"; then
                        debug_log "ERROR" "Failed to extract TAR.GZ file: $input_path"
                        handle_error "$ERROR_TYPE_PROCESSING" "Failed to extract TAR.GZ file: $input_path" "$EXIT_PROCESSING_ERROR"
                        return 1
                    fi
                else
                    if ! tar -xf "$input_path" -C "$output_dir"; then
                        debug_log "ERROR" "Failed to extract TAR file: $input_path"
                        handle_error "$ERROR_TYPE_PROCESSING" "Failed to extract TAR file: $input_path" "$EXIT_PROCESSING_ERROR"
                        return 1
                    fi
                fi
                # Create basic metadata file
                {
                    echo "Export Type: TAR Archive"
                    echo "Source File: $input_path"
                    echo "Export Date: $(date +"%Y-%m-%d %H:%M:%S")"
                    echo "Files: $(find "$output_dir" -type f | wc -l)"
                } > "$output_dir/export_metadata.txt"
                ;;
                
            *)
                debug_log "ERROR" "Unsupported export file type: $input_path"
                handle_error "$ERROR_TYPE_INPUT" "Unsupported export file type. Please provide a supported format (HTML, ZIP, TAR)." "$EXIT_USAGE_ERROR"
                return 1
                ;;
        esac
    elif [[ -d "$input_path" ]]; then
        # Directory of files - copy to output
        echo "Copying directory contents..."
        cp -r "$input_path"/* "$output_dir"/ 2>/dev/null || true
        
        # Create basic metadata file
        {
            echo "Export Type: Directory"
            echo "Source Directory: $input_path"
            echo "Export Date: $(date +"%Y-%m-%d %H:%M:%S")"
            echo "Files: $(find "$output_dir" -type f | wc -l)"
        } > "$output_dir/export_metadata.txt"
    else
        debug_log "ERROR" "Invalid input path: $input_path"
        handle_error "$ERROR_TYPE_FILE" "Invalid input path. Must be a file or directory." "$EXIT_FILE_NOT_FOUND"
        return 1
    fi
    
    # Create an index file with a list of HTML files
    local index_file="$output_dir/export_index.txt"
    
    show_progress "Creating index of exported pages..."
    echo "# Exported Pages" > "$index_file"
    echo "Export date: $(date +"%Y-%m-%d %H:%M:%S")" >> "$index_file"
    echo "Total files: $(find "$output_dir" -type f -name "*.html" | wc -l)" >> "$index_file"
    echo "" >> "$index_file"
    echo "## Pages:" >> "$index_file"
    
    # Find all HTML files and add them to the index
    find "$output_dir" -type f -name "*.html" | sort | while read -r html_file; do
        # Extract the title from the HTML file
        local title=$(grep -oP "(?<=<title>).*?(?=</title>)" "$html_file" || echo "Untitled")
        local rel_path="${html_file#$output_dir/}"
        echo "- [$title]($rel_path)" >> "$index_file"
    done
    
    echo "Site export processed successfully. Results saved to: $output_dir"
    return 0
}

# Function to process and organize crawled content for the second brain
process_crawled_content() {
    # Function: process_crawled_content
    # Purpose: Process a crawled website directory and organize it for the second brain
    # Arguments:
    #   $1 - Directory containing crawled content
    #   $2 - Output neorg file for the knowledge base
    #   $3 - Base filename for the knowledge base entry
    # Returns: 0 if successful, non-zero otherwise
    
    local crawled_dir="$1"
    local output_file="$2"
    local filename_base="$3"
    
    echo "Processing crawled content: $crawled_dir"
    
    # Create temp directory for processing
    local temp_dir=$(mktemp -d $HOME/.tmp/sbi-crawl-XXXXXX)
    
    # Generate AI summary of the crawled content
    echo "Generating AI summary of crawled content..."
    local ai_summary=$(mktemp "${temp_dir}/ai_summary.XXXXXX")
    
    # Get the source URL from metadata
    local source_url=""
    if [[ -f "$crawled_dir/crawl_metadata.txt" ]]; then
        source_url=$(grep "Source URL:" "$crawled_dir/crawl_metadata.txt" | sed 's/Source URL: //')
    fi
    
    # Generate summary for the main page only
    local main_html_file=$(find "$crawled_dir" -name "index.html" -o -name "home.html" | head -1)
    
    # If main file not found, use the first HTML file
    if [[ -z "$main_html_file" ]]; then
        main_html_file=$(find "$crawled_dir" -name "*.html" | head -1)
    fi
    
    # If any HTML file exists, generate summary
    if [[ -n "$main_html_file" && -f "$main_html_file" ]]; then
        if command -v ai_summary_as_neorg &> /dev/null; then
            # Create AI summary in neorg format
            
            # Try different methods to extract text from HTML, in order of preference
            local html_text=""
            
            if command -v html2text &> /dev/null; then
                # Use html2text if available (preferred)
                debug_log "DEBUG" "Using html2text to convert HTML to plain text"
                html_text=$(cat "$main_html_file" | html2text 2>/dev/null)
            elif command -v lynx &> /dev/null; then
                # Use lynx as fallback with UTF-8 output
                debug_log "DEBUG" "Using lynx to convert HTML to plain text"
                # Force UTF-8 output with -display_charset=UTF-8
                html_text=$(lynx -dump -nolist -display_charset=UTF-8 "$main_html_file" 2>/dev/null)
            elif command -v w3m &> /dev/null; then
                # Use w3m as another fallback
                debug_log "DEBUG" "Using w3m to convert HTML to plain text"
                html_text=$(w3m -dump "$main_html_file" 2>/dev/null)
            else
                # Last resort: use grep and sed to extract text (very basic)
                debug_log "DEBUG" "Using basic text extraction from HTML"
                html_text=$(grep -o ">.*<" "$main_html_file" | sed 's/^>//;s/<$//' | grep -v "^$" 2>/dev/null)
            fi
            
            # Check if we got any text
            if [[ -n "$html_text" ]]; then
                debug_log "DEBUG" "Extracted text from HTML, sending to AI summary generator"
                
                # Create a temporary file with proper encoding for the text
                local text_file=$(mktemp "${temp_dir}/html_text.XXXXXX")
                
                # Clean the text to ensure it's valid UTF-8
                # tr command removes non-printable and non-UTF-8 characters
                echo "$html_text" | tr -cd '[:print:]\n' > "$text_file"
                
                debug_log "DEBUG" "Saved cleaned text to $text_file"
                
                # Use the file for AI summary instead of piping directly
                if ! run_ai_summary "$text_file" "$ai_summary" 2> "${temp_dir}/ai_error.log"; then
                    # Log the error message for debugging
                    if [[ -f "${temp_dir}/ai_error.log" ]]; then
                        debug_log "ERROR" "AI summary error: $(cat "${temp_dir}/ai_error.log")"
                    fi
                    
                    echo "Warning: AI summary generation failed. Will create a basic summary."
                    debug_log "ERROR" "AI summary generation failed for crawled content"
                    # Create a minimal summary as fallback
                    {
                        echo "AI summary generation failed for this crawled content."
                        echo "Please check the crawled files directly."
                    } > "$ai_summary"
                fi
            else
                echo "Warning: Could not extract text from HTML. Will create a basic summary."
                debug_log "WARNING" "Could not extract text from HTML for AI summary"
                # Create a minimal summary as fallback for empty text
                {
                    echo "Could not extract text from the HTML content."
                    echo "Please check the crawled files directly."
                } > "$ai_summary"
            fi
        else
            echo "Warning: 'ai_summary_as_neorg' not found. Creating basic structure instead."
            # Create a minimal note as fallback
            {
                echo "AI summary tool not available."
                echo "Please check the crawled files directly."
            } > "$ai_summary"
        fi
    else
        echo "Warning: No HTML files found in the crawled content."
        {
            echo "No HTML files found in the crawled content."
            echo "Please check if the crawling was successful."
        } > "$ai_summary"
    fi
    
    # Get site structure from the crawl_index.txt file
    local site_structure=""
    if [[ -f "$crawled_dir/crawl_index.txt" ]]; then
        site_structure=$(cat "$crawled_dir/crawl_index.txt")
    fi
    
    # Create the Neorg file
    {
        echo "* ${filename_base}"
        echo ""
        echo "** Metadata"
        echo ""
        echo "Source URL: $source_url"
        echo "Created on: $(date +"%Y-%m-%d %H:%M:%S")"
        [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
        echo "Crawl Depth: $CRAWL_DEPTH"
        echo "Crawl Files: $(find "$crawled_dir" -type f | wc -l)"
        echo ""
        
        echo "** Summary"
        echo ""
        if [[ -f "$ai_summary" ]]; then
            cat "$ai_summary"
        else
            echo "No summary available."
        fi
        echo ""
        
        echo "** Site Structure"
        echo ""
        if [[ -n "$site_structure" ]]; then
            # Convert markdown links to neorg format
            echo "$site_structure" | sed 's/\[/ /g' | sed 's/\](/ {/g' | sed 's/)$/}/g'
        else
            echo "Site structure information not available."
        fi
        echo ""
        
        # Only include raw file paths if archive mode is enabled
        if [[ "$CRAWL_ARCHIVE" == true ]]; then
            echo "** Files"
            echo ""
            echo "Path to crawled content:"
            echo "${filename_base} (in knowledge base)"
            echo ""
            echo "Main categories found:"
            # List the top-level directories in the crawled content
            find "$crawled_dir" -maxdepth 1 -type d | sort | while read -r dir; do
                if [[ "$dir" != "$crawled_dir" ]]; then
                    local dir_name=$(basename "$dir")
                    local file_count=$(find "$dir" -type f | wc -l)
                    echo "- $dir_name ($file_count files)"
                fi
            done
        else
            echo "** Statistics"
            echo ""
            echo "Files crawled: $(find "$crawled_dir" -type f | wc -l)"
            echo "HTML pages: $(find "$crawled_dir" -type f -name "*.html" | wc -l)"
            echo "Images: $(find "$crawled_dir" -type f -name "*.jpg" -o -name "*.png" -o -name "*.gif" | wc -l)"
            echo ""
            echo "Note: Raw crawled files are not saved. Use --crawl-archive to save the complete website."
        fi
    } > "$output_file"
    
    # Clean up
    rm -rf "$temp_dir"
    
    echo "Crawled content processed and saved to: $output_file"
    return 0
}

process_web_content() {
    local input_file="$1"
    local output_file="$2"
    local filename_base="$3"
    
    show_progress "Processing web content: $input_file"
    
    # Create temp directory for processing
    local temp_dir=$(mktemp -d $HOME/.tmp/sbi-web-XXXXXX)
    local url=""
    local page_title=""
    
    # Check if URL metadata exists
    if [[ -f "${input_file}.url" ]]; then
        url=$(cat "${input_file}.url")
    fi
    
    # Check if title metadata exists
    if [[ -f "${input_file}.title" ]]; then
        page_title=$(cat "${input_file}.title")
    fi
    
    # Check if we should bypass AI summary generation
    if [[ "$NO_SUMMARY_MODE" == true ]]; then
        show_progress "No-summary mode enabled, skipping AI summary generation"
        
        # If mton is available, directly convert markdown to neorg and save to output file
        if command -v mton &> /dev/null; then
            show_progress "Converting web content directly to Neorg format using mton"
            if cat "$input_file" | mton > "$output_file"; then
                show_progress "Successfully converted web content to Neorg format"
                # Clean up and return
                rm -rf "$temp_dir"
                return 0
            else
                handle_error "$ERROR_TYPE_CONVERSION" "mton conversion failed for web content" "" "WARNING"
                # Continue with normal workflow as fallback
            fi
        else
            handle_error "$ERROR_TYPE_DEPENDENCY" "'mton' tool not found for direct Markdown to Neorg conversion" "" "WARNING"
            # Continue with normal workflow as fallback
        fi
    fi
    
    # Generate AI summary of the web content (only reached if NO_SUMMARY_MODE is false or direct conversion failed)
    show_progress "Generating AI summary of web content..."
    local ai_summary=$(mktemp "${temp_dir}/ai_summary.XXXXXX")
    
    if command -v ai_summary_as_neorg &> /dev/null; then
        # Create AI summary in neorg format
        if ! run_ai_summary "$input_file" "$ai_summary"; then
            handle_error "$ERROR_TYPE_PROCESSING" "AI summary generation failed. Will create a basic summary." "" "WARNING"
            # Create a minimal summary as fallback
            {
                echo "AI summary generation failed for this web content."
                echo "Please see the full content below."
            } > "$ai_summary"
        fi
    else
        handle_error "$ERROR_TYPE_DEPENDENCY" "'ai_summary_as_neorg' not found. Creating basic structure instead." "" "WARNING"
        # Create a minimal note as fallback
        {
            echo "AI summary tool not available."
            echo "Please see the full content below."
        } > "$ai_summary"
    fi
    
    # Create the final neorg file with proper structure
    local full_content=$(mktemp "${temp_dir}/full_content.XXXXXX")
    
    # Get just a snippet of the content for a preview
    head -n 20 "$input_file" > "${temp_dir}/preview.md"
    
    # Convert the preview based on output format
    if [[ "$NEORG_MODE" == true ]]; then
        if command -v mton &> /dev/null; then
            mton < "${temp_dir}/preview.md" > "${temp_dir}/preview.norg" 2>/dev/null || true
        else
            # Fallback to code block for neorg
            {
                echo "@code markdown"
                cat "${temp_dir}/preview.md"
            echo "@end"
        } > "${temp_dir}/preview.norg"
    # For markdown mode, just use the preview.md directly
    fi
    fi
    
    # Create the final document with the structure we want
    {
        # Document title and metadata
        echo "* Web Content: ${filename_base}"
        echo
        echo "Source: Web page"
        if [[ -n "$page_title" ]]; then
            echo "Title: ${page_title}"
        fi
        if [[ -n "$url" ]]; then
            echo "URL: ${url}"
        fi
        echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
        [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
        echo
        
        # AI Summary section
        echo "* AI Summary"
        echo 
        cat "$ai_summary"
        echo
        
        # Content Preview
        echo "* Content Preview"
        echo
        echo "This is just a preview. See the full content section for complete text."
        echo
        # Display preview based on format
        if [[ "$NEORG_MODE" == true && -f "${temp_dir}/preview.norg" ]]; then
            cat "${temp_dir}/preview.norg"
        else
            cat "${temp_dir}/preview.md"
        fi
        echo
        
        # Reference to original markdown
        echo "* Full Content"
        echo
        echo "The complete content is stored as markdown and can be viewed at:"
        echo "@code bash"
        echo "cat \"$input_file\""
        echo "@end"
        
    } > "$output_file"
    
    # Clean up
    rm -rf "$temp_dir"
    
    echo "Web content processing complete."
    return 0
}

# Function to process video files (strip audio, transcribe, and summarize)
process_video_file() {
    local input_file="$1"
    local output_file="$2"
    local filename_base="$3"
    
    show_progress "Processing video file: $input_file"
    
    # Create temp directory for processing
    local temp_dir=$(mktemp -d $HOME/.tmp/sbi-video-XXXXXX)
    
    # Strip audio from video
    show_progress "Extracting audio from video..."
    local audio_file="${temp_dir}/audio.ogg"
    if ! strip_audio "$input_file" "$audio_file"; then
        handle_error "$ERROR_TYPE_PROCESSING" "Audio extraction failed" "" "ERROR"
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Transcribe audio
    show_progress "Transcribing audio..."
    local transcript_file="${temp_dir}/transcript.txt"
    local transcription_uuid=""
    
    # Build transcribe_audio command with optional arguments
    local video_transcribe_cmd="transcribe_audio"
    [[ -n "$SUMMARY_TYPE" ]] && video_transcribe_cmd="$video_transcribe_cmd --type $SUMMARY_TYPE"
    [[ -n "$TAGS" ]] && video_transcribe_cmd="$video_transcribe_cmd --tags '$TAGS'"
    video_transcribe_cmd="$video_transcribe_cmd \"$audio_file\""
    
    # Run the command and capture output
    local transcribe_output
    if ! transcribe_output=$(eval "$video_transcribe_cmd" 2>&1); then
        handle_error "$ERROR_TYPE_PROCESSING" "Transcription failed" "" "ERROR"
        rm -rf "$temp_dir"
        return 1
    fi
    
    # Parse UUID from output if present (use tail -1 to get only the last UUID in case of duplicates)
    if echo "$transcribe_output" | grep -q "Transcription ID:"; then
        transcription_uuid=$(echo "$transcribe_output" | grep "Transcription ID:" | tail -1 | sed 's/.*ID: //' | tr -d ' ')
        debug_log "INFO" "Captured transcription UUID: $transcription_uuid"
    fi
    
    # Fetch transcript using UUID if available, otherwise fall back to file method
    if [[ -n "$transcription_uuid" ]]; then
        debug_log "DEBUG" "Fetching transcript using UUID: $transcription_uuid"
        show_progress "Fetching transcript from database..."
        
        # Use transcriptions view to get the transcript content
        if ! transcriptions view "$transcription_uuid" > "$transcript_file" 2>&1; then
            handle_error "$ERROR_TYPE_EXTERNAL" "Failed to fetch transcript from database" "" "ERROR"
            
            # Fall back to file method
            debug_log "WARN" "Falling back to file-based transcript retrieval"
            if [[ -f "${audio_file}.txt" ]]; then
                mv "${audio_file}.txt" "$transcript_file"
            else
                rm -rf "$temp_dir"
                return 1
            fi
        else
            debug_log "INFO" "Successfully fetched transcript from database"
        fi
    else
        # No UUID available, use traditional file method
        debug_log "DEBUG" "No UUID captured, using file-based method"
        if [[ -f "${audio_file}.txt" ]]; then
            debug_log "DEBUG" "Moving transcript from ${audio_file}.txt to $transcript_file"
            mv "${audio_file}.txt" "$transcript_file"
        else
            handle_error "$ERROR_TYPE_FILE" "No transcript UUID and no .txt file found" "" "ERROR"
            rm -rf "$temp_dir"
            return 1
        fi
    fi
    
    # Verify the transcript file exists and is not empty
    if [[ ! -f "$transcript_file" ]]; then
        handle_error "$ERROR_TYPE_FILE" "Transcript file not found after retrieval" "" "ERROR"
        rm -rf "$temp_dir"
        return 1
    fi
    
    if [[ ! -s "$transcript_file" ]]; then
        handle_error "$ERROR_TYPE_PROCESSING" "Transcript file is empty" "" "ERROR"
        debug_log "ERROR" "Transcript file exists but is empty: $transcript_file"
        rm -rf "$temp_dir"
        return 1
    fi
    
    debug_log "INFO" "Transcript file size: $(wc -c < "$transcript_file") bytes"
    
    # Check if we should bypass AI summary generation
    if [[ "$NO_SUMMARY_MODE" == true ]]; then
        show_progress "No-summary mode enabled, skipping AI summary generation for video"
        
        # Create a simple Neorg document with just the transcript
        {
            echo "* Video Transcript: ${filename_base}"
            echo
            echo "Source video: ${input_file}"
            echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
            [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
            [[ -n "$transcription_uuid" ]] && echo "Transcription UUID: $transcription_uuid"
            echo
            echo "* Transcript"
            echo
            cat "$transcript_file"
        } > "$output_file"
        
        # Clean up and return
        rm -rf "$temp_dir"
        show_progress "Video processing complete."
        return 0
    fi
    
    # Generate summary in neorg format (only if NO_SUMMARY_MODE is false)
    show_progress "Generating summary..."
    run_ai_summary "$transcript_file" "$output_file"
    
    # Add source information to the beginning of the file
    # Determine output extension based on mode
    local output_ext=".md"
    if [[ "$NEORG_MODE" == true ]]; then
        output_ext=".norg"
    fi
    local temp_output="${temp_dir}/output${output_ext}"
    
    # Check if the original audio came from a YouTube URL
    # (This would happen if a YouTube URL was processed and the audio file 
    # was passed to process_video_file by mistake instead of process_audio_file)
    local youtube_url=""
    if [[ -f "${audio_file}.yturl" ]]; then
        youtube_url=$(cat "${audio_file}.yturl")
    elif [[ -f "${input_file}.yturl" ]]; then
        youtube_url=$(cat "${input_file}.yturl")
    fi
    
    {
        echo "* Video Summary: ${filename_base}"
        echo
        if [[ -n "$youtube_url" ]]; then
            echo "Source: YouTube video"
            echo "URL: ${youtube_url}"
        else
            echo "Source video: ${input_file}"
        fi
        echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
        [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
        [[ -n "$transcription_uuid" ]] && echo "Transcription UUID: $transcription_uuid"
        echo
        echo "* Summary"
        echo
        cat "$output_file"
    } > "$temp_output"
    
    # Replace output file with our enhanced version
    mv "$temp_output" "$output_file"
    
    # Clean up
    rm -rf "$temp_dir"
    
    show_progress "Video processing complete."
    return 0
}

# Parse arguments
PARA_TYPE="inbox"
TARGET_PARA="00_inbox"  # Initialize TARGET_PARA with the default inbox
CATEGORY=""
FILES=()
URLS=()          # Array for YouTube URLs to process
WEB_URLS=()      # Array for generic web URLs to process
LIST_FLAG=false
LIST_FILES_FLAG=false
FULL_PATH_FLAG=false
STDIN_MODE=false
TEMP_FILE=""
STDIN_FORMAT=""  # Format for stdin content
EDIT_FLAG=false  # Flag to enable editing
NAME_SEED=""     # Custom filename seed for stdin content

debug_log "INFO" "SBI started. Version 1.0"
debug_log "DEBUG" "Command-line arguments: $*"
debug_log "DEBUG" "Working directory: $(pwd)"

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            ;;
        --debug)
            DEBUG_MODE=true
            debug_log "INFO" "Debug mode enabled"
            # Create a log file if requested
            if [[ -n "$DEBUG_LOG_FILE" ]]; then
                debug_log "INFO" "Logging to file: $DEBUG_LOG_FILE"
            fi
            shift
            ;;
        --silent)
            SILENT_MODE=true
            debug_log "INFO" "Silent mode enabled"
            shift
            ;;
        -n|--no-summary)
            NO_SUMMARY_MODE=true
            debug_log "INFO" "No summary mode enabled - will bypass AI summary generation"
            shift
            ;;
        -s|--sanitize)
            SANITIZE_MODE=true
            debug_log "INFO" "Sanitize mode enabled - will pipe content through sanitize_data before processing"
            shift
            ;;
        --neorg)
            NEORG_MODE=true
            debug_log "INFO" "Neorg mode enabled - will use ai_summary_as_neorg instead of ai_summary_as_markdown"
            shift
            ;;
        --type)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --type flag"
                handle_error "$ERROR_TYPE_INPUT" "--type requires an argument" "$EXIT_USAGE_ERROR"
            fi
            SUMMARY_TYPE="$2"
            debug_log "DEBUG" "Summary type specified: $SUMMARY_TYPE"
            shift 2
            ;;
        --prompt)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --prompt flag"
                handle_error "$ERROR_TYPE_INPUT" "--prompt requires an argument" "$EXIT_USAGE_ERROR"
            fi
            SUMMARY_PROMPT="$2"
            debug_log "DEBUG" "Summary prompt specified: $SUMMARY_PROMPT"
            shift 2
            ;;
        --principle)
            SUMMARY_PRINCIPLE_MODE=true
            debug_log "DEBUG" "Principle mode enabled for summary"
            shift
            ;;
        --provider)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --provider flag"
                handle_error "$ERROR_TYPE_INPUT" "--provider requires an argument" "$EXIT_USAGE_ERROR"
            fi
            SUMMARY_PROVIDER="$2"
            debug_log "DEBUG" "Summary provider specified: $SUMMARY_PROVIDER"
            shift 2
            ;;
        --model)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --model flag"
                handle_error "$ERROR_TYPE_INPUT" "--model requires an argument" "$EXIT_USAGE_ERROR"
            fi
            SUMMARY_MODEL="$2"
            debug_log "DEBUG" "Summary model specified: $SUMMARY_MODEL"
            shift 2
            ;;
        --tags)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --tags flag"
                handle_error "$ERROR_TYPE_INPUT" "--tags requires an argument" "$EXIT_USAGE_ERROR"
            fi
            TAGS="$2"
            debug_log "DEBUG" "Tags specified: $TAGS"
            shift 2
            ;;
        -i|--interactive)
            INTERACTIVE_MODE=true
            debug_log "INFO" "Interactive TUI mode enabled"
            shift
            ;;
        -l|--list)
            # Capture the list flag - we'll process it after parsing all arguments
            LIST_FLAG=true
            debug_log "DEBUG" "List flag enabled"
            shift
            ;;
        -L|--list-files)
            # Capture the list-files flag - we'll process it after parsing all arguments
            LIST_FILES_FLAG=true
            debug_log "DEBUG" "List-files flag enabled"
            shift
            ;;
        -f|--full-path)
            # Capture the full-path flag
            FULL_PATH_FLAG=true
            debug_log "DEBUG" "Full-path flag enabled"
            shift
            ;;
        --format)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --format flag"
                handle_error "$ERROR_TYPE_INPUT" "--format requires an argument" "$EXIT_USAGE_ERROR"
            fi
            STDIN_FORMAT="$2"
            debug_log "DEBUG" "Format specified: $STDIN_FORMAT"
            shift 2
            ;;
        --name-seed)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --name-seed flag"
                handle_error "$ERROR_TYPE_INPUT" "--name-seed requires an argument" "$EXIT_USAGE_ERROR"
            fi
            NAME_SEED="$2"
            debug_log "DEBUG" "Name seed specified: $NAME_SEED"
            shift 2
            ;;
        -e|--edit)
            EDIT_FLAG=true
            debug_log "DEBUG" "Edit flag enabled"
            shift
            ;;
        -p|--para)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --para flag"
                handle_error "$ERROR_TYPE_INPUT" "--para requires an argument" "$EXIT_USAGE_ERROR"
            fi
            case "$2" in
                inbox|project|area|resource|archive|detect)
                    PARA_TYPE="$2"
                    debug_log "DEBUG" "PARA category specified: $PARA_TYPE"
                    ;;
                *)
                    debug_log "ERROR" "Invalid PARA type: $2"
                    handle_error "$ERROR_TYPE_INPUT" "Invalid PARA type. Must be one of: inbox, project, area, resource, archive, detect" "$EXIT_USAGE_ERROR"
                    ;;
            esac
            shift 2
            ;;
        -b|--branch)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --branch flag"
                handle_error "$ERROR_TYPE_INPUT" "--branch requires an argument" "$EXIT_USAGE_ERROR"
            fi
            BRANCH_NAME="$2"
            NOTES_DIR="$HOME/Documents/notes/trees/$BRANCH_NAME"
            debug_log "INFO" "Using git worktree branch: $BRANCH_NAME"
            debug_log "DEBUG" "NOTES_DIR updated to: $NOTES_DIR"
            if [[ ! -d "${NOTES_DIR}" ]]; then
                debug_log "ERROR" "$NOTES_DIR does not exist. Are you sure you created this worktree?"
                handle_error "$ERROR_TYPE_INPUT" "--branch argument is invalid" "$EXIT_USAGE_ERROR"
            fi
            shift 2
            ;;
        -c|--category)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --category flag"
                handle_error "$ERROR_TYPE_INPUT" "--category requires an argument" "$EXIT_USAGE_ERROR"
            fi
            CATEGORY="$2"
            debug_log "DEBUG" "Category specified: $CATEGORY"
            shift 2
            ;;
        # Web crawling options
        --crawl)
            CRAWL_MODE=true
            debug_log "INFO" "Web crawling mode enabled"
            shift
            ;;
        --crawl-archive)
            CRAWL_ARCHIVE=true
            debug_log "INFO" "Website archive saving enabled"
            shift
            ;;
        --export)
            EXPORT_MODE=true
            debug_log "INFO" "Site export processing mode enabled"
            shift
            ;;
        --depth)
            if [[ $# -lt 2 || ! "$2" =~ ^[0-9]+$ ]]; then
                debug_log "ERROR" "Missing or invalid argument for --depth flag"
                handle_error "$ERROR_TYPE_INPUT" "--depth requires a numeric argument" "$EXIT_USAGE_ERROR"
            fi
            CRAWL_DEPTH="$2"
            debug_log "DEBUG" "Crawl depth specified: $CRAWL_DEPTH"
            shift 2
            ;;
        --no-domain-restrict)
            CRAWL_DOMAIN_RESTRICT=false
            debug_log "DEBUG" "Domain restriction disabled for crawling"
            shift
            ;;
        --wait)
            if [[ $# -lt 2 || ! "$2" =~ ^[0-9]+$ ]]; then
                debug_log "ERROR" "Missing or invalid argument for --wait flag"
                handle_error "$ERROR_TYPE_INPUT" "--wait requires a numeric argument" "$EXIT_USAGE_ERROR"
            fi
            CRAWL_WAIT="$2"
            debug_log "DEBUG" "Crawl wait time specified: $CRAWL_WAIT seconds"
            shift 2
            ;;
        --include)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --include flag"
                handle_error "$ERROR_TYPE_INPUT" "--include requires a pattern argument" "$EXIT_USAGE_ERROR"
            fi
            CRAWL_INCLUDE_PATTERN="$2"
            debug_log "DEBUG" "Crawl include pattern specified: $CRAWL_INCLUDE_PATTERN"
            shift 2
            ;;
        --exclude)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --exclude flag"
                handle_error "$ERROR_TYPE_INPUT" "--exclude requires a pattern argument" "$EXIT_USAGE_ERROR"
            fi
            CRAWL_EXCLUDE_PATTERN="$2"
            debug_log "DEBUG" "Crawl exclude pattern specified: $CRAWL_EXCLUDE_PATTERN"
            shift 2
            ;;
        --user-agent)
            if [[ $# -lt 2 || -z "$2" || "$2" == -* ]]; then
                debug_log "ERROR" "Missing argument for --user-agent flag"
                handle_error "$ERROR_TYPE_INPUT" "--user-agent requires a string argument" "$EXIT_USAGE_ERROR"
            fi
            CRAWL_USER_AGENT="$2"
            debug_log "DEBUG" "Crawl user agent specified: $CRAWL_USER_AGENT"
            shift 2
            ;;
        *)
            # Check if it's a URL
            if is_url "$1"; then
                # Process URL
                if is_youtube_url "$1"; then
                    # This is a YouTube URL - add to a special URL array for audio processing
                    echo "Detected YouTube URL: $1"
                    debug_log "INFO" "Detected YouTube URL: $1"
                    URLS+=("$1")
                else
                    # For other URLs, process as web content
                    echo "Detected generic URL: $1"
                    debug_log "INFO" "Detected generic URL: $1"
                    # Store in a different array for web content processing
                    WEB_URLS+=("$1")
                    # Don't fall through to the file check, we know it's a URL
                fi
            elif [[ -f "$1" ]]; then
                # It's a valid file
                debug_log "DEBUG" "Adding file to processing queue: $1"
                FILES+=("$1")
            else
                debug_log "ERROR" "Invalid input: '$1' is not a valid file or URL"
                handle_error "$ERROR_TYPE_INPUT" "'$1' is not a valid file or URL" "$EXIT_FILE_NOT_FOUND"
            fi
            shift
            ;;
    esac
done

# Process interactive mode if requested
if [[ "$INTERACTIVE_MODE" == true ]]; then
    debug_log "INFO" "Starting interactive TUI mode"
    run_interactive_mode
    exit $?
fi

# Process list flags if set
if [[ "$LIST_FLAG" == true || "$LIST_FILES_FLAG" == true ]]; then
    debug_log "INFO" "Processing directory listing request"
    
    # Determine include_files value based on which flag was used
    include_files="false"
    if [[ "$LIST_FILES_FLAG" == true ]]; then
        include_files="true"
        debug_log "DEBUG" "Including files in listing"
    else
        debug_log "DEBUG" "Listing directories only"
    fi
    
    # Convert PARA_TYPE to format expected by list_structure
    if [[ -n "$PARA_TYPE" && "$PARA_TYPE" != "detect" && "$PARA_TYPE" != "inbox" ]]; then
        # Use specified PARA type
        debug_log "DEBUG" "Listing structure for PARA type: $PARA_TYPE, category: $CATEGORY"
        list_structure "$PARA_TYPE" "$CATEGORY" "$include_files" "$FULL_PATH_FLAG"
    else
        # If para type is not specified, is "detect", or is the default "inbox",
        # show all PARA folders (full listing)
        debug_log "DEBUG" "Listing full structure for all PARA categories"
        list_structure "" "" "$include_files" "$FULL_PATH_FLAG"
    fi
fi

# Handle website crawling mode
if [[ "$CRAWL_MODE" == true ]]; then
    echo "Web crawling mode enabled"
    debug_log "INFO" "Web crawling mode enabled"
    
    # Check dependencies for web crawling
    if ! check_crawl_dependencies; then
        debug_log "ERROR" "Missing dependencies for web crawling"
        exit $EXIT_DEPENDENCY_ERROR
    fi
    
    # Make sure we have at least one URL to crawl
    if [[ ${#WEB_URLS[@]} -eq 0 ]]; then
        debug_log "ERROR" "No URLs provided for crawling"
        handle_error "$ERROR_TYPE_INPUT" "You must provide at least one URL to crawl when using --crawl mode" "$EXIT_USAGE_ERROR"
    fi
    
    # Map PARA_TYPE to TARGET_PARA if not already done
    if [[ -n "$PARA_TYPE" && "$PARA_TYPE" != "detect" ]]; then
        case "$PARA_TYPE" in
            inbox)
                TARGET_PARA="00_inbox"
                ;;
            project)
                TARGET_PARA="01_projects"
                ;;
            area)
                TARGET_PARA="02_areas"
                ;;
            resource)
                TARGET_PARA="03_resources"
                ;;
            archive)
                TARGET_PARA="04_archives"
                ;;
            *)
                # This should never happen due to validation above, but as a safety
                TARGET_PARA="00_inbox"
                ;;
        esac
    fi

    # Process each URL for crawling
    for url in "${WEB_URLS[@]}"; do
        debug_log "INFO" "Crawling web URL: $url"
        
        # Generate unique directory name for this URL
        url_domain=$(echo "$url" | sed -e 's|^https\?://||' -e 's|/.*$||')
        url_hash=$(echo "$url" | md5sum | cut -d' ' -f1 | head -c 8)
        crawl_dir_name="${url_domain}-${url_hash}"
        crawl_path="$HOME/.tmp/sbi-crawl-$crawl_dir_name"
        
        debug_log "DEBUG" "Generated directory for crawled site: $crawl_path"
        
        # Create crawl directory if it doesn't exist
        mkdir -p "$crawl_path"
        
        # Execute the crawl
        echo "Crawling website: $url (depth: $CRAWL_DEPTH)"
        if ! crawl_website "$url" "$crawl_path"; then
            debug_log "ERROR" "Failed to crawl website: $url"
            continue
        fi
        
        # Generate the target filename based on the domain
        if [[ "$CRAWL_ARCHIVE" == true ]]; then
            # Simple name for archive mode (will be in websites folder)
            filename_base="${url_domain}-site"
        else
            # More descriptive name for default mode (will be at PARA root)
            filename_base="website-${url_domain}-$(date +"%Y-%m-%d")"
        fi
        
        # Use custom name seed if provided
        if [[ -n "$NAME_SEED" ]]; then
            filename_base="$NAME_SEED"
        fi
        
        # Determine the target path
        if [[ "$PARA_TYPE" == "detect" || -z "$TARGET_PARA" ]]; then
            # If PARA type is "detect", attempt to detect the category for the main page
            if [[ -f "$crawl_path/index.html" ]]; then
                detected_para_type=$(detect_para_category "$crawl_path/index.html")
                debug_log "INFO" "Auto-detected PARA category: $detected_para_type"
                
                # Map to correct PARA folder
                case "$detected_para_type" in
                    inbox)
                        TARGET_PARA="00_inbox"
                        ;;
                    project)
                        TARGET_PARA="01_projects"
                        ;;
                    area)
                        TARGET_PARA="02_areas"
                        ;;
                    resource)
                        TARGET_PARA="03_resources"
                        ;;
                    archive)
                        TARGET_PARA="04_archives"
                        ;;
                    *)
                        # Default to inbox for unknown categories
                        TARGET_PARA="00_inbox"
                        ;;
                esac
            else
                # Default to inbox if we can't detect
                TARGET_PARA="00_inbox"
            fi
        fi
        
        # Ensure TARGET_PARA has a valid value
        if [[ -z "$TARGET_PARA" ]]; then
            # Default to inbox if TARGET_PARA is still empty
            TARGET_PARA="00_inbox"
            debug_log "WARNING" "TARGET_PARA not set, defaulting to inbox category"
        fi
        
        # Create target directory path
        target_dir="${NOTES_DIR}/${TARGET_PARA}"
        if [[ -n "$CATEGORY" ]]; then
            # Add category path if specified
            target_dir="${target_dir}/${CATEGORY}"
        else
            # Only add "websites" subdirectory if archive mode is enabled
            if [[ "$CRAWL_ARCHIVE" == true ]]; then
                target_dir="${target_dir}/websites"
            fi
        fi
        
        # Make sure target directory exists
        mkdir -p "$target_dir"
        
        # Define paths for processed content
        # Determine file extension based on output mode
        local file_ext=".md"
        if [[ "$NEORG_MODE" == true ]]; then
            file_ext=".norg"
            debug_log "DEBUG" "Using .norg extension due to --neorg flag"
        fi

        neorg_file="${target_dir}/${filename_base}${file_ext}"

        # Process the crawled content
        echo "Processing crawled content..."
        if ! process_crawled_content "$crawl_path" "$neorg_file" "$filename_base"; then
            debug_log "ERROR" "Failed to process crawled content for: $url"
            continue
        fi
        
        # Save raw crawled content if archive mode is enabled
        if [[ "$CRAWL_ARCHIVE" == true ]]; then
            # Create archive directory
            crawl_archive_dir="${target_dir}/${filename_base}"
            mkdir -p "$crawl_archive_dir"
            
            # Copy raw crawled content to the archive directory
            echo "Copying crawled content to archive directory..."
            cp -r "$crawl_path"/* "$crawl_archive_dir"/
            
            echo "Raw crawled data saved to: $crawl_archive_dir"
            debug_log "INFO" "Raw crawled data saved to: $crawl_archive_dir"
        else
            debug_log "INFO" "Archive mode disabled, skipping raw data saving"
        fi
        
        # Edit the neorg file if edit flag is specified
        if [[ "$EDIT_FLAG" == true ]]; then
            ${EDITOR:-vi} "$neorg_file"
            debug_log "INFO" "Edited crawled content in: $neorg_file"
        fi
        
        echo "Web crawling completed for $url"
        echo "Content saved to: $neorg_file"
    done
    
    # Exit after processing all crawl URLs
    exit 0
fi

# Handle site export processing mode
if [[ "$EXPORT_MODE" == true ]]; then
    echo "Site export processing mode enabled"
    debug_log "INFO" "Site export processing mode enabled"
    
    # Make sure we have at least one file to process
    if [[ ${#FILES[@]} -eq 0 ]]; then
        debug_log "ERROR" "No files provided for site export processing"
        handle_error "$ERROR_TYPE_INPUT" "You must provide at least one file (HTML, ZIP, TAR) when using --export mode" "$EXIT_USAGE_ERROR"
    fi
    
    # Map PARA_TYPE to TARGET_PARA if not already done
    if [[ -n "$PARA_TYPE" && "$PARA_TYPE" != "detect" ]]; then
        case "$PARA_TYPE" in
            inbox)
                TARGET_PARA="00_inbox"
                ;;
            project)
                TARGET_PARA="01_projects"
                ;;
            area)
                TARGET_PARA="02_areas"
                ;;
            resource)
                TARGET_PARA="03_resources"
                ;;
            archive)
                TARGET_PARA="04_archives"
                ;;
            *)
                # This should never happen due to validation above, but as a safety
                TARGET_PARA="00_inbox"
                ;;
        esac
    fi

    # Process each export file
    for file in "${FILES[@]}"; do
        debug_log "INFO" "Processing site export file: $file"
        
        # Generate unique directory name for this export
        file_basename=$(basename "$file")
        file_hash=$(md5sum "$file" | cut -d' ' -f1 | head -c 8)
        export_dir_name="${file_basename%.*}-${file_hash}"
        export_path="$HOME/.tmp/sbi-export-$export_dir_name"
        
        debug_log "DEBUG" "Generated directory for site export: $export_path"
        
        # Create export directory if it doesn't exist
        mkdir -p "$export_path"
        
        # Execute the export processing
        echo "Processing site export: $file"
        if ! process_site_export "$file" "$export_path" "$file_basename"; then
            debug_log "ERROR" "Failed to process site export: $file"
            continue
        fi
        
        # Generate the target filename based on the file name
        if [[ "$CRAWL_ARCHIVE" == true ]]; then
            # Simple name for archive mode (will be in websites folder)
            filename_base="${file_basename%.*}-site"
        else
            # More descriptive name for default mode (will be at PARA root)
            filename_base="website-export-${file_basename%.*}-$(date +"%Y-%m-%d")"
        fi
        
        # Use custom name seed if provided
        if [[ -n "$NAME_SEED" ]]; then
            filename_base="$NAME_SEED"
        fi
        
        # Determine the target path
        if [[ "$PARA_TYPE" == "detect" || -z "$TARGET_PARA" ]]; then
            # If PARA type is "detect", attempt to detect the category
            if [[ -f "$export_path/index.html" ]]; then
                detected_para_type=$(detect_para_category "$export_path/index.html")
                debug_log "INFO" "Auto-detected PARA category: $detected_para_type"
                
                # Map to correct PARA folder
                case "$detected_para_type" in
                    inbox)
                        TARGET_PARA="00_inbox"
                        ;;
                    project)
                        TARGET_PARA="01_projects"
                        ;;
                    area)
                        TARGET_PARA="02_areas"
                        ;;
                    resource)
                        TARGET_PARA="03_resources"
                        ;;
                    archive)
                        TARGET_PARA="04_archives"
                        ;;
                    *)
                        # Default to inbox for unknown categories
                        TARGET_PARA="00_inbox"
                        ;;
                esac
            else
                # Default to inbox if we can't detect
                TARGET_PARA="00_inbox"
            fi
        fi
        
        # Ensure TARGET_PARA has a valid value
        if [[ -z "$TARGET_PARA" ]]; then
            # Default to inbox if TARGET_PARA is still empty
            TARGET_PARA="00_inbox"
            debug_log "WARNING" "TARGET_PARA not set, defaulting to inbox category"
        fi
        
        # Create target directory path
        target_dir="${NOTES_DIR}/${TARGET_PARA}"
        if [[ -n "$CATEGORY" ]]; then
            # Add category path if specified
            target_dir="${target_dir}/${CATEGORY}"
        else
            # Only add "websites" subdirectory if archive mode is enabled
            if [[ "$CRAWL_ARCHIVE" == true ]]; then
                target_dir="${target_dir}/websites"
            fi
        fi
        
        # Make sure target directory exists
        mkdir -p "$target_dir"
        
        # Define paths for processed content
        # Determine file extension based on output mode
        local file_ext=".md"
        if [[ "$NEORG_MODE" == true ]]; then
            file_ext=".norg"
            debug_log "DEBUG" "Using .norg extension due to --neorg flag"
        fi

        neorg_file="${target_dir}/${filename_base}${file_ext}"

        # Process the export content into a file
        echo "Creating knowledge base entry for site export..."
        {
            echo "* ${filename_base}"
            echo ""
            echo "** Metadata"
            echo ""
            echo "Source: $(basename "$file")"
            echo "Created on: $(date +"%Y-%m-%d %H:%M:%S")"
            [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
            echo "Export Type: $(file -b "$file")"
            echo ""
            
            echo "** Summary"
            echo ""
            echo "Site export from: $(basename "$file")"
            
            # Add index if available
            if [[ -f "$export_path/export_index.txt" ]]; then
                echo ""
                echo "** Site Structure"
                echo ""
                # Convert markdown links to neorg format
                cat "$export_path/export_index.txt" | sed 's/\[/ /g' | sed 's/\](/ {/g' | sed 's/)$/}/g'
            fi
            
            # Only include raw file paths if archive mode is enabled
            if [[ "$CRAWL_ARCHIVE" == true ]]; then
                echo ""
                echo "** Files"
                echo ""
                echo "Path to exported content:"
                echo "${filename_base} (in knowledge base)"
                echo ""
                echo "Main files in export:"
                # List the top HTML files in the export
                find "$export_path" -name "*.html" | head -10 | while read -r html_file; do
                    rel_path="${html_file#$export_path/}"
                    echo "- $rel_path"
                done
            else
                echo ""
                echo "** Statistics"
                echo ""
                echo "Files extracted: $(find "$export_path" -type f | wc -l)"
                echo "HTML pages: $(find "$export_path" -type f -name "*.html" | wc -l)"
                echo "Images: $(find "$export_path" -type f -name "*.jpg" -o -name "*.png" -o -name "*.gif" | wc -l)"
                echo ""
                echo "Note: Raw export files are not saved. Use --crawl-archive to save the complete export."
            fi
        } > "$neorg_file"
        
        # Save raw export content if archive mode is enabled
        if [[ "$CRAWL_ARCHIVE" == true ]]; then
            # Create archive directory
            export_archive_dir="${target_dir}/${filename_base}"
            mkdir -p "$export_archive_dir"
            
            # Copy raw export content to the archive directory
            echo "Copying export content to archive directory..."
            cp -r "$export_path"/* "$export_archive_dir"/
            
            echo "Raw export data saved to: $export_archive_dir"
            debug_log "INFO" "Raw export data saved to: $export_archive_dir"
        else
            debug_log "INFO" "Archive mode disabled, skipping raw data saving"
        fi
        
        # Edit the neorg file if edit flag is specified
        if [[ "$EDIT_FLAG" == true ]]; then
            ${EDITOR:-vi} "$neorg_file"
            debug_log "INFO" "Edited export content in: $neorg_file"
        fi
        
        echo "Site export processing completed for $file"
        echo "Content saved to: $neorg_file"
    done
    
    # Exit after processing all export files
    exit 0
fi

# Process YouTube URLs if any
if [[ ${#URLS[@]} -gt 0 ]]; then
    echo "Processing ${#URLS[@]} YouTube URL(s)..."
    debug_log "INFO" "Processing ${#URLS[@]} YouTube URL(s)"
    
    # Create temp directory for downloads
    YT_TEMP_DIR=$(mktemp -d $HOME/.tmp/sbi-youtube-XXXXXX)
    debug_log "DEBUG" "Created temporary directory for YouTube downloads: $YT_TEMP_DIR"
    
    # Process each URL
    for url in "${URLS[@]}"; do
        debug_log "INFO" "Processing YouTube URL: $url"
        
        # Generate a unique filename for this URL
        url_hash=$(echo "$url" | md5sum | cut -d' ' -f1)
        audio_file="${YT_TEMP_DIR}/${url_hash}"  # Extension will be added by yt-dlp
        debug_log "DEBUG" "Generated hash for URL: $url_hash"
        debug_log "DEBUG" "Target audio file path: $audio_file"
        
        # Download audio from YouTube
        debug_log "INFO" "Attempting to download audio from YouTube URL"
        if download_youtube_audio "$url" "$audio_file"; then
            debug_log "INFO" "Successfully downloaded audio from YouTube"
            
            # Store YouTube URL in a metadata file that will be used during processing
            echo "$url" > "${audio_file}.yturl"
            debug_log "DEBUG" "Stored original URL in metadata file: ${audio_file}.yturl"
            
            # Mark this as a direct audio file (not needing audio extraction)
            # This will be used later to skip the audio extraction step
            touch "${audio_file}.direct_audio"
            debug_log "DEBUG" "Marked audio file as direct audio (no extraction needed)"
            
            # Add audio file to the FILES array for processing
            FILES+=("$audio_file")
            debug_log "DEBUG" "Added audio file to processing queue: $audio_file"
            
            # Get and store YouTube title, but don't override custom name-seed
            # Try to get video title using yt-dlp
            debug_log "DEBUG" "Attempting to get video title from YouTube"
            title=$(yt-dlp --get-title "$url" 2>/dev/null)
            if [[ -n "$title" ]]; then
                # Always store the title in a metadata file for the specific URL
                echo "$title" > "${audio_file}.title"
                debug_log "DEBUG" "Stored video title in metadata file: ${audio_file}.title"
                
                # Only set NAME_SEED if it wasn't provided by the user
                if [[ -z "$NAME_SEED" ]]; then
                    echo "Using YouTube video title as filename: $title"
                    debug_log "INFO" "Using YouTube video title as filename: $title"
                else
                    echo "Using custom name-seed instead of YouTube title: $NAME_SEED"
                    debug_log "INFO" "Using custom name-seed instead of YouTube title: $NAME_SEED"
                fi
            else
                debug_log "WARNING" "Could not retrieve video title from YouTube"
            fi
        else
            echo "Warning: Failed to process YouTube URL: $url"
            debug_log "ERROR" "Failed to process YouTube URL: $url"
        fi
    done
fi

# Process generic web URLs if any
if [[ ${#WEB_URLS[@]} -gt 0 ]]; then
    echo "Processing ${#WEB_URLS[@]} web URL(s)..."
    debug_log "INFO" "Processing ${#WEB_URLS[@]} web URL(s)"
    
    # Create temp directory for downloads
    WEB_TEMP_DIR=$(mktemp -d $HOME/.tmp/sbi-web-XXXXXX)
    debug_log "DEBUG" "Created temporary directory for web downloads: $WEB_TEMP_DIR"
    
    # Process each URL
    for url in "${WEB_URLS[@]}"; do
        debug_log "INFO" "Processing web URL: $url"
        
        # Generate a filename from the URL
        url_filename=$(extract_filename_from_url "$url")
        # If NAME_SEED is provided, use it instead
        if [[ -n "$NAME_SEED" ]]; then
            url_filename="$NAME_SEED"
        fi
        md_file="${WEB_TEMP_DIR}/${url_filename}.md"
        debug_log "DEBUG" "Generated filename from URL: $url_filename"
        debug_log "DEBUG" "Target markdown file path: $md_file"
        
        # Download and convert web page to markdown
        debug_log "INFO" "Attempting to download and convert web page to markdown"
        if download_url_as_markdown "$url" "$md_file"; then
            debug_log "INFO" "Successfully downloaded and converted web page"
            
            # Add markdown file to the FILES array for processing
            FILES+=("$md_file")
            debug_log "DEBUG" "Added markdown file to processing queue: $md_file"
            
            # Mark this as a web content file for special processing
            touch "${md_file}.web_content"
            debug_log "DEBUG" "Marked file as web content for special processing"
            
            # Get filename from title if available and name seed wasn't provided
            if [[ -z "$NAME_SEED" && -f "${md_file}.title" ]]; then
                # Use page title as filename base
                web_title=$(cat "${md_file}.title")
                if [[ -n "$web_title" ]]; then
                    echo "Using web page title as filename: $web_title"
                    debug_log "INFO" "Using web page title as filename: $web_title"
                else
                    debug_log "DEBUG" "Web page title file exists but is empty"
                fi
            elif [[ -n "$NAME_SEED" ]]; then
                echo "Using custom name-seed for web content: $NAME_SEED"
                debug_log "INFO" "Using custom name-seed for web content: $NAME_SEED"
            else
                debug_log "DEBUG" "No title or name seed available, will use default naming"
            fi
        else
            echo "Warning: Failed to process web URL: $url"
            debug_log "ERROR" "Failed to process web URL: $url"
        fi
    done
fi

# Check if at least one file is provided or if we have stdin input, only if we're not listing
if [[ ${#FILES[@]} -eq 0 && "$LIST_FLAG" == false && "$LIST_FILES_FLAG" == false ]]; then
    debug_log "DEBUG" "Checking for stdin input because no files were specified"
    
    # Check if there's data on stdin (not a terminal)
    if [ -t 0 ]; then
        # No stdin input
        debug_log "ERROR" "No input files specified and no content provided via stdin"
        handle_error "$ERROR_TYPE_INPUT" "No input files specified and no content provided via stdin" "$EXIT_USAGE_ERROR"
    else
        # We have stdin input; create a temporary file
        debug_log "INFO" "Detected content on stdin, processing"
        TEMP_FILE=$(mktemp $HOME/.tmp/sbi-stdin-XXXXXX)
        debug_log "DEBUG" "Created temporary file for stdin content: $TEMP_FILE"
        
        # Handle different formats first
        if [[ -n "$STDIN_FORMAT" ]]; then
            # If format is specified, create a code block with that format
            debug_log "DEBUG" "Wrapping stdin content in Neorg code block with format: $STDIN_FORMAT"
            {
                echo "@code $STDIN_FORMAT"
                cat
                echo "@end"
            } > "$TEMP_FILE"
        else
            # Default: assume content is already in neorg format
            debug_log "DEBUG" "Assuming stdin content is already in Neorg format"
            cat > "$TEMP_FILE"
        fi
        
        # If edit is requested, let the user edit directly with their editor
        if [[ "$EDIT_FLAG" == true ]]; then
            # Rather than using vipe, use the editor directly on the temp file
            debug_log "INFO" "Opening editor for stdin content: ${EDITOR:-vi}"
            ${EDITOR:-vi} "$TEMP_FILE"
            debug_log "DEBUG" "Editor session for stdin content completed"
        fi
        
        FILES=("$TEMP_FILE")
        debug_log "DEBUG" "Added stdin content file to processing queue: $TEMP_FILE"
        
        # Flag to indicate this file should be removed after processing
        STDIN_MODE=true
        debug_log "DEBUG" "Set STDIN_MODE to true for cleanup later"
    fi
else
    STDIN_MODE=false
    debug_log "DEBUG" "STDIN_MODE set to false (not processing stdin)"
fi

# Process each file
debug_log "INFO" "Starting to process ${#FILES[@]} file(s)"

for file in "${FILES[@]}"; do
    debug_log "INFO" "Processing file: $file"
    
    if [[ ! -f "$file" ]]; then
        echo "Warning: File does not exist or is not a regular file: $file"
        debug_log "WARNING" "File does not exist or is not a regular file: $file"
        continue
    fi
    
    # Generate filename - prioritize name-seed for all content types
    debug_log "DEBUG" "Generating filename for content"
    
    if [[ -n "$NAME_SEED" ]]; then
        # Always prioritize user-specified name seed for ALL content types
        echo "Using custom name seed for filename: $NAME_SEED"
        debug_log "INFO" "Using custom name seed for filename: $NAME_SEED"
        filename="$NAME_SEED"
        filename_no_ext="$filename"
    elif [[ "$STDIN_MODE" == true && "$file" == "$TEMP_FILE" ]]; then
        # For stdin content with no name seed, use just the date as filename
        current_date=$(date +"%Y-%m-%d")
        debug_log "DEBUG" "Using current date for stdin content filename: $current_date"
        filename="${current_date}"
        filename_no_ext="$filename"
    # Check if this is a YouTube file (has a title metadata file)
    elif [[ -f "${file}.title" ]]; then
        # Use the YouTube video title as filename
        filename=$(cat "${file}.title")
        filename_no_ext="$filename"
        echo "Using saved YouTube title for filename: $filename"
        debug_log "INFO" "Using saved YouTube title for filename: $filename"
    # Check if this is a web content file (has a URL metadata file)
    elif [[ -f "${file}.url" ]]; then
        # Extract filename from the URL
        url=$(cat "${file}.url")
        url_filename=$(extract_filename_from_url "$url")
        # Check if we also have a page title
        if [[ -f "${file}.title" ]]; then
            # Prefer page title over URL-based filename
            filename=$(cat "${file}.title")
            filename_no_ext="$filename"
            echo "Using saved web page title for filename: $filename"
            debug_log "INFO" "Using saved web page title for filename: $filename"
        else
            # Use URL-based filename
            filename="$url_filename"
            filename_no_ext="$filename"
            echo "Using URL-based filename: $filename"
            debug_log "INFO" "Using URL-based filename: $filename (from URL: $url)"
        fi
    else
        # Default case - use original filename
        filename=$(basename "$file")
        filename_no_ext="${filename%.*}"
        debug_log "DEBUG" "Using original filename: $filename (base: $filename_no_ext)"
    fi
    
    # Convert filename to under_score_case
    filename_underscored=$(echo "$filename_no_ext" | tr ' -' '_' | tr '[:upper:]' '[:lower:]')
    debug_log "DEBUG" "Converted filename to underscore case: $filename_underscored"
    
    # Determine PARA category folder
    TARGET_PARA="00_inbox"  # Default value
    debug_log "DEBUG" "Default PARA category: $TARGET_PARA"
    
    if [[ "$PARA_TYPE" == "detect" ]]; then
        debug_log "INFO" "Auto-detecting PARA category for file: $file"
        detected=$(detect_para_category "$file")
        echo "Detected category: ${detected}"
        debug_log "INFO" "AI detected PARA category: ${detected}"
        
        case "$detected" in
            *project*)
                TARGET_PARA="01_projects"
                debug_log "DEBUG" "Mapping detected 'project' to folder: $TARGET_PARA"
                ;;
            *area*)
                TARGET_PARA="02_areas"
                debug_log "DEBUG" "Mapping detected 'area' to folder: $TARGET_PARA"
                ;;
            *resource*)
                TARGET_PARA="03_resources"
                debug_log "DEBUG" "Mapping detected 'resource' to folder: $TARGET_PARA"
                ;;
            *archive*)
                TARGET_PARA="04_archives"
                debug_log "DEBUG" "Mapping detected 'archive' to folder: $TARGET_PARA"
                ;;
            *)
                TARGET_PARA="00_inbox"
                debug_log "DEBUG" "Unrecognized category, defaulting to: $TARGET_PARA"
                ;;
        esac
        echo "Using folder: ${TARGET_PARA}"
        debug_log "INFO" "Using folder: ${TARGET_PARA}"
    else
        debug_log "DEBUG" "Using user-specified PARA category: $PARA_TYPE"
        case "$PARA_TYPE" in
            inbox)
                TARGET_PARA="00_inbox"
                ;;
            project)
                TARGET_PARA="01_projects"
                ;;
            area)
                TARGET_PARA="02_areas"
                ;;
            resource)
                TARGET_PARA="03_resources"
                ;;
            archive)
                TARGET_PARA="04_archives"
                ;;
        esac
        debug_log "DEBUG" "Mapped to folder: $TARGET_PARA"
    fi
    
    # Build target directory path
    if [[ -n "$CATEGORY" ]]; then
        TARGET_DIR="${NOTES_DIR}/${TARGET_PARA}/${CATEGORY}"
        debug_log "DEBUG" "Using subcategory path: $CATEGORY"
    else
        TARGET_DIR="${NOTES_DIR}/${TARGET_PARA}"
        debug_log "DEBUG" "No subcategory specified, using base PARA folder"
    fi
    debug_log "INFO" "Target directory: $TARGET_DIR"
    
    # Create target directory if it doesn't exist
    if [[ ! -d "$TARGET_DIR" ]]; then
        debug_log "DEBUG" "Target directory doesn't exist, creating it"
        mkdir -p "$TARGET_DIR"
        debug_log "DEBUG" "Created directory: $TARGET_DIR"
    else
        debug_log "DEBUG" "Target directory already exists"
    fi
    
    # Process file based on type
    # Determine file extension based on output mode
    file_ext=".md"
    if [[ "$NEORG_MODE" == true ]]; then
        file_ext=".norg"
        debug_log "DEBUG" "Using .norg extension due to --neorg flag"
    fi

    TARGET_FILE="${TARGET_DIR}/${filename_underscored}${file_ext}"
    debug_log "INFO" "Target file: $TARGET_FILE"
    
    # Check if the target file already exists
    if [[ -f "$TARGET_FILE" ]]; then
        # File exists - append to it
        if is_neorg_file "$file"; then
            if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                # Only for non-stdin files
                # Create temp file with content to append
                EDIT_TEMP=$(mktemp $HOME/.tmp/sbi-edit-XXXXXX)
                if [[ "$NEORG_MODE" == true ]]; then
                    echo -e "* Appended via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" > "$EDIT_TEMP"
                else
                    echo -e "# Appended via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" > "$EDIT_TEMP"
                fi
                cat "$file" >> "$EDIT_TEMP"
                
                # Edit the content directly with the editor
                ${EDITOR:-vi} "$EDIT_TEMP"
                
                # Append the edited content
                echo -e "\n" >> "$TARGET_FILE"
                cat "$EDIT_TEMP" >> "$TARGET_FILE"
                echo -e "\n" >> "$TARGET_FILE"

                # Clean up
                rm -f "$EDIT_TEMP"
                echo "Edited and appended to: $TARGET_FILE"
            else
                # Append content with a separator
                if [[ "$NEORG_MODE" == true ]]; then
                    echo -e "\n* Appended via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" >> "$TARGET_FILE"
                else
                    echo -e "\n# Appended via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" >> "$TARGET_FILE"
                fi
                cat "$file" >> "$TARGET_FILE"
                echo -e "\n" >> "$TARGET_FILE"
                if [[ "$NEORG_MODE" == true ]]; then
                    echo "Appended Neorg file to: $TARGET_FILE"
                else
                    echo "Appended Markdown file to: $TARGET_FILE"
                fi
            fi
        else
            if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                # Only for non-stdin files
                # Convert to neorg first
                CONVERT_TEMP=$(mktemp $HOME/.tmp/sbi-convert-XXXXXX)
                convert_to_neorg "$file" "$CONVERT_TEMP"

                # Add header to content
                EDIT_TEMP=$(mktemp $HOME/.tmp/sbi-edit-XXXXXX)
                if [[ "$NEORG_MODE" == true ]]; then
                    echo -e "* Appended via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" > "$EDIT_TEMP"
                else
                    echo -e "# Appended via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" > "$EDIT_TEMP"
                fi
                cat "$CONVERT_TEMP" >> "$EDIT_TEMP"

                # Edit directly with editor
                ${EDITOR:-vi} "$EDIT_TEMP"

                # Append the edited content
                echo -e "\n" >> "$TARGET_FILE"
                cat "$EDIT_TEMP" >> "$TARGET_FILE"
                echo -e "\n" >> "$TARGET_FILE"

                # Clean up
                rm -f "$CONVERT_TEMP" "$EDIT_TEMP"
                echo "Edited, converted and appended to: $TARGET_FILE"
            else
                # Convert and append with a separator
                if [[ "$NEORG_MODE" == true ]]; then
                    echo -e "\n* Appended via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" >> "$TARGET_FILE"
                else
                    echo -e "\n# Appended via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" >> "$TARGET_FILE"
                fi

                # For non-neorg files, create a temporary file for conversion
                APPEND_TEMP=$(mktemp $HOME/.tmp/sbi-append-XXXXXX)
                convert_to_neorg "$file" "$APPEND_TEMP"
                cat "$APPEND_TEMP" >> "$TARGET_FILE"
                echo -e "\n" >> "$TARGET_FILE"
                rm -f "$APPEND_TEMP"

                echo "Converted and appended to: $TARGET_FILE"
            fi
        fi
    else
        # New file
        if is_neorg_file "$file"; then
            if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                # Only edit non-stdin files here (stdin is already edited if needed)
                # Use the editor directly on a temp copy
                EDIT_TEMP=$(mktemp $HOME/.tmp/sbi-edit-XXXXXX)
                cp "$file" "$EDIT_TEMP"
                ${EDITOR:-vi} "$EDIT_TEMP"
                # Add timestamp header and copy content
                if [[ "$NEORG_MODE" == true ]]; then
                    echo -e "* Added via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" > "$TARGET_FILE"
                    cat "$EDIT_TEMP" >> "$TARGET_FILE"
                    echo -e "\n" >> "$TARGET_FILE"
                    echo "Edited and copied Neorg file to: $TARGET_FILE"
                else
                    echo -e "# Added via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" > "$TARGET_FILE"
                    cat "$EDIT_TEMP" >> "$TARGET_FILE"
                    echo -e "\n" >> "$TARGET_FILE"
                    echo "Edited and copied Markdown file to: $TARGET_FILE"
                fi
                rm -f "$EDIT_TEMP"
            else
                # Add timestamp header and copy content
                if [[ "$NEORG_MODE" == true ]]; then
                    echo -e "* Added via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" > "$TARGET_FILE"
                    cat "$file" >> "$TARGET_FILE"
                    echo -e "\n" >> "$TARGET_FILE"
                    echo "Copied Neorg file to: $TARGET_FILE"
                else
                    echo -e "# Added via 'sbi' on $(date +"%Y-%m-%d %H:%M:%S")\n" > "$TARGET_FILE"
                    cat "$file" >> "$TARGET_FILE"
                    echo -e "\n" >> "$TARGET_FILE"
                    echo "Copied Markdown file to: $TARGET_FILE"
                fi
            fi
        elif [[ -f "${file}.web_content" ]]; then
            # Process web content
            echo "Detected web content. Processing..."
            TEMP_OUTPUT=$(mktemp $HOME/.tmp/sbi-web-XXXXXX)
            
            if process_web_content "$file" "$TEMP_OUTPUT" "$filename_no_ext"; then
                # If processing succeeded, copy to target
                cp "$TEMP_OUTPUT" "$TARGET_FILE"
                echo -e "\n" >> "$TARGET_FILE"
                echo "Web content processed and ingested to: $TARGET_FILE"
                
                # Edit if requested
                if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                    ${EDITOR:-vi} "$TARGET_FILE"
                    echo "Edited web content in: $TARGET_FILE"
                fi
            else
                # If processing failed, fall back to normal conversion
                echo "Web content processing failed, falling back to standard conversion."
                convert_to_neorg "$file" "$TARGET_FILE"
                echo "Converted and ingested to: $TARGET_FILE"
            fi
            
            # Clean up
            rm -f "$TEMP_OUTPUT"
            
        elif is_audio_file "$file"; then
            # Process audio file - transcribe and summarize
            echo "Detected audio file. Processing..."
            TEMP_OUTPUT=$(mktemp $HOME/.tmp/sbi-audio-XXXXXX)
            
            if process_audio_file "$file" "$TEMP_OUTPUT" "$filename_no_ext"; then
                # If processing succeeded, copy to target
                cp "$TEMP_OUTPUT" "$TARGET_FILE"
                echo -e "\n" >> "$TARGET_FILE"
                echo "Audio processed and ingested to: $TARGET_FILE"
                
                # Edit if requested
                if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                    ${EDITOR:-vi} "$TARGET_FILE"
                    echo "Edited audio summary in: $TARGET_FILE"
                fi
            else
                # If processing failed, create an error placeholder
                echo "Audio processing failed. Creating error placeholder..."
                {
                    echo "# Failed Audio Processing: $(basename "$file")"
                    echo
                    echo "**Error:** The audio file could not be processed."
                    echo
                    echo "- **File:** $file"
                    echo "- **Date:** $(date +"%Y-%m-%d %H:%M:%S")"
                    echo "- **Reason:** Audio transcription or summary generation failed"
                    echo
                    echo "## Troubleshooting Steps"
                    echo
                    echo "1. Try running manually:"
                    echo "   \`\`\`bash"
                    echo "   transcribe_audio \"$file\""
                    echo "   \`\`\`"
                    echo
                    echo "2. Check if the audio file is valid"
                    echo "3. Ensure whisper container is running"
                    echo "4. Check available disk space"
                } > "$TARGET_FILE"
                echo "Error placeholder created at: $TARGET_FILE"
            fi
            
            # Clean up
            rm -f "$TEMP_OUTPUT"
            
            # Skip to next file to prevent double processing
            continue
            
        elif is_excel_file "$file"; then
            # Process Excel spreadsheet
            show_progress "Detected Excel spreadsheet ($(basename "$file")). Processing..."
            TEMP_OUTPUT=$(mktemp $HOME/.tmp/sbi-excel-XXXXXX)
            
            if process_excel_file "$file" "$TEMP_OUTPUT" "$filename_no_ext"; then
                # If processing succeeded, copy to target
                cp "$TEMP_OUTPUT" "$TARGET_FILE"
                echo -e "\n" >> "$TARGET_FILE"
                show_progress "Excel spreadsheet processed and ingested to: $TARGET_FILE"
                
                # Edit if requested
                if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                    ${EDITOR:-vi} "$TARGET_FILE"
                    show_progress "Edited document summary in: $TARGET_FILE"
                fi
            fi
            
            # Clean up
            rm -f "$TEMP_OUTPUT"
        elif is_generic_text_format "$file"; then
            # Process generic text format (CSV, JSON, XML)
            show_progress "Detected generic text format ($(basename "$file")). Processing..."
            TEMP_OUTPUT=$(mktemp $HOME/.tmp/sbi-text-format-XXXXXX)
            
            if process_generic_text_format "$file" "$TEMP_OUTPUT" "$filename_no_ext"; then
                # If processing succeeded, copy to target
                cp "$TEMP_OUTPUT" "$TARGET_FILE"
                echo -e "\n" >> "$TARGET_FILE"
                show_progress "Generic text format processed and ingested to: $TARGET_FILE"
                
                # Edit if requested
                if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                    ${EDITOR:-vi} "$TARGET_FILE"
                    show_progress "Edited document summary in: $TARGET_FILE"
                fi
            fi
            
            # Clean up
            rm -f "$TEMP_OUTPUT"
        elif is_email_file "$file"; then
            # Process email file (.eml or .msg)
            show_progress "Detected email file ($(basename "$file")). Processing..."
            TEMP_OUTPUT=$(mktemp $HOME/.tmp/sbi-email-XXXXXX)
            
            if process_email_file "$file" "$TEMP_OUTPUT" "$filename_no_ext"; then
                # If processing succeeded, copy to target
                cp "$TEMP_OUTPUT" "$TARGET_FILE"
                echo -e "\n" >> "$TARGET_FILE"
                show_progress "Email processed and ingested to: $TARGET_FILE"
                
                # Edit if requested
                if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                    ${EDITOR:-vi} "$TARGET_FILE"
                    show_progress "Edited email content in: $TARGET_FILE"
                fi
            else
                # If processing failed, notify user
                handle_error "$ERROR_TYPE_CONVERSION" "Failed to process email file: $file" "" "WARNING"
            fi
            
            # Clean up
            rm -f "$TEMP_OUTPUT"
            
        elif is_ebook_file "$file" || is_pdf_file "$file" || is_office_file "$file" || [[ "${file##*.}" == "md" || "${file##*.}" == "markdown" || "${file##*.}" == "MD" ]]; then
            # Process ebook, PDF, office document, or markdown file
            show_progress "Detected document file ($(basename "$file")). Processing..."
            TEMP_OUTPUT=$(mktemp $HOME/.tmp/sbi-document-XXXXXX)
            
            if process_document_content "$file" "$TEMP_OUTPUT" "$filename_no_ext"; then
                # If processing succeeded, copy to target
                cp "$TEMP_OUTPUT" "$TARGET_FILE"
                echo -e "\n" >> "$TARGET_FILE"
                show_progress "Document processed and ingested to: $TARGET_FILE"
                
                # Edit if requested
                if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                    ${EDITOR:-vi} "$TARGET_FILE"
                    show_progress "Edited document summary in: $TARGET_FILE"
                fi
            else
                # If processing failed, fall back to normal conversion
                handle_error "$ERROR_TYPE_PROCESSING" "Document processing failed, falling back to standard conversion." "" "WARNING"
                convert_to_neorg "$file" "$TARGET_FILE"
                show_progress "Converted and ingested to: $TARGET_FILE"
            fi
            
            # Clean up
            rm -f "$TEMP_OUTPUT"
            
        elif is_video_file "$file" || [[ -f "${file}.direct_audio" ]]; then
            # Process video file or direct audio from YouTube
            if [[ -f "${file}.direct_audio" ]]; then
                echo "Detected direct audio from YouTube. Processing..."
                # For direct audio from YouTube, we skip the audio extraction step
                TEMP_OUTPUT=$(mktemp $HOME/.tmp/sbi-audio-XXXXXX)
                
                echo "Processing YouTube audio: $file"
                
                # Create temp files for processing
                TRANSCRIPT_FILE=$(mktemp $HOME/.tmp/sbi-transcript-XXXXXX)
                SUMMARY_FILE=$(mktemp $HOME/.tmp/sbi-summary-XXXXXX)
                
                # Check if the audio file exists and has non-zero size
                if [[ ! -f "$file" || ! -s "$file" ]]; then
                    echo "Error: Audio file is missing or empty: $file"
                    echo "Creating a placeholder note instead."
                    {
                        echo "* YouTube Download Failure: ${filename_no_ext}"
                        echo
                        echo "Source: YouTube video"
                        if [[ -f "${file}.yturl" ]]; then
                            echo "URL: $(cat "${file}.yturl")"
                        fi
                        echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
                        [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
                        echo
                        echo "* Note"
                        echo
                        echo "There was an error downloading or processing this YouTube video."
                        echo "Please try again or manually download the content."
                    } > "$TEMP_OUTPUT"
                    cp "$TEMP_OUTPUT" "$TARGET_FILE"
                    echo -e "\n" >> "$TARGET_FILE"
                    echo "Created placeholder note at: $TARGET_FILE"
                    continue
                fi
                
                echo "Audio file exists and has content. File size: $(du -h "$file" | cut -f1)"
                echo "File type: $(file -b "$file")"
                
                # Try to transcribe the audio directly
                echo "Running transcribe_audio on: $file"
                # Build transcribe_audio command with optional arguments
                yt_transcribe_cmd="transcribe_audio"
                [[ -n "$SUMMARY_TYPE" ]] && yt_transcribe_cmd="$yt_transcribe_cmd --type $SUMMARY_TYPE"
                [[ -n "$TAGS" ]] && yt_transcribe_cmd="$yt_transcribe_cmd --tags '$TAGS'"
                yt_transcribe_cmd="$yt_transcribe_cmd \"$file\""
                
                # Run the command and capture output
                yt_transcribe_output=""
                yt_transcription_uuid=""
                if yt_transcribe_output=$(eval "$yt_transcribe_cmd" 2>&1); then
                    # Parse UUID from output if present (use tail -1 to get only the last UUID in case of duplicates)
                    if echo "$yt_transcribe_output" | grep -q "Transcription ID:"; then
                        yt_transcription_uuid=$(echo "$yt_transcribe_output" | grep "Transcription ID:" | tail -1 | sed 's/.*ID: //' | tr -d ' ')
                        echo "Captured transcription UUID: $yt_transcription_uuid"
                    fi
                fi
                
                echo "Checking for transcript file: ${file}.txt"
                if [[ -f "${file}.txt" ]]; then
                    echo "Transcript file found, moving to: $TRANSCRIPT_FILE"
                    # Transcription succeeded, move transcript to our temp file
                    cp "${file}.txt" "$TRANSCRIPT_FILE"
                    
                    # Check if transcript has content
                    if [[ -s "$TRANSCRIPT_FILE" ]]; then
                        echo "Transcript has content. Generating summary..."
                        # Generate the summary
                        run_ai_summary "$TRANSCRIPT_FILE" "$SUMMARY_FILE"
                        
                        # Check if summary was generated successfully
                        if [[ -s "$SUMMARY_FILE" ]]; then
                            echo "Summary generated successfully."
                            
                            # Create the final file with proper headers
                            {
                                echo "* YouTube Summary: ${filename_no_ext}"
                                echo
                                echo "Source: YouTube video"
                                # Add YouTube URL if available
                                if [[ -f "${file}.yturl" ]]; then
                                    echo "URL: $(cat "${file}.yturl")"
                                fi
                                echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
                                [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
                                [[ -n "$yt_transcription_uuid" ]] && echo "Transcription UUID: $yt_transcription_uuid"
                                echo
                                echo "* Summary"
                                echo
                                cat "$SUMMARY_FILE"
                            } > "$TEMP_OUTPUT"
                            
                            # Handle existing target file (append or create new)
                            if [[ -f "$TARGET_FILE" ]]; then
                                # If target exists, append with a separator
                                echo -e "\n* Appended on $(date +"%Y-%m-%d %H:%M:%S")\n" >> "$TARGET_FILE"
                                cat "$TEMP_OUTPUT" >> "$TARGET_FILE"
                                echo -e "\n" >> "$TARGET_FILE"
                                echo "YouTube summary appended to existing file: $TARGET_FILE"
                            else
                                # New file
                                cp "$TEMP_OUTPUT" "$TARGET_FILE"
                                echo -e "\n" >> "$TARGET_FILE"
                                echo "YouTube audio processed and saved to: $TARGET_FILE"
                            fi
                        else
                            echo "Summary generation failed. Creating placeholder with transcript."
                            # Create a simple note with the transcript
                            {
                                echo "* YouTube Transcript: ${filename_no_ext}"
                                echo
                                echo "Source: YouTube video"
                                # Add YouTube URL if available
                                if [[ -f "${file}.yturl" ]]; then
                                    echo "URL: $(cat "${file}.yturl")"
                                fi
                                echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
                                [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
                                [[ -n "$yt_transcription_uuid" ]] && echo "Transcription UUID: $yt_transcription_uuid"
                                echo
                                echo "* Transcript"
                                echo
                                cat "$TRANSCRIPT_FILE"
                            } > "$TEMP_OUTPUT"

                            # Save it
                            cp "$TEMP_OUTPUT" "$TARGET_FILE"
                            echo -e "\n" >> "$TARGET_FILE"
                            echo "Transcript saved to: $TARGET_FILE"
                        fi
                    else
                        echo "Transcript file is empty. Creating placeholder note."
                        # Create a simple note indicating failure
                        {
                            echo "* YouTube Processing Issue: ${filename_no_ext}"
                            echo
                            echo "Source: YouTube video"
                            # Add YouTube URL if available
                            if [[ -f "${file}.yturl" ]]; then
                                echo "URL: $(cat "${file}.yturl")"
                            fi
                            echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
                            [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
                            [[ -n "$yt_transcription_uuid" ]] && echo "Transcription UUID: $yt_transcription_uuid"
                            echo
                            echo "* Note"
                            echo
                            echo "The audio was downloaded, but transcription failed to produce content."
                            echo "The downloaded audio file is located at: $file"
                        } > "$TEMP_OUTPUT"

                        # Save it
                        cp "$TEMP_OUTPUT" "$TARGET_FILE"
                        echo -e "\n" >> "$TARGET_FILE"
                        echo "Created placeholder note at: $TARGET_FILE"
                    fi

                    # Clean up
                    rm -f "$TRANSCRIPT_FILE" "$SUMMARY_FILE"
                else
                    # No transcript file found
                    echo "No transcript file found. Creating placeholder note."
                    {
                        echo "* YouTube Processing Issue: ${filename_no_ext}"
                        echo
                        echo "Source: YouTube video"
                        # Add YouTube URL if available
                        if [[ -f "${file}.yturl" ]]; then
                            echo "URL: $(cat "${file}.yturl")"
                        fi
                        echo "Processed on: $(date +"%Y-%m-%d %H:%M:%S")"
                        [[ -n "$TAGS" ]] && echo "Tags: $TAGS"
                        echo
                        echo "* Note"
                        echo
                        echo "The audio was downloaded successfully, but the transcription process failed."
                        echo "The downloaded audio file is located at: $file"
                        echo 
                        echo "You can try to manually transcribe this file by running:"
                        echo "@code bash"
                        echo "transcribe_audio \"$file\""
                        echo "@end"
                    } > "$TEMP_OUTPUT"

                    # Save it
                    cp "$TEMP_OUTPUT" "$TARGET_FILE"
                    echo -e "\n" >> "$TARGET_FILE"
                    echo "Created placeholder note at: $TARGET_FILE"
                fi

                # Edit if requested
                if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                    ${EDITOR:-vi} "$TARGET_FILE"
                    echo "Edited YouTube audio summary in: $TARGET_FILE"
                fi
                
                # Clean up
                rm -f "$TEMP_OUTPUT"
            else
                # Regular video file - strip audio, transcribe, and summarize
                echo "Detected video file. Processing..."
                TEMP_OUTPUT=$(mktemp $HOME/.tmp/sbi-video-XXXXXX)
                
                if process_video_file "$file" "$TEMP_OUTPUT" "$filename_no_ext"; then
                    # If processing succeeded, copy to target
                    cp "$TEMP_OUTPUT" "$TARGET_FILE"
                    echo -e "\n" >> "$TARGET_FILE"
                    echo "Video processed and ingested to: $TARGET_FILE"
                    
                    # Edit if requested
                    if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                        ${EDITOR:-vi} "$TARGET_FILE"
                        echo "Edited video summary in: $TARGET_FILE"
                    fi
                else
                    # If processing failed, create an error placeholder
                    echo "Video processing failed. Creating error placeholder..."
                    {
                        echo "# Failed Video Processing: $(basename "$file")"
                        echo
                        echo "**Error:** The video file could not be processed."
                        echo
                        echo "- **File:** $file"
                        echo "- **Date:** $(date +"%Y-%m-%d %H:%M:%S")"
                        echo "- **Reason:** Video transcription or summary generation failed"
                        echo
                        echo "## Troubleshooting Steps"
                        echo
                        echo "1. Try extracting audio manually:"
                        echo "   \`\`\`bash"
                        echo "   strip_audio \"$file\" output.ogg"
                        echo "   transcribe_audio output.ogg"
                        echo "   \`\`\`"
                        echo
                        echo "2. Check if the video file is valid"
                        echo "3. Ensure ffmpeg is available"
                        echo "4. Check available disk space"
                    } > "$TARGET_FILE"
                    echo "Error placeholder created at: $TARGET_FILE"
                fi
                
                # Clean up
                rm -f "$TEMP_OUTPUT"
            fi
            
        else
            # For plain text files, process with AI summary instead of just wrapping in code blocks
            if [[ "${file##*.}" == "txt" || -z "${file##*.}" ]]; then
                # Process as plain text with AI summary
                echo "Detected plain text file: $file (extension: ${file##*.})"
                echo "Using AI summarization..."
                TEMP_DIR=$(mktemp -d "${HOME}/.tmp/sbi-plain-text-XXXXXX")
                TEMP_OUTPUT="${TEMP_DIR}/output${file_ext}"
                
                # If sanitize mode is enabled, pipe through sanitize_data
                if [[ "$SANITIZE_MODE" == true ]]; then
                    debug_log "INFO" "Sanitizing plain text content using sanitize_data"
                    cat "$file" | sanitize_data | run_ai_summary "/dev/stdin" "$TEMP_OUTPUT"
                else
                    run_ai_summary "$file" "$TEMP_OUTPUT"
                fi
                
                # Copy to final destination
                cp "$TEMP_OUTPUT" "$TARGET_FILE"
                echo -e "\n" >> "$TARGET_FILE"

                # Edit if requested
                if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                    ${EDITOR:-vi} "$TARGET_FILE"
                    echo "Summarized, edited and ingested to: $TARGET_FILE"
                else
                    echo "Summarized and ingested to: $TARGET_FILE"
                fi
                
                # Clean up
                rm -rf "$TEMP_DIR"
            else
                # Standard conversion for other file types
                convert_to_neorg "$file" "$TARGET_FILE"
                
                # Edit non-stdin files after conversion if requested
                if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                    ${EDITOR:-vi} "$TARGET_FILE"
                    echo "Converted, edited and ingested to: $TARGET_FILE"
                else
                    echo "Converted and ingested to: $TARGET_FILE"
                fi
            fi
        fi
    fi
done

# Cleanup section
debug_log "INFO" "Starting cleanup phase"

# Clean up temporary file if we used stdin mode
if [[ "$STDIN_MODE" == true && -n "$TEMP_FILE" && -f "$TEMP_FILE" ]]; then
    debug_log "DEBUG" "Removing temporary stdin file: $TEMP_FILE"
    rm -f "$TEMP_FILE"
fi

# Clean up YouTube temporary directory if it exists
if [[ -n "${YT_TEMP_DIR:-}" && -d "${YT_TEMP_DIR}" ]]; then
    debug_log "DEBUG" "Removing YouTube temporary directory: $YT_TEMP_DIR"
    # Remove all files, including any metadata files (*.yturl)
    rm -rf "${YT_TEMP_DIR}"
fi

# Clean up web content temporary directory if it exists
if [[ -n "${WEB_TEMP_DIR:-}" && -d "${WEB_TEMP_DIR}" ]]; then
    debug_log "DEBUG" "Removing web content temporary directory: $WEB_TEMP_DIR"
    # Remove all files, including any metadata files (*.url, *.title)
    rm -rf "${WEB_TEMP_DIR}"
fi

debug_log "INFO" "SBI execution completed successfully"
