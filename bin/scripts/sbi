#!/bin/bash
set -euo pipefail

# sbi - Second Brain Ingest
# Script to ingest files into a second brain organized with PARA structure

NOTES_DIR="$HOME/Documents/notes"
DEFAULT_PARA="00_inbox"
PARA_MAP=("00_inbox" "01_projects" "02_areas" "03_resources" "04_archives")

show_help() {
    cat << EOF
Usage: sbi [OPTIONS] FILE1 [FILE2 ...]

Ingest files into second brain with PARA organization.

Options:
  -h, --help              Show this help message
  -p, --para CATEGORY     Specify PARA category (inbox, project, area, resource, archive, detect)
  -c, --category PATH     Specify subcategory path (e.g., "personal" or "technical/linux")
  -l, --list              List the second brain directory structure
  -L, --list-files        List the second brain directory structure including files
  -f, --full-path         Show full paths in directory listings
  --format FORMAT         Specify format for stdin content (e.g., "txt", "md", "json")
  -e, --edit              Edit content before writing to file
  --name-seed NAME        Use NAME as seed for filename (for stdin content)

Examples:
  sbi document.md                          # Ingest to inbox
  sbi --para project document.md           # Ingest to projects
  sbi --para resource --category technical/linux document.md  # Ingest to specific path
  sbi --para detect document.md            # Auto-detect PARA category
  sbi --list                               # List directory structure
  echo "* My neorg content" | sbi          # Pipe neorg content directly
  cat data.json | sbi --format json        # Pipe content with specified format
  echo "Draft note" | sbi --edit           # Open editor to modify before saving
  echo "Meeting notes" | sbi --name-seed "team meeting" # Use custom filename
EOF
    exit 0
}

list_structure() {
    local filter_para=""
    local filter_category=""
    local include_files=false
    local show_full_path=false
    
    # Parse arguments for filtering
    if [[ $# -ge 1 ]]; then
        filter_para="$1"
    fi
    
    if [[ $# -ge 2 ]]; then
        filter_category="$2"
    fi
    
    if [[ $# -ge 3 && "$3" == "true" ]]; then
        include_files=true
    fi
    
    if [[ $# -ge 4 && "$4" == "true" ]]; then
        show_full_path=true
    fi
    
    if ! command -v find &> /dev/null || ! command -v sort &> /dev/null; then
        echo "Error: Required tools 'find' and 'sort' not found."
        exit 1
    fi
    
    echo "Second Brain Structure at: $NOTES_DIR"
    
    # Make sure NOTES_DIR exists
    if [[ ! -d "$NOTES_DIR" ]]; then
        echo "Error: Notes directory '$NOTES_DIR' does not exist."
        exit 1
    fi
    
    # Map PARA type to folder name
    local target_para=""
    if [[ -n "$filter_para" ]]; then
        case "$filter_para" in
            inbox)
                target_para="00_inbox"
                ;;
            project)
                target_para="01_projects"
                ;;
            area)
                target_para="02_areas"
                ;;
            resource)
                target_para="03_resources"
                ;;
            archive)
                target_para="04_archives"
                ;;
            *)
                echo "Error: Invalid PARA type. Must be one of: inbox, project, area, resource, archive"
                exit 1
                ;;
        esac
        
        # Check if the PARA directory exists
        if [[ ! -d "$NOTES_DIR/$target_para" ]]; then
            echo "Error: PARA directory '$target_para' does not exist."
            exit 1
        fi
        
        # If category is specified, check if that path exists
        if [[ -n "$filter_category" ]]; then
            local category_path="$NOTES_DIR/$target_para/$filter_category"
            if [[ ! -d "$category_path" ]]; then
                echo "Error: Category path '$filter_category' does not exist under '$target_para'."
                exit 1
            fi
            
            # Print filtered directory structure with category
            echo "Directory structure for $target_para/$filter_category:"
            
            # List all directories under the specified category
            if [[ "$show_full_path" == true ]]; then
                echo "$target_para/$filter_category/"
            fi
            
            # Start with base indentation level based on category depth
            local base_depth=$(echo "$filter_category" | tr -cd '/' | wc -c)
            
            # Find type based on whether to include files
            local find_type="-type d"
            if [[ "$include_files" == true ]]; then
                find_type=""  # No type filter to include both files and directories
            fi
            
            # List directories and optionally files under the specified category
            find "$category_path" $find_type -print | sort | while read -r path; do
                # Skip the category directory itself
                if [[ "$path" == "$category_path" ]]; then
                    continue
                fi
                
                # Get relative path from category directory
                rel_path="${path#$category_path/}"
                
                # Skip empty entries
                if [[ -z "$rel_path" ]]; then
                    continue
                fi
                
                # Calculate directory depth for indentation (relative to category)
                depth=$(echo "$rel_path" | tr -cd '/' | wc -c)
                indent=$(printf '%*s' "$((depth*2))" '')
                
                # Determine what to display based on full path option
                if [[ "$show_full_path" == true ]]; then
                    # Show the full path from the notes directory
                    display_path="${path#$NOTES_DIR/}"
                    
                    if [[ -d "$path" ]]; then
                        echo "${display_path}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${display_path}"
                    fi
                else
                    # Show just the item name with indentation
                    item_name=$(basename "$path")
                    
                    if [[ -d "$path" ]]; then
                        echo "${indent}${item_name}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${indent}${item_name}"
                    fi
                fi
            done
        else
            # Print filtered directory structure for PARA only
            echo "Directory structure for $target_para:"
            
            # List PARA directory itself when using full path
            if [[ "$show_full_path" == true ]]; then
                echo "$target_para/"
            fi
            
            # Find type based on whether to include files
            local find_type="-type d"
            if [[ "$include_files" == true ]]; then
                find_type=""  # No type filter to include both files and directories
            fi
            
            # List directories and optionally files under the specified PARA
            find "$NOTES_DIR/$target_para" -mindepth 1 $find_type -print | sort | while read -r path; do
                # Get relative path from PARA directory
                rel_path="${path#$NOTES_DIR/$target_para/}"
                
                # Skip empty entries
                if [[ -z "$rel_path" ]]; then
                    continue
                fi
                
                # Calculate directory depth for indentation
                depth=$(echo "$rel_path" | tr -cd '/' | wc -c)
                indent=$(printf '%*s' "$((depth*2))" '')
                
                # Determine what to display based on full path option
                if [[ "$show_full_path" == true ]]; then
                    # Show the full path from the notes directory
                    display_path="${path#$NOTES_DIR/}"
                    
                    if [[ -d "$path" ]]; then
                        echo "${display_path}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${display_path}"
                    fi
                else
                    # Show just the item name with indentation
                    item_name=$(basename "$path")
                    
                    if [[ -d "$path" ]]; then
                        echo "${indent}${item_name}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${indent}${item_name}"
                    fi
                fi
            done
        fi
    else
        # Show full directory structure (all PARA folders)
        echo "Directory structure:"
        
        # List all PARA directories
        for para in 00_inbox 01_projects 02_areas 03_resources 04_archives; do
            para_dir="$NOTES_DIR/$para"
            
            # Skip if the directory doesn't exist
            if [[ ! -d "$para_dir" ]]; then
                continue
            fi
            
            # Print the top-level PARA folder, optionally with full path
            if [[ "$show_full_path" == true ]]; then
                echo "$para/"
            else
                echo "$para"
            fi
            
            # Find type based on whether to include files
            local find_type="-type d"
            if [[ "$include_files" == true ]]; then
                find_type=""  # No type filter to include both files and directories
            fi
            
            # List directories and optionally files with proper indentation
            find "$para_dir" -mindepth 1 $find_type -print | sort | while read -r path; do
                # Get relative path from PARA directory
                rel_path="${path#$para_dir/}"
                
                # Skip empty entries
                if [[ -z "$rel_path" ]]; then
                    continue
                fi
                
                # Calculate directory depth for indentation
                depth=$(echo "$rel_path" | tr -cd '/' | wc -c)
                indent=$(printf '%*s' "$((depth*2 + 2))" '')
                
                # Determine what to display based on full path option
                if [[ "$show_full_path" == true ]]; then
                    # Show the full path from the notes directory
                    display_path="${path#$NOTES_DIR/}"
                    
                    if [[ -d "$path" ]]; then
                        echo "${display_path}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${display_path}"
                    fi
                else
                    # Show just the item name with indentation
                    item_name=$(basename "$path")
                    
                    if [[ -d "$path" ]]; then
                        echo "${indent}${item_name}/"
                    elif [[ "$include_files" == true ]]; then
                        echo "${indent}${item_name}"
                    fi
                fi
            done
        done
    fi
    
    exit 0
}

detect_para_category() {
    local file="$1"
    local content
    
    # Check if perpy exists
    if ! command -v perpy &> /dev/null; then
        echo "Error: 'perpy' script not found. Defaulting to inbox."
        echo "inbox"
        return
    fi
    
    content=$(cat "$file")
    
    # Ask perpy to determine the PARA category
    local category
    local query="Please analyze this content and determine which PARA category it belongs to. Respond with EXACTLY ONE WORD from these options: project, area, resource, archive. DO NOT include any explanation.\n\n${content}"

    # Handle response from perpy more carefully
    category=$(perpy <<< "${query}" | tr -d '\n' | tr '[:upper:]' '[:lower:]' | xargs)
    
    # Validate and clean response
    case "$category" in
        *project*)
            echo "project"
            ;;
        *area*)
            echo "area"
            ;;
        *resource*)
            echo "resource"
            ;;
        *archive*)
            echo "archive"
            ;;
        *)
            echo "inbox"
            ;;
    esac
}

# Function to edit content using vipe if edit flag is set
edit_with_vipe() {
    local input_file="$1"
    local output_file="$2"
    
    if [[ "$EDIT_FLAG" == true ]]; then
        # Check if vipe is installed
        if ! command -v vipe &> /dev/null; then
            echo "Warning: 'vipe' utility not found. Skipping edit phase."
            cp "$input_file" "$output_file"
            return
        fi
        
        # Use vipe to edit the content with proper redirection
        # Try using EDITOR directly if vipe fails
        if ! cat "$input_file" | vipe > "$output_file" 2>/dev/null; then
            # Fall back to using the default editor directly
            EDIT_TMP="$input_file"
            ${EDITOR:-vi} "$EDIT_TMP"
            cp "$EDIT_TMP" "$output_file"
        fi
    else
        # No edit requested, just copy
        cp "$input_file" "$output_file"
    fi
}

convert_to_neorg() {
    local input_file="$1"
    local output_file="$2"
    local file_ext="${input_file##*.}"
    local temp_output
    
    # Special case for stdin with format already specified or any stdin in edit mode
    if [[ "$STDIN_MODE" == true && "$input_file" == "$TEMP_FILE" ]]; then
        # Just copy the content as-is - we've already handled editing in the stdin processing 
        # and/or formatted it as a code block
        cp "$input_file" "$output_file"
        return 0
    fi
    
    if [[ "$file_ext" == "md" || "$file_ext" == "markdown" || "$file_ext" == "MD" ]]; then
        # Check if mton exists
        if command -v mton &> /dev/null; then
            # Create temp file for intermediate result
            temp_output=$(mktemp /tmp/sbi-convert-XXXXXX)
            
            # Read the content and pass it to mton
            local content
            content=$(cat "$input_file")
            mton <<< "${content}" > "$temp_output"
            
            # Edit if requested
            if [[ "$EDIT_FLAG" == true ]]; then
                edit_with_vipe "$temp_output" "$output_file"
            else
                cp "$temp_output" "$output_file"
            fi
            
            # Clean up
            rm -f "$temp_output"
            return 0
        else
            echo "Warning: 'mton' script not found for Markdown conversion. Falling back to code block."
        fi
    fi
    
    # For all other formats, put content in a code block
    temp_output=$(mktemp /tmp/sbi-convert-XXXXXX)
    
    {
        echo "@code $file_ext"
        cat "$input_file"
        echo "@end"
    } > "$temp_output"
    
    # Edit if requested
    if [[ "$EDIT_FLAG" == true ]]; then
        edit_with_vipe "$temp_output" "$output_file"
    else
        cp "$temp_output" "$output_file"
    fi
    
    # Clean up
    rm -f "$temp_output"
}

is_neorg_file() {
    local file="$1"
    local file_ext="${file##*.}"
    
    # Check if it's a .norg file by extension
    if [[ "$file_ext" == "norg" ]]; then
        return 0
    fi
    
    # If it's our temp file from stdin AND no format was specified,
    # we assume it's already in neorg format
    if [[ "$STDIN_MODE" == true && "$file" == "$TEMP_FILE" && -z "$STDIN_FORMAT" ]]; then
        return 0
    fi
    
    # Even if format is specified for stdin, the convert_to_neorg function
    # will handle it properly, so no need for special case here
    
    # Otherwise, not a neorg file
    return 1
}

# Parse arguments
PARA_TYPE="inbox"
CATEGORY=""
FILES=()
LIST_FLAG=false
LIST_FILES_FLAG=false
FULL_PATH_FLAG=false
STDIN_MODE=false
TEMP_FILE=""
STDIN_FORMAT=""  # Format for stdin content
EDIT_FLAG=false  # Flag to enable editing
NAME_SEED=""     # Custom filename seed for stdin content

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            ;;
        -l|--list)
            # Capture the list flag - we'll process it after parsing all arguments
            LIST_FLAG=true
            shift
            ;;
        -L|--list-files)
            # Capture the list-files flag - we'll process it after parsing all arguments
            LIST_FILES_FLAG=true
            shift
            ;;
        -f|--full-path)
            # Capture the full-path flag
            FULL_PATH_FLAG=true
            shift
            ;;
        --format)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo "Error: --format requires an argument"
                exit 1
            fi
            STDIN_FORMAT="$2"
            shift 2
            ;;
        --name-seed)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo "Error: --name-seed requires an argument"
                exit 1
            fi
            NAME_SEED="$2"
            shift 2
            ;;
        -e|--edit)
            EDIT_FLAG=true
            shift
            ;;
        -p|--para)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo "Error: --para requires an argument"
                exit 1
            fi
            case "$2" in
                inbox|project|area|resource|archive|detect)
                    PARA_TYPE="$2"
                    ;;
                *)
                    echo "Error: Invalid PARA type. Must be one of: inbox, project, area, resource, archive, detect"
                    exit 1
                    ;;
            esac
            shift 2
            ;;
        -c|--category)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo "Error: --category requires an argument"
                exit 1
            fi
            CATEGORY="$2"
            shift 2
            ;;
        *)
            if [[ -f "$1" ]]; then
                FILES+=("$1")
            else
                echo "Error: '$1' is not a valid file!"
                exit 1
            fi
            shift
            ;;
    esac
done

# Process list flags if set
if [[ "$LIST_FLAG" == true || "$LIST_FILES_FLAG" == true ]]; then
    # Determine include_files value based on which flag was used
    include_files="false"
    if [[ "$LIST_FILES_FLAG" == true ]]; then
        include_files="true"
    fi
    
    # Convert PARA_TYPE to format expected by list_structure
    if [[ -n "$PARA_TYPE" && "$PARA_TYPE" != "detect" && "$PARA_TYPE" != "inbox" ]]; then
        # Use specified PARA type
        list_structure "$PARA_TYPE" "$CATEGORY" "$include_files" "$FULL_PATH_FLAG"
    else
        # If para type is not specified, is "detect", or is the default "inbox",
        # show all PARA folders (full listing)
        list_structure "" "" "$include_files" "$FULL_PATH_FLAG"
    fi
fi

# Check if at least one file is provided or if we have stdin input, only if we're not listing
if [[ ${#FILES[@]} -eq 0 && "$LIST_FLAG" == false && "$LIST_FILES_FLAG" == false ]]; then
    # Check if there's data on stdin (not a terminal)
    if [ -t 0 ]; then
        # No stdin input
        echo "Error: No input files specified and no content provided via stdin"
        show_help
    else
        # We have stdin input; create a temporary file
        TEMP_FILE=$(mktemp /tmp/sbi-stdin-XXXXXX)
        
        # Handle different formats first
        if [[ -n "$STDIN_FORMAT" ]]; then
            # If format is specified, create a code block with that format
            {
                echo "@code $STDIN_FORMAT"
                cat
                echo "@end"
            } > "$TEMP_FILE"
        else
            # Default: assume content is already in neorg format
            cat > "$TEMP_FILE"
        fi
        
        # If edit is requested, let the user edit directly with their editor
        if [[ "$EDIT_FLAG" == true ]]; then
            # Rather than using vipe, use the editor directly on the temp file
            ${EDITOR:-vi} "$TEMP_FILE"
        fi
        
        FILES=("$TEMP_FILE")
        # Flag to indicate this file should be removed after processing
        STDIN_MODE=true
    fi
else
    STDIN_MODE=false
fi

# Process each file
for file in "${FILES[@]}"; do
    if [[ ! -f "$file" ]]; then
        echo "Warning: File does not exist or is not a regular file: $file"
        continue
    fi
    
    # Generate filename - for stdin use name seed or date-based name
    if [[ "$STDIN_MODE" == true && "$file" == "$TEMP_FILE" ]]; then
        if [[ -n "$NAME_SEED" ]]; then
            # Use the provided name seed
            filename="$NAME_SEED"
            filename_no_ext="$filename"
        else
            # For stdin content with no name seed, use just the date as filename
            current_date=$(date +"%Y-%m-%d")
            filename="${current_date}"
            filename_no_ext="$filename"
        fi
    else
        filename=$(basename "$file")
        filename_no_ext="${filename%.*}"
    fi
    
    # Convert filename to under_score_case
    filename_underscored=$(echo "$filename_no_ext" | tr ' -' '_' | tr '[:upper:]' '[:lower:]')
    
    # Determine PARA category folder
    TARGET_PARA="00_inbox"  # Default value
    if [[ "$PARA_TYPE" == "detect" ]]; then
        detected=$(detect_para_category "$file")
        echo "Detected category: ${detected}"
        case "$detected" in
            *project*)
                TARGET_PARA="01_projects"
                ;;
            *area*)
                TARGET_PARA="02_areas"
                ;;
            *resource*)
                TARGET_PARA="03_resources"
                ;;
            *archive*)
                TARGET_PARA="04_archives"
                ;;
            *)
                TARGET_PARA="00_inbox"
                ;;
        esac
        echo "Using folder: ${TARGET_PARA}"
    else
        case "$PARA_TYPE" in
            inbox)
                TARGET_PARA="00_inbox"
                ;;
            project)
                TARGET_PARA="01_projects"
                ;;
            area)
                TARGET_PARA="02_areas"
                ;;
            resource)
                TARGET_PARA="03_resources"
                ;;
            archive)
                TARGET_PARA="04_archives"
                ;;
        esac
    fi
    
    # Build target directory path
    if [[ -n "$CATEGORY" ]]; then
        TARGET_DIR="${NOTES_DIR}/${TARGET_PARA}/${CATEGORY}"
    else
        TARGET_DIR="${NOTES_DIR}/${TARGET_PARA}"
    fi
    
    # Create target directory if it doesn't exist
    mkdir -p "$TARGET_DIR"
    
    # Process file based on type
    TARGET_FILE="${TARGET_DIR}/${filename_underscored}.norg"
    
    # Check if the target file already exists
    if [[ -f "$TARGET_FILE" ]]; then
        # File exists - append to it
        if is_neorg_file "$file"; then
            if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                # Only for non-stdin files
                # Create temp file with content to append
                EDIT_TEMP=$(mktemp /tmp/sbi-edit-XXXXXX)
                echo -e "* Appended on $(date +"%Y-%m-%d %H:%M:%S")\n" > "$EDIT_TEMP"
                cat "$file" >> "$EDIT_TEMP"
                
                # Edit the content directly with the editor
                ${EDITOR:-vi} "$EDIT_TEMP"
                
                # Append the edited content
                echo -e "\n" >> "$TARGET_FILE"
                cat "$EDIT_TEMP" >> "$TARGET_FILE"
                
                # Clean up
                rm -f "$EDIT_TEMP"
                echo "Edited and appended to: $TARGET_FILE"
            else
                # If source is already a neorg file, append its content with a separator
                echo -e "\n* Appended on $(date +"%Y-%m-%d %H:%M:%S")\n" >> "$TARGET_FILE"
                cat "$file" >> "$TARGET_FILE"
                echo "Appended Neorg file to: $TARGET_FILE"
            fi
        else
            if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                # Only for non-stdin files
                # Convert to neorg first
                CONVERT_TEMP=$(mktemp /tmp/sbi-convert-XXXXXX)
                convert_to_neorg "$file" "$CONVERT_TEMP"
                
                # Add header to content
                EDIT_TEMP=$(mktemp /tmp/sbi-edit-XXXXXX)
                echo -e "* Appended on $(date +"%Y-%m-%d %H:%M:%S")\n" > "$EDIT_TEMP"
                cat "$CONVERT_TEMP" >> "$EDIT_TEMP"
                
                # Edit directly with editor
                ${EDITOR:-vi} "$EDIT_TEMP"
                
                # Append the edited content
                echo -e "\n" >> "$TARGET_FILE"
                cat "$EDIT_TEMP" >> "$TARGET_FILE"
                
                # Clean up
                rm -f "$CONVERT_TEMP" "$EDIT_TEMP"
                echo "Edited, converted and appended to: $TARGET_FILE"
            else
                # Convert to neorg and append with a separator
                echo -e "\n* Appended on $(date +"%Y-%m-%d %H:%M:%S")\n" >> "$TARGET_FILE"
                
                # For non-neorg files, create a temporary file for conversion
                APPEND_TEMP=$(mktemp /tmp/sbi-append-XXXXXX)
                convert_to_neorg "$file" "$APPEND_TEMP"
                cat "$APPEND_TEMP" >> "$TARGET_FILE"
                rm -f "$APPEND_TEMP"
                
                echo "Converted and appended to: $TARGET_FILE"
            fi
        fi
    else
        # New file
        if is_neorg_file "$file"; then
            if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                # Only edit non-stdin files here (stdin is already edited if needed)
                # Use the editor directly on a temp copy
                EDIT_TEMP=$(mktemp /tmp/sbi-edit-XXXXXX)
                cp "$file" "$EDIT_TEMP"
                ${EDITOR:-vi} "$EDIT_TEMP"
                cp "$EDIT_TEMP" "$TARGET_FILE"
                rm -f "$EDIT_TEMP"
                echo "Edited and copied Neorg file to: $TARGET_FILE"
            else
                # Just copy
                cp "$file" "$TARGET_FILE"
                echo "Copied Neorg file to: $TARGET_FILE"
            fi
        else
            # Convert to neorg
            convert_to_neorg "$file" "$TARGET_FILE"
            
            # Edit non-stdin files after conversion if requested
            if [[ "$EDIT_FLAG" == true && "$STDIN_MODE" == false ]]; then
                ${EDITOR:-vi} "$TARGET_FILE"
                echo "Converted, edited and ingested to: $TARGET_FILE"
            else
                echo "Converted and ingested to: $TARGET_FILE"
            fi
        fi
    fi
done

# Clean up temporary file if we used stdin mode
if [[ "$STDIN_MODE" == true && -n "$TEMP_FILE" && -f "$TEMP_FILE" ]]; then
    rm -f "$TEMP_FILE"
fi
