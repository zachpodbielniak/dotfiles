#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;

#------------------------------------------------------------------------------
# mton_ast - AST-based Markdown to Neorg converter
#------------------------------------------------------------------------------
# 
# This script converts Markdown formatted text to Neorg format.
# It uses a block-by-block approach to handle Markdown structures.

# Options
my $input_file = '';
my $output_file = '';
my $help = 0;
my $debug = 0;

# Process command line arguments
GetOptions(
    "input|i=s" => \$input_file,
    "output|o=s" => \$output_file,
    "help|h" => \$help,
    "debug|d" => \$debug
) or pod2usage(1);

pod2usage(1) if $help;

# Set up input/output filehandles
my $input_fh = $input_file ? do { open my $fh, '<:encoding(UTF-8)', $input_file or die "Can't open $input_file: $!"; $fh } : \*STDIN;
my $output_fh = $output_file ? do { open my $fh, '>:encoding(UTF-8)', $output_file or die "Can't open $output_file for writing: $!"; $fh } : \*STDOUT;

# Set UTF-8 encoding for STDIN/STDOUT when not using files
binmode(STDIN, ':encoding(UTF-8)');
binmode(STDOUT, ':encoding(UTF-8)');

# Read the entire input
my $input = do { local $/; <$input_fh> };

# Pre-process reference-style links
my %reference_links;
$input =~ s/^\s*\[([^\]]+)\]:\s+(\S+)(?:\s+["'](.+?)["'])?\s*$/{
    $reference_links{lc($1)} = {url => $2, title => $3 || ''};
    '';
}/egm;

# Parse blocks
my @blocks = split_into_blocks($input);
my $output = '';

foreach my $block (@blocks) {
    $output .= process_block($block, \%reference_links);
}

# Fix escaped braces in image links
$output =~ s/\\\{/{/g;

# Write output
print $output_fh $output;

# Close filehandles
close($input_fh) if $input_file;
close($output_fh) if $output_file;

exit 0;

#------------------------------------------------------------------------------
# Parsing Functions
#------------------------------------------------------------------------------
sub split_into_blocks {
    my ($text) = @_;
    my @blocks;
    my $current_block = '';
    my $in_code_block = 0;
    
    # Normalize line endings
    $text =~ s/\r\n/\n/g;
    $text =~ s/\r/\n/g;
    
    foreach my $line (split /\n/, $text) {
        # Handle code blocks
        if ($line =~ /^(```|~~~)/) {
            if (!$in_code_block) {
                # Start of code block
                push @blocks, $current_block if $current_block =~ /\S/;
                $current_block = $line . "\n";
                $in_code_block = 1;
            } else {
                # End of code block
                $current_block .= $line . "\n";
                push @blocks, $current_block;
                $current_block = '';
                $in_code_block = 0;
            }
            next;
        }
        
        # Inside code block - collect lines
        if ($in_code_block) {
            $current_block .= $line . "\n";
            next;
        }
        
        # Empty line - end current block
        if ($line =~ /^\s*$/) {
            push @blocks, $current_block if $current_block =~ /\S/;
            $current_block = '';
            next;
        }
        
        # Add to current block
        $current_block .= $line . "\n";
    }
    
    # Add the last block if any
    push @blocks, $current_block if $current_block =~ /\S/;
    
    return @blocks;
}

sub process_block {
    my ($block, $references) = @_;
    my $result = '';
    
    # Trim trailing newlines
    $block =~ s/\n+$//;
    
    # Check if block contains multiple lines that might be headings
    if ($block =~ /^#/) {
        my @lines = split(/\n/, $block);
        my $all_headings = 1;
        
        # Check if all lines are headings
        foreach my $line (@lines) {
            if ($line !~ /^(#{1,6})\s+(.+?)(?:\s+#{0,6})?$/ && $line =~ /\S/) {
                $all_headings = 0;
                last;
            }
        }
        
        # If all lines are headings, process each one
        if ($all_headings) {
            foreach my $line (@lines) {
                if ($line =~ /^(#{1,6})\s+(.+?)(?:\s+#{0,6})?$/) {
                    my $level = length($1);
                    my $content = $2;
                    $result .= ('*' x $level) . ' ' . process_inline($content, $references) . "\n";
                }
            }
            $result .= "\n";
            return $result;
        }
    }
    
    # Single heading (original logic)
    if ($block =~ /^(#{1,6})\s+(.+?)(?:\s+#{0,6})?$/) {
        my $level = length($1);
        my $content = $2;
        $result = ('*' x $level) . ' ' . process_inline($content, $references) . "\n\n";
    }
    # Alternative Headings (=== or --- style)
    elsif ($block =~ /^(.+?)\n([=]+|[-]+)\s*$/) {
        my $content = $1;
        my $level = ($2 =~ /^=/) ? 1 : 2;
        $result = ('*' x $level) . ' ' . process_inline($content, $references) . "\n\n";
    }
    # Code blocks
    elsif ($block =~ /^(```|~~~)(.*)$(.*?)^\1$/ms) {
        my $lang = $2;
        my $code = $3;
        $code =~ s/^\n//; # Remove leading newline
        $result = "\@code";
        $result .= " $lang" if $lang =~ /\S/;
        $result .= "\n$code\n\@end\n\n";
    }
    # Blockquotes
    elsif ($block =~ /^>\s/) {
        $result = "\@quote\n";
        my @lines = split(/\n/, $block);
        foreach my $line (@lines) {
            $line =~ s/^>\s?//;
            $result .= process_inline($line, $references) . "\n";
        }
        $result .= "\@end\n\n";
    }
    # Unordered lists with task items
    elsif ($block =~ /^[-*+]\s+\[[ xX]\]/) {
        my @lines = split(/\n/, $block);
        foreach my $line (@lines) {
            if ($line =~ /^([ \t]*)[-*+]\s+\[([ xX])\]\s+(.*)$/) {
                my $indent = $1;
                my $status = lc($2);
                my $content = $3;
                $result .= "$indent- " . (($status eq 'x') ? "(x) " : "( ) ") . process_inline($content, $references) . "\n";
            } else {
                $result .= $line . "\n";
            }
        }
        $result .= "\n";
    }
    # Regular unordered lists
    elsif ($block =~ /^[-*+]\s/) {
        my @lines = split(/\n/, $block);
        foreach my $line (@lines) {
            if ($line =~ /^([ \t]*)[-*+]\s+(.*)$/) {
                my $indent = $1;
                my $content = $2;
                $result .= "$indent- " . process_inline($content, $references) . "\n";
            } else {
                $result .= $line . "\n";
            }
        }
        $result .= "\n";
    }
    # Ordered lists
    elsif ($block =~ /^\d+\.\s/) {
        my @lines = split(/\n/, $block);
        foreach my $line (@lines) {
            if ($line =~ /^([ \t]*)\d+\.\s+(.*)$/) {
                my $indent = $1;
                my $content = $2;
                $result .= "$indent# " . process_inline($content, $references) . "\n";
            } else {
                $result .= $line . "\n";
            }
        }
        $result .= "\n";
    }
    # Tables
    elsif ($block =~ /^\|.*\|$/m && $block =~ /\|[\s:-]+\|/m) {
        $result = "\@table\n$block\n\@end\n\n";
    }
    # Horizontal rule
    elsif ($block =~ /^([-*_])\1{2,}$/) {
        $result = "---\n\n";
    }
    # Definition lists (simplified)
    elsif ($block =~ /^.+\n:\s/) {
        my @lines = split(/\n/, $block);
        my $term = shift @lines;
        $result = "\$ " . process_inline($term, $references) . "\n";
        
        foreach my $line (@lines) {
            if ($line =~ /^:\s+(.*)$/) {
                $result .= "  " . process_inline($1, $references) . "\n";
            } else {
                $result .= "  $line\n";
            }
        }
        $result .= "\n";
    }
    # Default - paragraph
    else {
        $result = process_inline($block, $references) . "\n\n";
    }
    
    return $result;
}

sub process_inline {
    my ($text, $references) = @_;
    
    # Protect and store code spans
    my @code_spans;
    $text =~ s/`([^`]+)`/push @code_spans, $1; "\x{FEFF}CODESPAN" . $#code_spans . "\x{FEFF}"/ge;
    
    # Process links and images
    # Reference-style links [text][id]
    $text =~ s/\[([^\]]+)\]\[([^\]]*)\]/handle_reference_link($1, $2, $references)/ge;
    
    # Inline links: [text](url) - but not images ![text](url)
    $text =~ s/(?<!\!)\[([^\]]+)\]\(([^)]+)\)/"{$2}[$1]"/ge;
    
    # Reference-style images: ![alt][id]
    $text =~ s/!\[([^\]]+)\]\[([^\]]*)\]/handle_reference_image($1, $2, $references)/ge;
    
    # Inline images: ![alt](url)
    $text =~ s/!\[([^\]]+)\]\(([^)]+)\)/"\x{FEFF}IMGSTART\x{FEFF}$2\x{FEFF}IMGMID\x{FEFF}[image: $1]\x{FEFF}IMGEND\x{FEFF}"/ge;
    
    # Process formatting in the correct order to avoid conflicts
    # Bold+italic combined: ***text*** -> */text/*
    $text =~ s/\*\*\*([^*]+?)\*\*\*/\x{FEFF}BOLDITALIC\x{FEFF}$1\x{FEFF}ENDBOLDITALIC\x{FEFF}/g;
    
    # Bold: **text** -> *text*
    $text =~ s/\*\*([^*]+?)\*\*/\x{FEFF}BOLD\x{FEFF}$1\x{FEFF}ENDBOLD\x{FEFF}/g;
    
    # Bold with underscore: __text__ -> *text*
    $text =~ s/__([^_]+?)__/\x{FEFF}BOLD\x{FEFF}$1\x{FEFF}ENDBOLD\x{FEFF}/g;
    
    # Italic: *text* -> /text/
    $text =~ s/(?<!\*)\*([^*]+?)\*(?!\*)/\x{FEFF}ITALIC\x{FEFF}$1\x{FEFF}ENDITALIC\x{FEFF}/g;
    
    # Italic with underscore: _text_ -> /text/
    # Use negative lookahead/lookbehind to avoid escaped underscores
    $text =~ s/(?<!\\)_([^_]+?)(?<!\\)_/\x{FEFF}ITALIC\x{FEFF}$1\x{FEFF}ENDITALIC\x{FEFF}/g;
    
    # Strikethrough: ~~text~~ -> -text-
    $text =~ s/~~([^~]+?)~~/-$1-/g;
    
    # Footnote references: [^id] -> ^[id]
    $text =~ s/\[\^([^\]]+?)\]/\^\[$1\]/g;
    
    # Restore code spans BEFORE replacing formatting placeholders
    # This prevents code content from being affected by formatting rules
    $text =~ s/\x{FEFF}CODESPAN(\d+)\x{FEFF}/"`" . $code_spans[$1] . "`"/ge;
    
    # Now replace the formatting placeholders with the correct Neorg formatting
    # Use /s modifier to allow . to match newlines
    # Process each type of placeholder separately
    $text =~ s/\x{FEFF}BOLDITALIC\x{FEFF}(.*?)\x{FEFF}ENDBOLDITALIC\x{FEFF}/*\/$1\/*/gs;
    $text =~ s/\x{FEFF}BOLD\x{FEFF}(.*?)\x{FEFF}ENDBOLD\x{FEFF}/*$1*/gs;
    $text =~ s/\x{FEFF}ITALIC\x{FEFF}(.*?)\x{FEFF}ENDITALIC\x{FEFF}/\/$1\//gs;
    
    # Clean up any remaining unmatched placeholders
    # This handles cases where formatting spans across boundaries improperly
    $text =~ s/\x{FEFF}(?:BOLD|ITALIC|BOLDITALIC|ENDBOLD|ENDITALIC|ENDBOLDITALIC)\x{FEFF}//g;
    
    # Replace image placeholders with the correct format
    $text =~ s/\x{FEFF}IMGSTART\x{FEFF}(.*?)\x{FEFF}IMGMID\x{FEFF}(.*?)\x{FEFF}IMGEND\x{FEFF}/{$1}$2/g;
    
    # Final cleanup of any stray Unicode markers
    $text =~ s/\x{FEFF}//g;
    
    return $text;
}

sub handle_reference_link {
    my ($text, $id, $references) = @_;
    $id = $text if $id eq '';  # Empty reference uses text as id
    $id = lc($id);
    
    if (exists $references->{$id}) {
        my $url = $references->{$id}{url};
        return "{$url}[$text]";
    } else {
        return "[$text][$id]";
    }
}

sub handle_reference_image {
    my ($alt, $id, $references) = @_;
    $id = $alt if $id eq '';  # Empty reference uses alt as id
    $id = lc($id);
    
    if (exists $references->{$id}) {
        my $url = $references->{$id}{url};
        return "{$url}[image: $alt]";
    } else {
        return "![$alt][$id]";
    }
}

sub debug_print {
    my ($message) = @_;
    print STDERR "DEBUG: $message\n" if $debug;
}

__END__

=head1 NAME

mton_ast - Markdown to Neorg converter

=head1 SYNOPSIS

mton_ast [options]

 Options:
   -i, --input FILE    Read input from FILE (default: stdin)
   -o, --output FILE   Write output to FILE (default: stdout)
   -h, --help          Display this help message and exit
   -d, --debug         Enable debug output for diagnostics

 Examples:
   mton_ast -i input.md -o output.norg
   cat input.md | mton_ast > output.norg
   mton_ast < input.md > output.norg

=head1 DESCRIPTION

This script converts Markdown formatted text to Neorg format.
It uses a block-based approach to handle Markdown structures.

Features:
 - Headers: Converts # headers to * headers (Neorg format)
 - Lists: Converts - lists to - lists, and 1. lists to # lists
 - Task Lists: Converts [ ] and [x] to ( ) and (x)
 - Code Blocks: Converts ```lang to @code lang and ``` to @end
 - Block Quotes: Converts > text to @quote blocks
 - Tables: Handles tables with proper formatting
 - Inline formatting: **bold** -> *bold*, *italic* -> /italic/
 - Links: [text](url) -> {url}[text]
 - Images: ![alt](url) -> {url}[image: alt]
 - Footnotes: [^id] -> ^[id]
 - Horizontal Rules: ---, ___, *** -> ---

=head1 AUTHOR

Zach Podbielniak

=cut
