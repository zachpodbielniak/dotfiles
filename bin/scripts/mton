#!/bin/bash
set -euo pipefail

#------------------------------------------------------------------------------
# mton - Markdown to Neorg converter
#------------------------------------------------------------------------------
# 
# This script converts Markdown formatted text to Neorg format.
# It processes input line by line and handles various Markdown elements,
# converting them to their Neorg equivalents.
#
# Features:
# - Headers: Converts # headers to * headers (Neorg format)
# - Lists: Keeps - lists, converts 1. lists to # lists
# - Task Lists: Converts [ ] and [x] to ( ) and (x)
# - Code Blocks: Converts ```lang to @code lang and ``` to @end
# - Block Quotes: Converts > text to @quote blocks
# - Tables: Handles tables with a simple wrapper
# - Inline formatting: **bold** -> *bold*, *italic* -> /italic/
# - Links: [text](url) -> {(url)}[text]
# - Images: ![alt](url) -> {(url)}[image: alt]
# - Horizontal Rules: ---, ___, *** -> ---
#
# Known bugs:
# - Bold text with double asterisks (**text**) is sometimes converted to /text/ (italic)
#   instead of *text* (bold)
# - Complex nested formatting might not always convert correctly

usage() {
    # Display usage information and exit
    echo "Usage: $(basename "$0") [OPTIONS]"
    echo "Convert Markdown to Neorg format"
    echo ""
    echo "Options:"
    echo "  -i, --input FILE   Read input from FILE (default: stdin)"
    echo "  -o, --output FILE  Write output to FILE (default: stdout)"
    echo "  -h, --help         Display this help message and exit"
    echo ""
    echo "Examples:"
    echo "  $(basename "$0") -i input.md -o output.norg"
    echo "  cat input.md | $(basename "$0") > output.norg"
    echo "  $(basename "$0") < input.md > output.norg"
    exit 1
}

#------------------------------------------------------------------------------
# Command line arguments parsing
#------------------------------------------------------------------------------
# Initialize variables for input and output files
input=""
output=""

# Process command-line options
while [[ $# -gt 0 ]]; do
    case "$1" in
        -i|--input)
            # Handle input file parameter
            if [[ -n "${2:-}" ]]; then
                input="$2"
                shift 2
            else
                echo "Error: Argument for $1 is missing" >&2
                usage
            fi
            ;;
        -o|--output)
            # Handle output file parameter
            if [[ -n "${2:-}" ]]; then
                output="$2"
                shift 2
            else
                echo "Error: Argument for $1 is missing" >&2
                usage
            fi
            ;;
        -h|--help)
            # Show help and exit
            usage
            ;;
        *)
            # Catch any unrecognized options
            echo "Error: Unknown option: $1" >&2
            usage
            ;;
    esac
done

#------------------------------------------------------------------------------
# Main conversion function
#------------------------------------------------------------------------------
markdown_to_neorg() {
    # This function processes Markdown input line by line, converting each element
    # to its Neorg equivalent. It handles block elements (headers, lists, code blocks,
    # quotes, tables) and inline formatting (bold, italic, links, images).
    
    # State tracking variables for multi-line blocks
    local in_code_block=0  # Flag: currently inside a code block (0=no, 1=yes)
    local in_quote_block=0 # Flag: currently inside a blockquote (0=no, 1=yes)
    local in_table=0       # Flag: currently inside a table (0=no, 1=yes)
    
    # Main processing loop - reads input line by line with proper EOF handling
    # The || [[ -n "$line" ]] part ensures the last line is processed even without a newline
    while IFS= read -r line || [[ -n "$line" ]]; do
        #----------------------------------------------------------------------
        # Code Block Processing
        #----------------------------------------------------------------------
        # Check for code block markers ```
        if [[ "$line" =~ ^'```' ]]; then
            if [[ $in_code_block -eq 0 ]]; then
                # Start of code block
                # Extract language specifier if present (e.g., ```python -> python)
                local lang=$(echo "$line" | sed -E 's/^```(.*)/\1/')
                if [[ -n "$lang" ]]; then
                    # If language is specified, include it in the tag
                    echo "@code $lang"
                else
                    # Otherwise use a simple code tag
                    echo "@code"
                fi
                in_code_block=1
            else
                # End of code block
                echo "@end"
                in_code_block=0
            fi
            continue  # Process next line
        fi
        
        # If inside a code block, pass content through unchanged
        if [[ $in_code_block -eq 1 ]]; then
            echo "$line"
            continue  # Process next line
        fi
        
        #----------------------------------------------------------------------
        # Table Processing 
        #----------------------------------------------------------------------
        # Detect table rows by looking for lines starting and ending with pipe characters
        if [[ "$line" =~ ^'\|'.*'\|'$ ]]; then
            if [[ $in_table -eq 0 ]]; then
                # Start of table - Neorg uses a @table tag to wrap tables
                echo "@table"
                in_table=1
            fi
            # Pass the table row through unchanged (Neorg uses Markdown-like table syntax)
            echo "$line"
            continue  # Process next line
        elif [[ $in_table -eq 1 && ! "$line" =~ ^'\|'.*'\|'$ ]]; then
            # End of table detected when a non-table line is encountered
            echo "@end"
            in_table=0
            # Don't continue - continue processing this line through the rest of the loop
        fi
        
        #----------------------------------------------------------------------
        # Blockquote Processing
        #----------------------------------------------------------------------
        # Detect blockquotes by the > prefix
        if [[ "$line" =~ ^'> ' ]]; then
            if [[ $in_quote_block -eq 0 ]]; then
                # Start of blockquote
                echo "@quote"
                in_quote_block=1
            fi
            # Remove the '> ' prefix from the line and output the content
            echo "${line#> }"
            continue  # Process next line
        elif [[ $in_quote_block -eq 1 && ! "$line" =~ ^'> ' ]]; then
            # End of blockquote detected when a non-blockquote line is encountered
            echo "@end"
            in_quote_block=0
            # Don't continue - continue processing this line through the rest of the loop
        fi
        
        #----------------------------------------------------------------------
        # Header Processing
        #----------------------------------------------------------------------
        # Convert Markdown headers (# Style) to Neorg headers (* Style)
        # The number of # or * indicates the heading level
        if [[ "$line" =~ ^'# ' ]]; then
            # Level 1 heading: # Heading -> * Heading (Neorg format)
            # In Neorg, headings use asterisks instead of hash symbols
            local content="${line#\# }"
            echo "* $content"
            continue
        elif [[ "$line" =~ ^'## ' ]]; then
            # Level 2 heading: ## Heading -> ** Heading
            local content="${line#\#\# }"
            echo "** $content"
            continue
        elif [[ "$line" =~ ^'### ' ]]; then
            # Level 3 heading: ### Heading -> *** Heading
            local content="${line#\#\#\# }"
            echo "*** $content"
            continue
        elif [[ "$line" =~ ^'#### ' ]]; then
            # Level 4 heading: #### Heading -> **** Heading
            local content="${line#\#\#\#\# }"
            echo "**** $content"
            continue
        elif [[ "$line" =~ ^'##### ' ]]; then
            # Level 5 heading: ##### Heading -> ***** Heading
            local content="${line#\#\#\#\#\# }"
            echo "***** $content"
            continue
        elif [[ "$line" =~ ^'###### ' ]]; then
            # Level 6 heading: ###### Heading -> ****** Heading
            local content="${line#\#\#\#\#\#\# }"
            echo "****** $content"
            continue
        fi
        
        #----------------------------------------------------------------------
        # Task List Processing
        #----------------------------------------------------------------------
        # Convert Markdown task list items to Neorg format
        # Markdown: - [ ] Task Item -> Neorg: - ( ) Task Item
        # Markdown: - [x] Task Item -> Neorg: - (x) Task Item
        if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*\[[[:space:]]\] ]]; then
            # Unchecked task: - [ ] Task -> - ( ) Task
            # Extract indentation to preserve it
            local indent=$(echo "$line" | sed -E 's/^([[:space:]]*)-.*/\1/')
            # Extract the task content
            local content=$(echo "$line" | sed -E 's/^[[:space:]]*-[[:space:]]*\[[[:space:]]\][[:space:]]*(.*)/\1/')
            # Output with Neorg format
            echo "${indent}- ( ) ${content}"
            continue
        elif [[ "$line" =~ ^[[:space:]]*-[[:space:]]*\[x\] ]]; then
            # Checked task: - [x] Task -> - (x) Task
            # Extract indentation to preserve it
            local indent=$(echo "$line" | sed -E 's/^([[:space:]]*)-.*/\1/')
            # Extract the task content
            local content=$(echo "$line" | sed -E 's/^[[:space:]]*-[[:space:]]*\[x\][[:space:]]*(.*)/\1/')
            # Output with Neorg format
            echo "${indent}- (x) ${content}"
            continue
        fi
        
        #----------------------------------------------------------------------
        # List Processing
        #----------------------------------------------------------------------
        # Handle both unordered (-) and ordered (1.) lists
        if [[ "$line" =~ ^[[:space:]]*-[[:space:]] ]]; then
            # Unordered list items: Markdown uses - or *, Neorg uses -
            # Pass unordered list items through unchanged
            echo "$line"
            continue
        elif [[ "$line" =~ ^[[:space:]]*[0-9]+[[:space:]]*\. ]]; then
            # Ordered list items: 1. Item -> # Item (Neorg format)
            # Extract indentation
            local indent=$(echo "$line" | sed -E 's/^([[:space:]]*).*$/\1/')
            # Extract the list item content
            local content=$(echo "$line" | sed -E 's/^[[:space:]]*[0-9]+[[:space:]]*\.[[:space:]]*(.*)/\1/')
            # Output in Neorg format
            echo "${indent}# ${content}"
            continue
        fi
        
        #----------------------------------------------------------------------
        # Horizontal Rule Processing
        #----------------------------------------------------------------------
        # Convert Markdown horizontal rules (---, ___, ***) to Neorg format (---)
        if [[ "$line" =~ ^'---'+$ || "$line" =~ ^'___'+$ || "$line" =~ ^'\*\*\*'+$ ]]; then
            echo "---"
            continue
        fi
        
        #----------------------------------------------------------------------
        # Empty Line Handling
        #----------------------------------------------------------------------
        # Pass empty lines through unchanged - both formats use empty lines similarly
        if [[ -z "$line" ]]; then
            echo ""
            continue
        fi
        
        # Format line with Neorg inline formatting
        # Using temporary files to handle special characters better
        temp_file=$(mktemp)
        echo "$line" > "$temp_file"
        
        # Links: [text](url) -> {(url)}[text]
        sed -i 's/\[\([^]]*\)\](\([^)]*\))/{(\2)}[\1]/g' "$temp_file"
        
        # Images: ![alt](url) -> {(url)}[image: alt]
        sed -i 's/!\[\([^]]*\)\](\([^)]*\))/{(\2)}[image: \1]/g' "$temp_file"
        
        # Bold and italic combined: ***text*** -> */text/*
        sed -i 's/\*\*\*\([^*]*\)\*\*\*/*\/\1\//g' "$temp_file"
        
        # Bold: **text** -> *text*
        sed -i 's/\*\*\([^*]*\)\*\*/*\1*/g' "$temp_file"
        
        # Italic: *text* -> /text/
        sed -i 's/\*\([^*]*\)\*/\/\1\//g' "$temp_file"
        
        # Bold with underscores: __text__ -> *text*
        sed -i 's/__\([^_]*\)__/*\1*/g' "$temp_file"
        
        # Italic with underscores: _text_ -> /text/
        sed -i 's/_\([^_]*\)_/\/\1\//g' "$temp_file"
        
        # Strikethrough: ~~text~~ -> -text-
        sed -i 's/~~\([^~]*\)~~/-\1-/g' "$temp_file"
        
        cat "$temp_file"
        rm "$temp_file"
    done
    
    #----------------------------------------------------------------------
    # Final Cleanup - Ensure all blocks are properly closed
    #----------------------------------------------------------------------
    # Close any open blocks that might be left open at the end of input
    if [[ $in_quote_block -eq 1 ]]; then
        # Close open blockquote block
        echo "@end"
    fi
    if [[ $in_table -eq 1 ]]; then
        # Close open table block
        echo "@end"
    fi
    if [[ $in_code_block -eq 1 ]]; then
        # Close open code block
        echo "@end"
    fi
}

#------------------------------------------------------------------------------
# Main Program Execution
#------------------------------------------------------------------------------
# Handle the four possible combinations of input/output:
# 1. Input file → Output file
# 2. Input file → Stdout
# 3. Stdin → Output file
# 4. Stdin → Stdout

if [[ -n "$input" ]]; then
    # Input from file
    if [[ ! -f "$input" ]]; then
        # Error handling: Ensure input file exists
        echo "Error: Input file '$input' does not exist" >&2
        exit 1
    fi
    
    if [[ -n "$output" ]]; then
        # Case 1: Input file → Output file
        cat "$input" | markdown_to_neorg > "$output"
    else
        # Case 2: Input file → Stdout
        cat "$input" | markdown_to_neorg
    fi
else
    # Input from stdin
    if [[ -n "$output" ]]; then
        # Case 3: Stdin → Output file
        markdown_to_neorg > "$output"
    else
        # Case 4: Stdin → Stdout
        markdown_to_neorg
    fi
fi

# Exit with success status
exit 0