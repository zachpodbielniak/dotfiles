#!/bin/bash

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail

# Configuration
VERSION="1.0.0"
SCRIPT_NAME=$(basename "$0")
DEFAULT_SPEC_FILE="${HOME}/Documents/notes/03_resources/technical/git/conventional_commits_specification.md"
DEFAULT_PROMPT="Write a concise git commit message following conventional commits for these changes. Output ONLY the commit message, no explanation. Do NOT include any codeblocks."

# Exit codes
readonly EXIT_SUCCESS=0
readonly EXIT_GENERAL_ERROR=1
readonly EXIT_USAGE_ERROR=2
readonly EXIT_NO_STAGED=3
readonly EXIT_MISSING_DEP=4
readonly EXIT_SPEC_NOT_FOUND=5

# Option defaults
EDIT_MODE=false
DRY_RUN=false
DEBUG_MODE=false
AUTO_CONFIRM=false
MODEL=""
PROVIDER=""
SPEC_FILE="${DEFAULT_SPEC_FILE}"

show_help () {
    cat << EOF
Usage: ${SCRIPT_NAME} [OPTIONS]

Generate AI-powered conventional commit messages from staged changes.

Options:
    -h, --help           Show this help message
    --license            Show license information
    -v, --version        Show version
    -e, --edit           Edit generated message with vipe before committing
    -n, --dry-run        Show generated message without committing
    -m, --model MODEL    Specify aipy model (default: aipy default)
    -p, --provider PROV  Specify aipy provider (default: aipy default)
    -s, --spec-file FILE Use custom conventional commits spec file
                         (default: ${DEFAULT_SPEC_FILE})
    -d, --debug          Enable debug output
    -y, --yes            Skip confirmation prompt (auto-confirm)

Examples:
    ${SCRIPT_NAME}                    # Generate and commit with default settings
    ${SCRIPT_NAME} -e                 # Edit message before committing
    ${SCRIPT_NAME} -n                 # Preview message without committing
    ${SCRIPT_NAME} -m claude-opus-4-5 # Use Claude Opus for better messages
    ${SCRIPT_NAME} --edit --debug     # Debug mode with edit
    ${SCRIPT_NAME} -y                 # Auto-confirm without prompt

Requires:
    - aipy script in PATH
    - Staged git changes
    - Conventional commits spec file (configurable with -s)
    - vipe (moreutils) for --edit mode
EOF
}

show_license () {
    cat << EOF
${SCRIPT_NAME} - Generate AI-powered conventional commit messages
Copyright (C) 2025  Zach Podbielniak

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
EOF
}

show_version () {
    echo "${SCRIPT_NAME} version ${VERSION}"
}

debug_print () {
    if [[ "${DEBUG_MODE}" == true ]]
    then
        echo "[DEBUG] $*" >&2
    fi
}

error_exit () {
    local exit_code="${1}"
    local message="${2}"
    echo "ERROR: ${message}" >&2
    exit "${exit_code}"
}

check_dependency () {
    local dep="${1}"
    local exit_code="${2}"
    local message="${3}"
    if ! command -v "${dep}" &>/dev/null
    then
        error_exit "${exit_code}" "${message}"
    fi
}

# Parse command-line arguments
while [[ $# -gt 0 ]]
do
    case "${1}" in
        -h|--help)
            show_help
            exit "${EXIT_SUCCESS}"
            ;;
        --license)
            show_license
            exit "${EXIT_SUCCESS}"
            ;;
        -v|--version)
            show_version
            exit "${EXIT_SUCCESS}"
            ;;
        -e|--edit)
            EDIT_MODE=true
            shift
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -m|--model)
            if [[ -z "${2:-}" ]]
            then
                error_exit "${EXIT_USAGE_ERROR}" "--model requires an argument"
            fi
            MODEL="${2}"
            shift 2
            ;;
        -p|--provider)
            if [[ -z "${2:-}" ]]
            then
                error_exit "${EXIT_USAGE_ERROR}" "--provider requires an argument"
            fi
            PROVIDER="${2}"
            shift 2
            ;;
        -s|--spec-file)
            if [[ -z "${2:-}" ]]
            then
                error_exit "${EXIT_USAGE_ERROR}" "--spec-file requires an argument"
            fi
            SPEC_FILE="${2}"
            shift 2
            ;;
        -d|--debug)
            DEBUG_MODE=true
            shift
            ;;
        -y|--yes)
            AUTO_CONFIRM=true
            shift
            ;;
        -*)
            error_exit "${EXIT_USAGE_ERROR}" "Unknown option: ${1}. Use --help for usage."
            ;;
        *)
            error_exit "${EXIT_USAGE_ERROR}" "Unexpected argument: ${1}. Use --help for usage."
            ;;
    esac
done

# Debug: print configuration
debug_print "Configuration:"
debug_print "  EDIT_MODE=${EDIT_MODE}"
debug_print "  DRY_RUN=${DRY_RUN}"
debug_print "  DEBUG_MODE=${DEBUG_MODE}"
debug_print "  AUTO_CONFIRM=${AUTO_CONFIRM}"
debug_print "  MODEL=${MODEL:-<default>}"
debug_print "  PROVIDER=${PROVIDER:-<default>}"
debug_print "  SPEC_FILE=${SPEC_FILE}"

# Check dependencies
check_dependency "aipy" "${EXIT_MISSING_DEP}" "aipy is not installed or not in PATH"
check_dependency "git" "${EXIT_MISSING_DEP}" "git is not installed or not in PATH"

if [[ "${EDIT_MODE}" == true ]]
then
    check_dependency "vipe" "${EXIT_MISSING_DEP}" "vipe (moreutils) is required for --edit mode"
fi

# Check for staged changes
if [[ -z "$(git diff --staged)" ]]
then
    error_exit "${EXIT_NO_STAGED}" "Nothing is staged to be committed. Did you mean to 'git add [<file_0>...<file_n>]'?"
fi

# Check spec file exists
if [[ ! -f "${SPEC_FILE}" ]]
then
    error_exit "${EXIT_SPEC_NOT_FOUND}" "Spec file not found: ${SPEC_FILE}"
fi

# Build aipy command
aipy_cmd=("aipy" "--prompt" "${DEFAULT_PROMPT}" "-f" "${SPEC_FILE}" "--no-preserve")

if [[ -n "${MODEL}" ]]
then
    aipy_cmd+=("--model" "${MODEL}")
fi

if [[ -n "${PROVIDER}" ]]
then
    aipy_cmd+=("--provider" "${PROVIDER}")
fi

debug_print "Running: git diff --staged | ${aipy_cmd[*]}"

# Generate commit message
commit_msg=$(git diff --staged | "${aipy_cmd[@]}")

if [[ -z "${commit_msg}" ]]
then
    error_exit "${EXIT_GENERAL_ERROR}" "aipy returned an empty commit message"
fi

debug_print "Generated message:"
debug_print "${commit_msg}"

# Dry run mode: just print and exit
if [[ "${DRY_RUN}" == true ]]
then
    echo "${commit_msg}"
    exit "${EXIT_SUCCESS}"
fi

# Edit mode: pipe through vipe
if [[ "${EDIT_MODE}" == true ]]
then
    debug_print "Opening message in editor (vipe)..."
    commit_msg=$(echo "${commit_msg}" | vipe)

    if [[ -z "${commit_msg}" ]]
    then
        error_exit "${EXIT_GENERAL_ERROR}" "Commit message is empty after editing. Aborting."
    fi

    debug_print "Message after editing:"
    debug_print "${commit_msg}"
fi

# Confirmation prompt (unless --yes)
if [[ "${AUTO_CONFIRM}" != true ]]
then
    echo "Generated commit message:"
    echo "---"
    echo "${commit_msg}"
    echo "---"
    read -r -p "Commit with this message? [Y/n] " confirm

    case "${confirm}" in
        [nN]|[nN][oO])
            echo "Commit aborted."
            exit "${EXIT_SUCCESS}"
            ;;
    esac
fi

# Execute the commit
git commit -m "${commit_msg}"

echo "Commit successful."
