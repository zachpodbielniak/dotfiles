#!/usr/bin/python3

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
Simple Schedule - Multi-session event scheduling tool

This script helps schedule multi-session events across multiple locations while minimizing
attendee conflicts and respecting various constraints like room capacity, presenter availability,
and time restrictions.

Required sessions (required=true) are automatically assigned to ALL attendees regardless of
signup preferences. Non-required sessions only include attendees who explicitly signed up.

Author: Simple Schedule Contributors
License: MIT
"""

import argparse
import json
import sys
import os
import re
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Set, Any, NamedTuple
from dataclasses import dataclass
from collections import defaultdict
import csv
from pathlib import Path
from subprocess import run

# Check if we're in the correct distrobox
ctr_id = os.environ.get("CONTAINER_ID", "")

# Check if distrobox check should be skipped
no_dbox_check = os.environ.get("NO_DBOX_CHECK", "").lower() in ("1", "true")

# If we are not in the 'dev' distrobox, re-exec the script inside it
if not no_dbox_check and ctr_id != "dev":
    cmd = ["distrobox", "enter", "dev", "--", *sys.argv]
    result = run(cmd)
    sys.exit(result.returncode)

# Check for required dependencies
try:
    import pandas as pd
except ImportError:
    print("ERROR: pandas is required but not installed.", file=sys.stderr)
    print("\nThis script requires the 'dev' distrobox environment.", file=sys.stderr)
    print("The script should automatically run in the dev distrobox.", file=sys.stderr)
    print("\nIf you're bypassing the distrobox check, install dependencies with:", file=sys.stderr)
    print("  pip install pandas openpyxl", file=sys.stderr)
    sys.exit(1)

try:
    import openpyxl
    XLSX_SUPPORT = True
except ImportError:
    XLSX_SUPPORT = False

try:
    from tabulate import tabulate
    TABULATE_SUPPORT = True
except ImportError:
    TABULATE_SUPPORT = False


@dataclass
class Session:
    """Represents a session to be scheduled"""
    name: str
    max_attendees: int  # 0 means unlimited
    presenters: List[str]
    length: int  # minutes
    required: bool
    priority: int  # -20 to 19
    min_sessions: int  # Minimum number of sessions to schedule
    max_sessions: int  # Maximum number of sessions to schedule (0 means auto-determine)
    max_per_day: int
    interested_attendees: Set[str]
    maybe_attendees: Set[str]


@dataclass
class Location:
    """Represents a location/room"""
    name: str
    soft_limit: int
    hard_limit: int
    time_available: List[Tuple[datetime, datetime]]
    days_available: Optional[Set[int]] = None  # None means available all days


@dataclass
class TimeSlot:
    """Represents a time slot in the schedule"""
    day: int
    start_time: datetime
    end_time: datetime
    
    def overlaps_with(self, other: 'TimeSlot') -> bool:
        """Check if this time slot overlaps with another"""
        if self.day != other.day:
            return False
        return (self.start_time < other.end_time and 
                self.end_time > other.start_time)


@dataclass
class ScheduledSession:
    """Represents a scheduled session"""
    session: Session
    location: Location
    time_slot: TimeSlot
    attendees: Set[str]
    
    def conflicts_with(self, other: 'ScheduledSession') -> bool:
        """Check if this scheduled session conflicts with another"""
        return self.time_slot.overlaps_with(other.time_slot)


class SchedulingError(Exception):
    """Custom exception for scheduling errors"""
    pass


# Global debug flag
DEBUG = False


def debug_log(message: str, indent: int = 0):
    """Print debug message to stderr if debug mode is enabled"""
    if DEBUG:
        prefix = "  " * indent
        print(f"[DEBUG] {prefix}{message}", file=sys.stderr)


def parse_time(time_str: str) -> datetime:
    """
    Parse time string in various formats
    
    Args:
        time_str: Time string like "8am", "8:00am", "08:00", "8:30pm", "20:30"
        
    Returns:
        datetime object with the parsed time
        
    Raises:
        ValueError: If time format is invalid
    """
    time_str = time_str.strip().lower()
    
    # Try different time formats
    formats = [
        "%I%p",           # 8am
        "%I:%M%p",        # 8:00am
        "%H:%M",          # 08:00 or 20:30
    ]
    
    for fmt in formats:
        try:
            # Use a dummy date for parsing time only
            return datetime.strptime(f"2000-01-01 {time_str}", f"%Y-%m-%d {fmt}")
        except ValueError:
            continue
    
    raise ValueError(f"Invalid time format: '{time_str}'. Use formats like '8am', '8:00am', or '20:30'")


def parse_time_range(time_range: str) -> Tuple[datetime, datetime]:
    """
    Parse a time range string
    
    Args:
        time_range: Time range like "8am-12pm" or "09:00-17:00"
        
    Returns:
        Tuple of (start_time, end_time)
        
    Raises:
        ValueError: If format is invalid or start >= end
    """
    parts = time_range.strip().split('-')
    if len(parts) != 2:
        raise ValueError(f"Invalid time range format: '{time_range}'. Use 'start-end' format")
    
    start = parse_time(parts[0])
    end = parse_time(parts[1])
    
    if start >= end:
        raise ValueError(f"Start time must be before end time in range: '{time_range}'")
    
    return start, end


def parse_time_list(time_list: str) -> List[Tuple[datetime, datetime]]:
    """Parse comma-separated list of time ranges"""
    ranges = []
    for time_range in time_list.split(','):
        ranges.append(parse_time_range(time_range))
    return ranges


def parse_slice_duration(slice_str: str) -> timedelta:
    """
    Parse slice duration string
    
    Args:
        slice_str: Duration like "30m" or "1h"
        
    Returns:
        timedelta object
    """
    match = re.match(r'^(\d+)([mh])$', slice_str.lower())
    if not match:
        raise ValueError(f"Invalid slice format: '{slice_str}'. Use '<number>m' or '<number>h'")
    
    value = int(match.group(1))
    unit = match.group(2)
    
    if unit == 'm':
        return timedelta(minutes=value)
    else:  # 'h'
        return timedelta(hours=value)


def read_csv_file(filepath: Path) -> pd.DataFrame:
    """Read CSV file with error handling"""
    try:
        return pd.read_csv(filepath)
    except Exception as e:
        raise SchedulingError(f"Error reading CSV file '{filepath}': {str(e)}")


def read_xlsx_file(filepath: Path) -> pd.DataFrame:
    """Read Excel file with error handling"""
    if not XLSX_SUPPORT:
        raise SchedulingError("Excel support not available. Install openpyxl: pip install openpyxl")
    try:
        return pd.read_excel(filepath)
    except Exception as e:
        raise SchedulingError(f"Error reading Excel file '{filepath}': {str(e)}")


def read_markdown_table(filepath: Path) -> pd.DataFrame:
    """Read Markdown table file"""
    try:
        with open(filepath, 'r') as f:
            content = f.read()
        
        # Find the table in the markdown
        lines = content.strip().split('\n')
        table_lines = []
        in_table = False
        
        for line in lines:
            if '|' in line:
                if not in_table:
                    in_table = True
                table_lines.append(line)
            elif in_table and line.strip() == '':
                break
        
        if not table_lines:
            raise ValueError("No markdown table found in file")
        
        # Parse the table
        header = [cell.strip() for cell in table_lines[0].split('|')[1:-1]]
        
        # Skip separator line
        data_lines = []
        for line in table_lines[2:]:
            if line.strip():
                row = [cell.strip() for cell in line.split('|')[1:-1]]
                data_lines.append(row)
        
        return pd.DataFrame(data_lines, columns=header)
        
    except Exception as e:
        raise SchedulingError(f"Error reading Markdown file '{filepath}': {str(e)}")


def read_input_file(filepath: str, file_type: str) -> pd.DataFrame:
    """Read input file based on extension"""
    path = Path(filepath)
    
    debug_log(f"Reading {file_type} file: {filepath}")
    
    if not path.exists():
        raise SchedulingError(f"File not found: '{filepath}'")
    
    ext = path.suffix.lower()
    debug_log(f"File extension: {ext}", 1)
    
    if ext == '.csv':
        df = read_csv_file(path)
    elif ext in ['.xlsx', '.xls']:
        df = read_xlsx_file(path)
    elif ext == '.md':
        df = read_markdown_table(path)
    else:
        raise SchedulingError(
            f"Unsupported file format '{ext}' for {file_type}. "
            f"Supported formats: csv, xlsx, md"
        )
    
    debug_log(f"Read {len(df)} rows from {file_type} file", 1)
    if DEBUG and len(df) > 0:
        debug_log(f"Columns: {list(df.columns)}", 2)
    
    return df


def normalize_bool_value(value: Any) -> bool:
    """Normalize various boolean representations"""
    if pd.isna(value):
        return False
    str_val = str(value).lower().strip()
    return str_val in ['true', '1', 'yes', 'y']


def normalize_interest_value(value: Any) -> str:
    """Normalize attendee interest values"""
    if pd.isna(value) or value == '':
        return ''
    str_val = str(value).lower().strip()
    
    if str_val in ['1', 'x', 'yes', 'true']:
        return 'yes'
    elif str_val in ['?', 'maybe']:
        return 'maybe'
    else:
        return ''


def parse_session_count(value: Any, session_name: str) -> Tuple[int, int]:
    """
    Parse session count which can be:
    - Single number: "3" -> (3, 3)
    - Range: "2-5" -> (2, 5)
    - Auto-determine: "?" or "0" -> (1, 0) where 0 means unlimited
    
    Returns: (min_sessions, max_sessions)
    """
    if pd.isna(value):
        raise ValueError(f"number_of_sessions is required")
    
    str_val = str(value).strip()
    
    # Check for auto-determine
    if str_val in ['?', '0']:
        return (1, 0)  # min 1, max unlimited (auto-determine)
    
    # Check for range
    if '-' in str_val:
        parts = str_val.split('-')
        if len(parts) != 2:
            raise ValueError(f"Invalid range format: '{str_val}'. Use 'min-max' format")
        
        try:
            min_val = int(parts[0].strip())
            max_val = int(parts[1].strip())
        except ValueError:
            raise ValueError(f"Invalid range values: '{str_val}'. Must be integers")
        
        if min_val <= 0:
            raise ValueError(f"Minimum sessions must be > 0, got {min_val}")
        if max_val < min_val:
            raise ValueError(f"Maximum sessions ({max_val}) must be >= minimum ({min_val})")
        
        return (min_val, max_val)
    
    # Single number
    try:
        num = int(str_val)
        if num <= 0:
            raise ValueError(f"number_of_sessions must be > 0, got {num}")
        return (num, num)
    except ValueError:
        raise ValueError(f"Invalid number_of_sessions value: '{str_val}'")


def validate_attendees_delimited(df: pd.DataFrame, sessions_df: pd.DataFrame, delimiter: str) -> Dict[str, Dict[str, str]]:
    """
    Validate and parse attendees data in delimited format
    
    Expected format:
        attendee_name | sessions
        John Doe      | Intro to AI:yes,Workshop A,Panel Discussion:maybe
        Jane Smith    | Workshop B:yes,Closing Keynote
    
    Returns:
        Dict mapping attendee_name to dict of session_name -> interest_level
    """
    debug_log("Validating attendees data (delimited format)")
    debug_log(f"Using delimiter: '{delimiter}'", 1)
    
    if df.empty:
        raise SchedulingError("Attendees file is empty")
    
    if len(df.columns) != 2:
        raise SchedulingError(
            "Attendees file in delimited format must have exactly 2 columns: "
            "attendee_name and sessions"
        )
    
    # Column names
    attendee_col = df.columns[0]
    sessions_col = df.columns[1]
    
    debug_log(f"Attendee column: {attendee_col}", 1)
    debug_log(f"Sessions column: {sessions_col}", 1)
    
    # Check for duplicate attendee names
    duplicates = df[attendee_col].duplicated()
    if duplicates.any():
        dup_names = df[attendee_col][duplicates].unique()
        raise SchedulingError(f"Duplicate attendee names found: {', '.join(dup_names)}")
    
    # Get valid session names from sessions file
    valid_sessions = set(sessions_df[sessions_df.columns[0]].values)
    
    # Build attendee interest map
    attendees = {}
    for _, row in df.iterrows():
        attendee_name = str(row[attendee_col]).strip()
        sessions_str = str(row[sessions_col]).strip()
        interests = {}
        
        if sessions_str and not pd.isna(row[sessions_col]):
            # Parse delimited sessions
            session_entries = [s.strip() for s in sessions_str.split(delimiter) if s.strip()]
            
            for entry in session_entries:
                # Check if interest level is specified with :suffix
                if ':' in entry:
                    parts = entry.split(':', 1)
                    session_name = parts[0].strip()
                    interest_suffix = parts[1].strip().lower()
                    
                    if interest_suffix in ['yes', 'maybe']:
                        interest = interest_suffix
                    else:
                        # Normalize the suffix
                        interest = normalize_interest_value(interest_suffix)
                        if not interest:
                            debug_log(f"Warning: Unknown interest suffix '{interest_suffix}' for session '{session_name}', treating as 'yes'", 2)
                            interest = 'yes'
                else:
                    # No suffix means definite interest
                    session_name = entry
                    interest = 'yes'
                
                # Validate session exists
                if session_name not in valid_sessions:
                    raise SchedulingError(
                        f"Session '{session_name}' for attendee '{attendee_name}' not found in sessions file"
                    )
                
                interests[session_name] = interest
        
        attendees[attendee_name] = interests
    
    debug_log(f"Processed {len(attendees)} attendees", 1)
    if DEBUG and attendees:
        sample_attendee = list(attendees.keys())[0]
        debug_log(f"Sample: {sample_attendee} -> {attendees[sample_attendee]}", 2)
    
    return attendees


def validate_attendees(df: pd.DataFrame, sessions_df: pd.DataFrame) -> Dict[str, Dict[str, str]]:
    """
    Validate and parse attendees data
    
    Returns:
        Dict mapping attendee_name to dict of session_name -> interest_level
    """
    debug_log("Validating attendees data")
    
    if df.empty:
        raise SchedulingError("Attendees file is empty")
    
    if len(df.columns) < 2:
        raise SchedulingError("Attendees file must have at least 2 columns (attendee_name and one session)")
    
    # First column is attendee name
    attendee_col = df.columns[0]
    session_cols = df.columns[1:]
    
    debug_log(f"Attendee column: {attendee_col}", 1)
    debug_log(f"Session columns: {list(session_cols)}", 1)
    
    # Check for duplicate attendee names
    duplicates = df[attendee_col].duplicated()
    if duplicates.any():
        dup_names = df[attendee_col][duplicates].unique()
        raise SchedulingError(f"Duplicate attendee names found: {', '.join(dup_names)}")
    
    # Get valid session names from sessions file
    valid_sessions = set(sessions_df[sessions_df.columns[0]].values)
    
    # Validate session columns match sessions in sessions file
    invalid_sessions = []
    for session in session_cols:
        if session not in valid_sessions:
            invalid_sessions.append(session)
    
    if invalid_sessions:
        raise SchedulingError(
            f"Sessions in attendees file not found in sessions file: {', '.join(invalid_sessions)}"
        )
    
    # Build attendee interest map
    attendees = {}
    for _, row in df.iterrows():
        attendee_name = str(row[attendee_col]).strip()
        interests = {}
        
        for session in session_cols:
            interest = normalize_interest_value(row[session])
            if interest:
                interests[session] = interest
        
        attendees[attendee_name] = interests
    
    debug_log(f"Processed {len(attendees)} attendees", 1)
    if DEBUG and attendees:
        sample_attendee = list(attendees.keys())[0]
        debug_log(f"Sample: {sample_attendee} -> {attendees[sample_attendee]}", 2)
    
    return attendees


def validate_sessions(df: pd.DataFrame, attendees: Dict[str, Dict[str, str]]) -> List[Session]:
    """Validate and parse sessions data"""
    if df.empty:
        raise SchedulingError("Sessions file is empty")
    
    required_cols = [
        'session_name', 'max_attendees', 'presenters', 'length',
        'required', 'priority', 'number_of_sessions', 'max_per_day'
    ]
    
    # Check column names (case-insensitive)
    df_cols_lower = [col.lower() for col in df.columns]
    missing_cols = []
    col_mapping = {}
    
    for req_col in required_cols:
        found = False
        for i, df_col in enumerate(df_cols_lower):
            if req_col.lower() == df_col:
                col_mapping[req_col] = df.columns[i]
                found = True
                break
        if not found:
            missing_cols.append(req_col)
    
    if missing_cols:
        raise SchedulingError(
            f"Missing required columns in sessions file: {', '.join(missing_cols)}\n"
            f"Expected columns: {', '.join(required_cols)}"
        )
    
    sessions = []
    all_attendee_names = set(attendees.keys())
    
    for idx, row in df.iterrows():
        try:
            name = str(row[col_mapping['session_name']]).strip()
            max_attendees = int(row[col_mapping['max_attendees']])
            
            if max_attendees < 0:
                raise ValueError(f"max_attendees must be >= 0, got {max_attendees}")
            
            # Parse presenters
            presenters_str = str(row[col_mapping['presenters']]).strip()
            presenters = [p.strip() for p in presenters_str.split(',') if p.strip()]
            
            length = int(row[col_mapping['length']])
            if length <= 0:
                raise ValueError(f"length must be > 0, got {length}")
            if length > 480:  # 8 hours
                raise ValueError(f"length seems too long ({length} minutes). Maximum recommended: 480")
            
            required = normalize_bool_value(row[col_mapping['required']])
            
            priority = int(row[col_mapping['priority']])
            if priority < -20 or priority > 19:
                raise ValueError(f"priority must be between -20 and 19, got {priority}")
            
            # Parse number_of_sessions (can be range or auto)
            min_sessions, max_sessions = parse_session_count(
                row[col_mapping['number_of_sessions']], 
                name
            )
            
            max_per_day = int(row[col_mapping['max_per_day']])
            if max_per_day <= 0:
                raise ValueError(f"max_per_day must be > 0, got {max_per_day}")
            
            # Validate max_per_day against session counts
            if max_sessions > 0 and max_per_day > max_sessions:
                raise ValueError(f"max_per_day ({max_per_day}) cannot exceed max_sessions ({max_sessions})")
            if max_per_day < min_sessions and min_sessions <= 3:
                # Only warn if min_sessions is reasonable (<=3)
                debug_log(f"Warning: max_per_day ({max_per_day}) < min_sessions ({min_sessions}) for '{name}'", 1)
            
            # Find interested attendees
            interested = set()
            maybe = set()
            
            # If session is required, ALL attendees are interested
            if required:
                interested = all_attendee_names.copy()
                debug_log(f"  Session '{name}' is required - adding all {len(interested)} attendees", 1)
            else:
                # Only add those who explicitly signed up
                for attendee, interests in attendees.items():
                    if name in interests:
                        if interests[name] == 'yes':
                            interested.add(attendee)
                        elif interests[name] == 'maybe':
                            maybe.add(attendee)
            
            sessions.append(Session(
                name=name,
                max_attendees=max_attendees,
                presenters=presenters,
                length=length,
                required=required,
                priority=priority,
                min_sessions=min_sessions,
                max_sessions=max_sessions,
                max_per_day=max_per_day,
                interested_attendees=interested,
                maybe_attendees=maybe
            ))
            
        except ValueError as e:
            raise SchedulingError(f"Error in sessions file row {idx + 2} ('{name}'): {str(e)}")
    
    return sessions


def validate_locations(df: pd.DataFrame) -> List[Location]:
    """Validate and parse locations data"""
    if df.empty:
        raise SchedulingError("Locations file is empty")
    
    required_cols = ['location_name', 'soft_limit', 'hard_limit', 'time_available']
    optional_cols = ['days_available']
    
    # Check column names (case-insensitive)
    df_cols_lower = [col.lower() for col in df.columns]
    missing_cols = []
    col_mapping = {}
    
    for req_col in required_cols:
        found = False
        for i, df_col in enumerate(df_cols_lower):
            if req_col.lower() == df_col:
                col_mapping[req_col] = df.columns[i]
                found = True
                break
        if not found:
            missing_cols.append(req_col)
    
    if missing_cols:
        raise SchedulingError(
            f"Missing required columns in locations file: {', '.join(missing_cols)}\n"
            f"Expected columns: {', '.join(required_cols)}"
        )
    
    # Check for optional columns
    for opt_col in optional_cols:
        for i, df_col in enumerate(df_cols_lower):
            if opt_col.lower() == df_col:
                col_mapping[opt_col] = df.columns[i]
                break
    
    locations = []
    
    for idx, row in df.iterrows():
        try:
            name = str(row[col_mapping['location_name']]).strip()
            soft_limit = int(row[col_mapping['soft_limit']])
            hard_limit = int(row[col_mapping['hard_limit']])
            
            if soft_limit <= 0:
                raise ValueError(f"soft_limit must be > 0, got {soft_limit}")
            if hard_limit <= 0:
                raise ValueError(f"hard_limit must be > 0, got {hard_limit}")
            if soft_limit > hard_limit:
                raise ValueError(f"soft_limit ({soft_limit}) cannot exceed hard_limit ({hard_limit})")
            
            time_available_str = str(row[col_mapping['time_available']]).strip()
            time_available = parse_time_list(time_available_str)
            
            # Parse days_available if column exists
            days_available = None
            if 'days_available' in col_mapping:
                days_str = str(row[col_mapping['days_available']]).strip()
                if days_str and not pd.isna(row[col_mapping['days_available']]):
                    try:
                        # Parse CSV string of day indices (0-based)
                        days_available = set()
                        for day_str in days_str.split(','):
                            day_str = day_str.strip()
                            if day_str:
                                day_num = int(day_str)
                                if day_num < 0:
                                    raise ValueError(f"Day index must be >= 0, got {day_num}")
                                days_available.add(day_num)
                    except ValueError as e:
                        raise ValueError(f"Invalid days_available format: {e}")
            
            locations.append(Location(
                name=name,
                soft_limit=soft_limit,
                hard_limit=hard_limit,
                time_available=time_available,
                days_available=days_available
            ))
            
        except ValueError as e:
            raise SchedulingError(f"Error in locations file row {idx + 2} ('{name}'): {str(e)}")
    
    return locations


def parse_day_names(day_names_str: str, num_days: int) -> List[str]:
    """
    Parse day names from CSV string
    
    Args:
        day_names_str: CSV string of day names
        num_days: Expected number of days
        
    Returns:
        List of day names
        
    Raises:
        SchedulingError: If number of names doesn't match days
    """
    if not day_names_str:
        # Default to "Day 1", "Day 2", etc.
        return [f"Day {i + 1}" for i in range(num_days)]
    
    # Parse CSV string
    day_names = [name.strip() for name in day_names_str.split(',')]
    
    if len(day_names) != num_days:
        raise SchedulingError(
            f"Number of day names ({len(day_names)}) doesn't match number of days ({num_days}). "
            f"Provide exactly {num_days} comma-separated names."
        )
    
    debug_log(f"Using custom day names: {day_names}")
    
    return day_names


def parse_blackout(blackout_str: str) -> List[Dict[str, Any]]:
    """Parse blackout JSON string"""
    if not blackout_str:
        return []
    
    try:
        blackouts = json.loads(blackout_str)
        if not isinstance(blackouts, list):
            raise ValueError("Blackout must be a JSON array")
        
        parsed = []
        for i, blackout in enumerate(blackouts):
            if not isinstance(blackout, dict):
                raise ValueError(f"Blackout entry {i} must be a JSON object")
            
            if 'day' not in blackout:
                raise ValueError(f"Blackout entry {i} missing 'day' field")
            if 'time' not in blackout:
                raise ValueError(f"Blackout entry {i} missing 'time' field")
            
            day = int(blackout['day'])
            if day < 0:
                raise ValueError(f"Blackout entry {i}: day must be >= 0")
            
            time_ranges = []
            for time_str in blackout['time']:
                time_ranges.append(parse_time_range(time_str))
            
            name = blackout.get('name', 'blackout')
            
            parsed.append({
                'day': day,
                'time_ranges': time_ranges,
                'name': name
            })
        
        return parsed
        
    except json.JSONDecodeError as e:
        raise SchedulingError(f"Invalid JSON in blackout parameter: {str(e)}")
    except ValueError as e:
        raise SchedulingError(f"Invalid blackout format: {str(e)}")


def generate_time_slots(
    days: int,
    global_time: Optional[List[Tuple[datetime, datetime]]],
    locations: List[Location],
    blackouts: List[Dict[str, Any]],
    slice_duration: timedelta
) -> Dict[int, List[TimeSlot]]:
    """Generate all available time slots per day"""
    debug_log(f"Generating time slots for {days} days with {slice_duration} slices")
    
    slots_by_day = defaultdict(list)
    
    for day in range(days):
        # Start with location availability
        day_ranges = []
        for location in locations:
            # Skip locations not available on this day
            if location.days_available is not None and day not in location.days_available:
                continue
                
            for start, end in location.time_available:
                if global_time:
                    # Intersect with global time constraints
                    for g_start, g_end in global_time:
                        intersect_start = max(start, g_start)
                        intersect_end = min(end, g_end)
                        if intersect_start < intersect_end:
                            day_ranges.append((intersect_start, intersect_end))
                else:
                    day_ranges.append((start, end))
        
        # Merge overlapping ranges
        if day_ranges:
            day_ranges.sort()
            merged = [day_ranges[0]]
            for start, end in day_ranges[1:]:
                if start <= merged[-1][1]:
                    merged[-1] = (merged[-1][0], max(merged[-1][1], end))
                else:
                    merged.append((start, end))
            
            # Generate time slots
            for start, end in merged:
                current = start
                while current + slice_duration <= end:
                    slot = TimeSlot(day, current, current + slice_duration)
                    
                    # Check blackouts
                    is_blackout = False
                    for blackout in blackouts:
                        if blackout['day'] == day:
                            for b_start, b_end in blackout['time_ranges']:
                                if (current >= b_start and current < b_end) or \
                                   (current + slice_duration > b_start and current + slice_duration <= b_end):
                                    is_blackout = True
                                    break
                        if is_blackout:
                            break
                    
                    if not is_blackout:
                        slots_by_day[day].append(slot)
                    
                    current += slice_duration
    
    return dict(slots_by_day)


class Scheduler:
    """Main scheduling algorithm implementation"""
    
    def __init__(
        self,
        sessions: List[Session],
        locations: List[Location],
        attendees: Dict[str, Dict[str, str]],
        time_slots: Dict[int, List[TimeSlot]],
        include_overlaps: bool = False
    ):
        # Sort sessions: required first, then by priority (lower number = higher priority), then by number of interested attendees
        self.sessions = sorted(sessions, key=lambda s: (-s.required, s.priority, -len(s.interested_attendees)))
        self.locations = locations
        self.attendees = attendees
        self.time_slots = time_slots
        self.include_overlaps = include_overlaps
        self.schedule: List[ScheduledSession] = []
        self.unscheduled_sessions: List[Tuple[Session, str]] = []
        # Track attendees who have already been scheduled for each session name
        self.scheduled_attendees_by_session: Dict[str, Set[str]] = defaultdict(set)
        # Track scheduling errors for required sessions
        self.scheduling_errors: List[str] = []
    
    def is_presenter_available(self, presenter: str, time_slot: TimeSlot) -> bool:
        """Check if presenter is available during time slot"""
        for scheduled in self.schedule:
            if presenter in scheduled.session.presenters and \
               scheduled.time_slot.overlaps_with(time_slot):
                return False
        return True
    
    def is_location_available(self, location: Location, time_slot: TimeSlot) -> bool:
        """Check if location is available during time slot"""
        for scheduled in self.schedule:
            if scheduled.location.name == location.name and \
               scheduled.time_slot.overlaps_with(time_slot):
                return False
        return True
    
    def get_attendee_conflicts(self, attendees: Set[str], time_slot: TimeSlot) -> Set[str]:
        """Get attendees who have conflicts at this time"""
        conflicts = set()
        for scheduled in self.schedule:
            if scheduled.time_slot.overlaps_with(time_slot):
                conflicts.update(scheduled.attendees & attendees)
        return conflicts
    
    def fits_in_location(self, session: Session, location: Location, time_slot: TimeSlot) -> bool:
        """Check if session fits in location during time slot"""
        # Check day availability first
        if location.days_available is not None and time_slot.day not in location.days_available:
            if DEBUG:
                debug_log(f"        Location not available on day {time_slot.day}", 6)
            return False
        
        # Check time availability
        slot_fits = False
        for start, end in location.time_available:
            if time_slot.start_time >= start and time_slot.end_time <= end:
                slot_fits = True
                break
        
        if not slot_fits:
            if DEBUG:
                debug_log(f"        Time {format_time(time_slot.start_time)}-{format_time(time_slot.end_time)} not in location's available times", 6)
            return False
        
        # Check capacity
        num_attendees = len(session.interested_attendees)
        if session.max_attendees > 0:
            num_attendees = min(num_attendees, session.max_attendees)
        
        if num_attendees > location.hard_limit:
            if DEBUG:
                debug_log(f"        {num_attendees} attendees exceeds location capacity of {location.hard_limit}", 6)
            return False
            
        return True
    
    def calculate_session_duration_slots(self, session: Session, slice_duration: timedelta) -> int:
        """Calculate how many time slots a session needs"""
        session_duration = timedelta(minutes=session.length)
        slots_needed = int(session_duration / slice_duration)
        if session_duration % slice_duration:
            slots_needed += 1
        return slots_needed
    
    def find_consecutive_slots(
        self, 
        day: int, 
        slots_needed: int,
        slice_duration: timedelta
    ) -> List[List[TimeSlot]]:
        """Find all possible consecutive time slot groups for a session"""
        if day not in self.time_slots:
            return []
        
        day_slots = self.time_slots[day]
        if len(day_slots) < slots_needed:
            return []
        
        consecutive_groups = []
        
        for i in range(len(day_slots) - slots_needed + 1):
            # Check if slots are consecutive
            is_consecutive = True
            for j in range(slots_needed - 1):
                if day_slots[i + j].end_time != day_slots[i + j + 1].start_time:
                    is_consecutive = False
                    break
            
            if is_consecutive:
                consecutive_groups.append(day_slots[i:i + slots_needed])
        
        return consecutive_groups
    
    def schedule_session_instance(
        self, 
        session: Session, 
        instance_num: int,
        sessions_per_day: Dict[int, int]
    ) -> bool:
        """Try to schedule one instance of a session"""
        debug_log(f"  Trying to schedule instance {instance_num + 1} of {session.name}", 1)
        
        slice_duration = None
        if self.time_slots:
            first_day_slots = next(iter(self.time_slots.values()))
            if len(first_day_slots) >= 2:
                slice_duration = first_day_slots[1].start_time - first_day_slots[0].start_time
            else:
                slice_duration = timedelta(hours=1)
        else:
            slice_duration = timedelta(hours=1)
        
        slots_needed = self.calculate_session_duration_slots(session, slice_duration)
        debug_log(f"  Session needs {slots_needed} time slots ({session.length} minutes)", 2)
        
        # Collect all possible slots with their conflict scores
        possible_slots = []
        
        # Get available attendees for this session (not already scheduled)
        available_attendees = session.interested_attendees - self.scheduled_attendees_by_session[session.name]
        
        # Try each day
        for day in sorted(self.time_slots.keys()):
            debug_log(f"  Day {day + 1}:", 2)
            
            # Check max_per_day constraint
            if sessions_per_day[session.name].get(day, 0) >= session.max_per_day:
                debug_log(f"    ✗ Already scheduled {sessions_per_day[session.name].get(day, 0)} sessions (max: {session.max_per_day})", 3)
                continue
            
            # Get possible time slot groups
            slot_groups = self.find_consecutive_slots(day, slots_needed, slice_duration)
            
            if not slot_groups:
                debug_log(f"    ✗ No consecutive slots available for {slots_needed} time slots", 3)
                continue
            
            # Try each location
            for location in self.locations:
                debug_log(f"    Trying location: {location.name}", 3)
                
                # Try each time slot group
                for slot_group in slot_groups:
                    # Create combined time slot
                    combined_slot = TimeSlot(
                        day=day,
                        start_time=slot_group[0].start_time,
                        end_time=slot_group[-1].end_time
                    )
                    
                    debug_log(f"      Time slot: {format_time(combined_slot.start_time)}-{format_time(combined_slot.end_time)}", 4)
                    
                    # Check if session fits in location
                    if not self.fits_in_location(session, location, combined_slot):
                        debug_log(f"      ✗ Session doesn't fit in location (capacity or time)", 5)
                        continue
                    
                    # Check if location is available at this time
                    if not self.is_location_available(location, combined_slot):
                        debug_log(f"      ✗ Location already occupied", 5)
                        continue
                    
                    # Check presenter availability
                    presenters_available = all(
                        self.is_presenter_available(p, combined_slot)
                        for p in session.presenters
                    )
                    if not presenters_available:
                        debug_log(f"      ✗ Presenter(s) not available", 5)
                        continue
                    
                    # If no attendees are available (all already scheduled), skip this slot
                    if not available_attendees:
                        debug_log(f"      ✗ All interested attendees already scheduled for {session.name}", 5)
                        continue
                    
                    # Check attendee conflicts (only for available attendees)
                    conflicts = self.get_attendee_conflicts(
                        available_attendees, 
                        combined_slot
                    )
                    
                    # For required sessions, we should still schedule them even with conflicts
                    # Only skip if ALL available attendees have conflicts
                    if session.required and len(conflicts) == len(available_attendees) and not self.include_overlaps:
                        debug_log(f"      ✗ All available attendees have conflicts for required session", 5)
                        continue
                    
                    # Calculate score (minimize conflicts)
                    score = len(conflicts)
                    
                    # Add to possible slots
                    possible_slots.append({
                        'location': location,
                        'time_slot': combined_slot,
                        'conflicts': conflicts,
                        'score': score,
                        'day': day
                    })
                    
                    debug_log(f"      ✓ Added as possible slot (score={score}, conflicts={len(conflicts)})", 5)
        
        # If no possible slots, return False
        if not possible_slots:
            debug_log(f"  ✗ No possible slots found for {session.name} instance {instance_num + 1}", 1)
            debug_log(f"    Available attendees: {len(available_attendees)}", 2)
            if len(available_attendees) == 0:
                debug_log(f"    Reason: All {len(session.interested_attendees)} interested attendees already scheduled", 2)
            else:
                debug_log(f"    Check: location capacity, time availability, presenter conflicts", 2)
            return False
        
        # Sort by score (fewest conflicts first), then by day (earlier days first)
        possible_slots.sort(key=lambda x: (x['score'], x['day']))
        
        # Use the best slot (fewest conflicts)
        best_slot = possible_slots[0]
        
        # Schedule the session
        scheduled_attendees = available_attendees - best_slot['conflicts']
        if self.include_overlaps:
            scheduled_attendees = available_attendees
        
        # Apply max_attendees limit
        if session.max_attendees > 0 and len(scheduled_attendees) > session.max_attendees:
            # Sort attendees to ensure consistent selection
            sorted_attendees = sorted(list(scheduled_attendees))
            scheduled_attendees = set(sorted_attendees[:session.max_attendees])
        
        self.schedule.append(ScheduledSession(
            session=session,
            location=best_slot['location'],
            time_slot=best_slot['time_slot'],
            attendees=scheduled_attendees
        ))
        
        # Update tracking of scheduled attendees for this session
        self.scheduled_attendees_by_session[session.name].update(scheduled_attendees)
        
        sessions_per_day[session.name][best_slot['day']] = \
            sessions_per_day[session.name].get(best_slot['day'], 0) + 1
        
        debug_log(f"      ✓ Scheduled successfully with {len(scheduled_attendees)} attendees at {format_time(best_slot['time_slot'].start_time)}", 5)
        if best_slot['conflicts']:
            debug_log(f"        Conflicts: {len(best_slot['conflicts'])} attendees", 6)
        
        return True
    
    def run(self):
        """Run the scheduling algorithm"""
        debug_log(f"Starting scheduler with {len(self.sessions)} sessions")
        debug_log(f"Available locations: {[loc.name for loc in self.locations]}")
        debug_log(f"Include overlaps: {self.include_overlaps}")
        
        # Track sessions scheduled per day
        sessions_per_day = defaultdict(lambda: defaultdict(int))
        
        # Schedule each session
        for session in self.sessions:
            debug_log(f"\nScheduling session: {session.name} (priority={session.priority})")
            scheduled_count = 0
            
            # Determine target number of sessions
            if session.max_sessions == 0:
                # Auto-determine based on attendee count and max_attendees per session
                if session.max_attendees > 0:
                    # Calculate how many sessions needed to accommodate all interested attendees
                    total_interested = len(session.interested_attendees)
                    sessions_needed = (total_interested + session.max_attendees - 1) // session.max_attendees
                    target_sessions = max(session.min_sessions, min(sessions_needed, 10))  # Cap at 10 for sanity
                else:
                    # No attendee limit, so use min_sessions
                    target_sessions = session.min_sessions
                debug_log(f"  Auto-determined target sessions: {target_sessions} (min={session.min_sessions})", 1)
            else:
                # Use the specified max as target
                target_sessions = session.max_sessions
            
            # Try to schedule up to target_sessions
            attempts = 0
            consecutive_failures = 0
            
            while scheduled_count < target_sessions and attempts < target_sessions * 2:
                if self.schedule_session_instance(session, scheduled_count, sessions_per_day):
                    scheduled_count += 1
                    consecutive_failures = 0
                    
                    # For auto-determine, check if we've scheduled enough
                    if session.max_sessions == 0:
                        # Check if all interested attendees have been scheduled
                        unscheduled = session.interested_attendees - self.scheduled_attendees_by_session[session.name]
                        if len(unscheduled) == 0:
                            debug_log(f"  All interested attendees scheduled, stopping at {scheduled_count} sessions", 1)
                            break
                        elif session.max_attendees > 0 and len(unscheduled) < session.max_attendees * 0.5:
                            # Less than half capacity remaining, might not be worth another session
                            debug_log(f"  Only {len(unscheduled)} attendees remaining, stopping at {scheduled_count} sessions", 1)
                            break
                else:
                    consecutive_failures += 1
                    if consecutive_failures >= 3:
                        # Stop trying after 3 consecutive failures
                        debug_log(f"  Stopping after 3 consecutive scheduling failures", 1)
                        break
                
                attempts += 1
            
            # Check if we met minimum requirements
            if scheduled_count < session.min_sessions:
                # Provide more context about why scheduling failed
                details = []
                if len(session.interested_attendees) == 0:
                    details.append("no attendees signed up")
                else:
                    details.append(f"{len(session.interested_attendees)} interested attendees")
                
                if len(session.presenters) > 0:
                    details.append(f"presenter(s): {', '.join(session.presenters)}")
                
                details.append(f"{session.length} minutes")
                
                if session.required:
                    self.scheduling_errors.append(
                        f"Unable to schedule minimum required sessions for '{session.name}'. "
                        f"Scheduled {scheduled_count} but minimum is {session.min_sessions}. "
                        f"Details: {', '.join(details)}"
                    )
                else:
                    self.unscheduled_sessions.append(
                        (session, f"Could only schedule {scheduled_count} of minimum {session.min_sessions} sessions ({', '.join(details)})")
                    )
            elif scheduled_count < target_sessions:
                # Scheduled some but not all target sessions
                debug_log(f"  Scheduled {scheduled_count} of target {target_sessions} sessions", 1)


def format_time(dt: datetime) -> str:
    """Format datetime as time string"""
    return dt.strftime("%-I:%M%p").lower()


def generate_markdown_output(
    schedule: List[ScheduledSession],
    locations: List[Location],
    days: int,
    time_slots: Dict[int, List[TimeSlot]],
    blackouts: List[Dict[str, Any]],
    slice_duration: timedelta,
    day_names: List[str]
) -> str:
    """Generate markdown table output"""
    output = []
    
    for day in range(days):
        output.append(f"## {day_names[day]}\n")
        
        if day not in time_slots or not time_slots[day]:
            output.append("*No sessions scheduled*\n")
            continue
        
        # Create time slot index
        all_times = set()
        for slot in time_slots[day]:
            all_times.add(slot.start_time)
        
        # Add blackout times
        for blackout in blackouts:
            if blackout['day'] == day:
                for start, end in blackout['time_ranges']:
                    current = start
                    while current < end:
                        all_times.add(current)
                        current += slice_duration
        
        sorted_times = sorted(all_times)
        
        # Create table header (deduplicate location names for display)
        unique_location_names = []
        seen_names = set()
        for loc in locations:
            if loc.name not in seen_names:
                unique_location_names.append(loc.name)
                seen_names.add(loc.name)
        
        header = ["Time"] + unique_location_names
        output.append("| " + " | ".join(header) + " |")
        output.append("|" + "|".join(["-" * (len(h) + 2) for h in header]) + "|")
        
        # Fill in schedule
        for time in sorted_times:
            row = [format_time(time)]
            
            # Check if this is a blackout time
            is_blackout = False
            blackout_name = "blackout"
            for blackout in blackouts:
                if blackout['day'] == day:
                    for start, end in blackout['time_ranges']:
                        if time >= start and time < end:
                            is_blackout = True
                            blackout_name = blackout['name']
                            break
            
            if is_blackout:
                for _ in unique_location_names:
                    row.append(f"-- {blackout_name} --")
            else:
                for location_name in unique_location_names:
                    # Find session at this time and location name
                    session_found = False
                    for scheduled in schedule:
                        if (scheduled.time_slot.day == day and
                            scheduled.location.name == location_name and
                            time >= scheduled.time_slot.start_time and
                            time < scheduled.time_slot.end_time):
                            
                            if time == scheduled.time_slot.start_time:
                                # First slot of session - show name and count
                                overlaps = ""
                                if any("(overlap)" in str(a) for a in scheduled.attendees):
                                    overlaps = " ⚠️"
                                row.append(f"{scheduled.session.name} ({len(scheduled.attendees)}){overlaps}")
                            else:
                                # Continuation of session
                                row.append("↓")
                            session_found = True
                            break
                    
                    if not session_found:
                        row.append("-")
            
            output.append("| " + " | ".join(row) + " |")
        
        output.append("")
    
    return "\n".join(output)


def generate_csv_output(
    schedule: List[ScheduledSession],
    locations: List[Location],
    days: int,
    time_slots: Dict[int, List[TimeSlot]],
    blackouts: List[Dict[str, Any]],
    slice_duration: timedelta,
    day_names: List[str]
) -> str:
    """Generate CSV output"""
    output = []
    writer = StringWriter()
    
    # Write header (deduplicate location names)
    unique_location_names = []
    seen_names = set()
    for loc in locations:
        if loc.name not in seen_names:
            unique_location_names.append(loc.name)
            seen_names.add(loc.name)
    
    header = ["Day", "Time"] + unique_location_names
    writer.writerow(header)
    
    for day in range(days):
        if day not in time_slots or not time_slots[day]:
            continue
        
        # Create time slot index
        all_times = set()
        for slot in time_slots[day]:
            all_times.add(slot.start_time)
        
        # Add blackout times
        for blackout in blackouts:
            if blackout['day'] == day:
                for start, end in blackout['time_ranges']:
                    current = start
                    while current < end:
                        all_times.add(current)
                        current += slice_duration
        
        sorted_times = sorted(all_times)
        
        # Fill in schedule
        for time in sorted_times:
            row = [day_names[day], format_time(time)]
            
            # Check if this is a blackout time
            is_blackout = False
            blackout_name = "blackout"
            for blackout in blackouts:
                if blackout['day'] == day:
                    for start, end in blackout['time_ranges']:
                        if time >= start and time < end:
                            is_blackout = True
                            blackout_name = blackout['name']
                            break
            
            if is_blackout:
                for _ in unique_location_names:
                    row.append(f"{blackout_name} (blackout)")
            else:
                for location_name in unique_location_names:
                    # Find session at this time and location
                    session_found = False
                    for scheduled in schedule:
                        if (scheduled.time_slot.day == day and
                            scheduled.location.name == location_name and
                            time >= scheduled.time_slot.start_time and
                            time < scheduled.time_slot.end_time):
                            
                            if time == scheduled.time_slot.start_time:
                                row.append(f"{scheduled.session.name} ({len(scheduled.attendees)})")
                            else:
                                row.append(scheduled.session.name)
                            session_found = True
                            break
                    
                    if not session_found:
                        row.append("---")
            
            writer.writerow(row)
    
    return writer.getvalue()


def generate_roster_markdown(
    schedule: List[ScheduledSession],
    day_names: List[str]
) -> str:
    """Generate markdown roster output with session details"""
    output = []
    output.append("# Session Roster\n")
    
    # Group sessions by day
    sessions_by_day = defaultdict(list)
    for scheduled in schedule:
        sessions_by_day[scheduled.time_slot.day].append(scheduled)
    
    # Sort days and sessions within each day
    for day in sorted(sessions_by_day.keys()):
        output.append(f"## {day_names[day]}\n")
        
        # Sort sessions by start time
        day_sessions = sorted(sessions_by_day[day], key=lambda s: s.time_slot.start_time)
        
        for scheduled in day_sessions:
            output.append(f"### {scheduled.session.name}\n")
            output.append(f"- **Time**: {format_time(scheduled.time_slot.start_time)} - {format_time(scheduled.time_slot.end_time)}")
            output.append(f"- **Location**: {scheduled.location.name}")
            output.append(f"- **Duration**: {scheduled.session.length} minutes")
            
            if scheduled.session.presenters:
                output.append(f"- **Presenter(s)**: {', '.join(scheduled.session.presenters)}")
            
            output.append(f"- **Attendees** ({len(scheduled.attendees)}):")
            if scheduled.attendees:
                # Sort attendees alphabetically
                for attendee in sorted(scheduled.attendees):
                    # Check if this is an overlap attendee
                    if "(overlap)" in str(attendee):
                        output.append(f"  - {attendee} ⚠️")
                    else:
                        output.append(f"  - {attendee}")
            else:
                output.append("  - No attendees scheduled")
            
            output.append("")  # Empty line between sessions
    
    return "\n".join(output)


def generate_roster_csv(
    schedule: List[ScheduledSession],
    day_names: List[str]
) -> str:
    """Generate CSV roster output with session details"""
    writer = StringWriter()
    
    # Write header
    header = [
        "Day", "Session", "Start Time", "End Time", "Duration (min)",
        "Location", "Presenters", "Attendee Count", "Attendees"
    ]
    writer.writerow(header)
    
    # Sort sessions by day and time
    sorted_schedule = sorted(
        schedule,
        key=lambda s: (s.time_slot.day, s.time_slot.start_time)
    )
    
    for scheduled in sorted_schedule:
        row = [
            day_names[scheduled.time_slot.day],
            scheduled.session.name,
            format_time(scheduled.time_slot.start_time),
            format_time(scheduled.time_slot.end_time),
            scheduled.session.length,
            scheduled.location.name,
            "; ".join(scheduled.session.presenters),
            len(scheduled.attendees),
            "; ".join(sorted(str(a) for a in scheduled.attendees))
        ]
        writer.writerow(row)
    
    return writer.getvalue()


def generate_roster_xlsx(
    schedule: List[ScheduledSession],
    output_file: str,
    day_names: List[str]
):
    """Generate Excel roster output with session details"""
    if not XLSX_SUPPORT:
        raise SchedulingError("Excel output requires openpyxl. Install with: pip install openpyxl")
    
    from openpyxl import Workbook
    from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
    from openpyxl.utils import get_column_letter
    
    wb = Workbook()
    ws = wb.active
    ws.title = "Session Roster"
    
    # Styles
    header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
    header_font = Font(color="FFFFFF", bold=True)
    day_fill = PatternFill(start_color="D9E1F2", end_color="D9E1F2", fill_type="solid")
    day_font = Font(bold=True, size=12)
    session_fill = PatternFill(start_color="E7F3FF", end_color="E7F3FF", fill_type="solid")
    border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    
    # Write header
    headers = [
        "Day", "Session", "Time", "Duration", "Location", 
        "Presenter(s)", "# Attendees", "Attendee List"
    ]
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col, value=header)
        cell.fill = header_fill
        cell.font = header_font
        cell.alignment = Alignment(horizontal="center", vertical="center")
        cell.border = border
    
    # Group and sort sessions
    sessions_by_day = defaultdict(list)
    for scheduled in schedule:
        sessions_by_day[scheduled.time_slot.day].append(scheduled)
    
    row_num = 2
    for day in sorted(sessions_by_day.keys()):
        # Day header row
        ws.merge_cells(f'A{row_num}:H{row_num}')
        day_cell = ws.cell(row=row_num, column=1, value=day_names[day])
        day_cell.fill = day_fill
        day_cell.font = day_font
        day_cell.alignment = Alignment(horizontal="center", vertical="center")
        for col in range(1, 9):
            ws.cell(row=row_num, column=col).border = border
        row_num += 1
        
        # Sort sessions by start time
        day_sessions = sorted(sessions_by_day[day], key=lambda s: s.time_slot.start_time)
        
        for scheduled in day_sessions:
            time_str = f"{format_time(scheduled.time_slot.start_time)} - {format_time(scheduled.time_slot.end_time)}"
            duration_str = f"{scheduled.session.length} min"
            presenters_str = ", ".join(scheduled.session.presenters) if scheduled.session.presenters else "N/A"
            attendees_str = ", ".join(sorted(str(a) for a in scheduled.attendees)) if scheduled.attendees else "No attendees"
            
            # Check for overlaps in attendees
            has_overlaps = any("(overlap)" in str(a) for a in scheduled.attendees)
            
            values = [
                "",  # Day column (empty for session rows)
                scheduled.session.name,
                time_str,
                duration_str,
                scheduled.location.name,
                presenters_str,
                len(scheduled.attendees),
                attendees_str
            ]
            
            for col, value in enumerate(values, 1):
                cell = ws.cell(row=row_num, column=col, value=value)
                if col == 2:  # Session name
                    cell.fill = session_fill
                    cell.font = Font(bold=True)
                cell.alignment = Alignment(
                    horizontal="left" if col in [2, 6, 8] else "center",
                    vertical="center",
                    wrap_text=(col == 8)  # Wrap attendee list
                )
                cell.border = border
                
                # Add warning color for overlaps
                if has_overlaps and col == 7:
                    cell.font = Font(color="FF0000")
            
            row_num += 1
    
    # Add summary sheet
    ws_summary = wb.create_sheet(title="Summary")
    ws_summary.append(["Session Roster Summary"])
    ws_summary.append([])
    ws_summary.append(["Total Sessions Scheduled:", len(schedule)])
    ws_summary.append(["Total Unique Sessions:", len(set(s.session.name for s in schedule))])
    ws_summary.append([])
    
    # Session counts
    session_counts = defaultdict(int)
    total_attendees_by_session = defaultdict(set)
    for scheduled in schedule:
        session_counts[scheduled.session.name] += 1
        total_attendees_by_session[scheduled.session.name].update(scheduled.attendees)
    
    ws_summary.append(["Session", "Times Scheduled", "Total Unique Attendees"])
    for session_name in sorted(session_counts.keys()):
        ws_summary.append([
            session_name,
            session_counts[session_name],
            len(total_attendees_by_session[session_name])
        ])
    
    # Adjust column widths
    for col in range(1, 9):
        if col == 8:  # Attendee list column
            ws.column_dimensions[get_column_letter(col)].width = 50
        elif col == 2:  # Session name
            ws.column_dimensions[get_column_letter(col)].width = 30
        elif col == 6:  # Presenters
            ws.column_dimensions[get_column_letter(col)].width = 25
        else:
            ws.column_dimensions[get_column_letter(col)].width = 15
    
    # Set row heights for better readability
    for row in ws.iter_rows():
        ws.row_dimensions[row[0].row].height = 20
    
    wb.save(output_file)


def generate_xlsx_output(
    schedule: List[ScheduledSession],
    locations: List[Location],
    days: int,
    time_slots: Dict[int, List[TimeSlot]],
    blackouts: List[Dict[str, Any]],
    slice_duration: timedelta,
    output_file: str,
    day_names: List[str]
):
    """Generate Excel output"""
    if not XLSX_SUPPORT:
        raise SchedulingError("Excel output requires openpyxl. Install with: pip install openpyxl")
    
    from openpyxl import Workbook
    from openpyxl.styles import PatternFill, Font, Alignment
    
    wb = Workbook()
    
    # Remove default sheet
    wb.remove(wb.active)
    
    # Colors
    header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
    header_font = Font(color="FFFFFF", bold=True)
    blackout_fill = PatternFill(start_color="808080", end_color="808080", fill_type="solid")
    session_fills = [
        PatternFill(start_color="E7F3FF", end_color="E7F3FF", fill_type="solid"),
        PatternFill(start_color="FFF2CC", end_color="FFF2CC", fill_type="solid"),
        PatternFill(start_color="E7FFE7", end_color="E7FFE7", fill_type="solid"),
        PatternFill(start_color="FFE7E7", end_color="FFE7E7", fill_type="solid"),
    ]
    
    session_colors = {}
    color_idx = 0
    
    for day in range(days):
        # Use custom day name for sheet title, but truncate if too long for Excel
        sheet_title = day_names[day][:31]  # Excel has 31 char limit for sheet names
        ws = wb.create_sheet(title=sheet_title)
        
        if day not in time_slots or not time_slots[day]:
            ws.append(["No sessions scheduled"])
            continue
        
        # Create time slot index
        all_times = set()
        for slot in time_slots[day]:
            all_times.add(slot.start_time)
        
        # Add blackout times
        for blackout in blackouts:
            if blackout['day'] == day:
                for start, end in blackout['time_ranges']:
                    current = start
                    while current < end:
                        all_times.add(current)
                        current += slice_duration
        
        sorted_times = sorted(all_times)
        
        # Write header (deduplicate location names)
        unique_location_names = []
        seen_names = set()
        for loc in locations:
            if loc.name not in seen_names:
                unique_location_names.append(loc.name)
                seen_names.add(loc.name)
        
        header = ["Time"] + unique_location_names
        ws.append(header)
        
        # Style header
        for col in range(1, len(header) + 1):
            cell = ws.cell(row=1, column=col)
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = Alignment(horizontal="center")
        
        # Fill in schedule
        for time_idx, time in enumerate(sorted_times):
            row = [format_time(time)]
            
            # Check if this is a blackout time
            is_blackout = False
            blackout_name = "blackout"
            for blackout in blackouts:
                if blackout['day'] == day:
                    for start, end in blackout['time_ranges']:
                        if time >= start and time < end:
                            is_blackout = True
                            blackout_name = blackout['name']
                            break
            
            if is_blackout:
                for _ in unique_location_names:
                    row.append(blackout_name)
            else:
                for location_name in unique_location_names:
                    # Find session at this time and location
                    session_found = False
                    for scheduled in schedule:
                        if (scheduled.time_slot.day == day and
                            scheduled.location.name == location_name and
                            time >= scheduled.time_slot.start_time and
                            time < scheduled.time_slot.end_time):
                            
                            if time == scheduled.time_slot.start_time:
                                row.append(f"{scheduled.session.name}\n({len(scheduled.attendees)} attendees)")
                            else:
                                row.append(scheduled.session.name)
                            session_found = True
                            
                            # Assign color to session
                            if scheduled.session.name not in session_colors:
                                session_colors[scheduled.session.name] = session_fills[color_idx % len(session_fills)]
                                color_idx += 1
                            
                            break
                    
                    if not session_found:
                        row.append("")
            
            ws.append(row)
            
            # Style the row
            row_num = time_idx + 2
            if is_blackout:
                for col in range(2, len(header) + 1):
                    cell = ws.cell(row=row_num, column=col)
                    cell.fill = blackout_fill
                    cell.alignment = Alignment(horizontal="center")
            else:
                # Color code sessions
                for col, location_name in enumerate(unique_location_names, start=2):
                    for scheduled in schedule:
                        if (scheduled.time_slot.day == day and
                            scheduled.location.name == location_name and
                            time >= scheduled.time_slot.start_time and
                            time < scheduled.time_slot.end_time):
                            
                            cell = ws.cell(row=row_num, column=col)
                            cell.fill = session_colors[scheduled.session.name]
                            cell.alignment = Alignment(horizontal="center", wrap_text=True)
                            break
        
        # Adjust column widths
        for col in range(1, len(header) + 1):
            ws.column_dimensions[chr(64 + col)].width = 20
    
    # Add summary sheet
    ws_summary = wb.create_sheet(title="Summary", index=0)
    ws_summary.append(["Scheduling Summary"])
    ws_summary.append([])
    ws_summary.append(["Sessions Scheduled:"])
    
    # Count sessions
    session_counts = defaultdict(int)
    for scheduled in schedule:
        session_counts[scheduled.session.name] += 1
    
    for session_name, count in sorted(session_counts.items()):
        ws_summary.append([f"  {session_name}: {count} sessions"])
    
    ws_summary.append([])
    ws_summary.append(["Total Conflicts:", sum(1 for s in schedule if any("(overlap)" in str(a) for a in s.attendees))])
    
    wb.save(output_file)


def create_arg_parser():
    """Create argument parser with detailed help"""
    parser = argparse.ArgumentParser(
        prog='simple_schedule',
        description='Simple Schedule - Multi-session event scheduling tool',
        epilog='''Examples:
  # Basic scheduling for a single-day event
  simple_schedule --attendees attendees.csv --sessions sessions.csv --locations rooms.csv

  # Multi-day conference with lunch breaks
  simple_schedule --attendees people.xlsx --sessions talks.xlsx --locations venues.xlsx \\
      --days 3 --time "9am-12pm,1pm-5pm" --slice 30m \\
      --blackout '[{"day": 0, "time": ["12pm-1pm"], "name": "Lunch"},
                   {"day": 1, "time": ["12pm-1pm"], "name": "Lunch"},
                   {"day": 2, "time": ["12pm-1pm"], "name": "Lunch"}]'

  # Generate markdown output with overlaps allowed for manual resolution
  simple_schedule --attendees attendees.md --sessions sessions.md --locations locations.md \\
      --include-overlaps --format md --output schedule.md

  # Complex scheduling with all options
  simple_schedule --attendees participants.csv --sessions workshops.csv --locations rooms.csv \\
      --days 2 --time "8:30am-12:30pm,2pm-6pm" --slice 15m \\
      --blackout '[{"day": 0, "time": ["12:30pm-2pm"], "name": "Lunch & Keynote"},
                   {"day": 1, "time": ["5pm-6pm"], "name": "Closing Reception"}]' \\
      --format xlsx --output "conference_schedule.xlsx"

  # Using delimited sessions format with custom delimiter
  simple_schedule --attendees attendees_delimited.csv --sessions sessions.csv --locations rooms.csv \\
      --delimited-sessions --delimiter ";" \\
      --format md --output schedule.md

  # Generate both schedule and detailed roster
  simple_schedule --attendees attendees.csv --sessions sessions.csv --locations rooms.csv \\
      --days 2 --format xlsx --output "schedule.xlsx" --output-roster "roster.xlsx"

  # Debug a failing schedule by dumping partial output
  simple_schedule --attendees attendees.csv --sessions sessions.csv --locations rooms.csv \\
      --dump-output --output debug_schedule.md --verbose

Template files are available at:
  /var/home/zach/Documents/notes/03_resources/templates/simple_schedule/

For more information, see the documentation at:
  https://github.com/yourusername/simple_schedule
        ''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        '--attendees',
        required=True,
        help='Path to attendees file (CSV, XLSX, or MD). Rows are attendees, columns are sessions. '
             'Values: 1/x/yes/true = definite interest, ?/maybe = optional interest'
    )
    
    parser.add_argument(
        '--delimited-sessions',
        action='store_true',
        help='Use delimited sessions format. Attendees file should have two columns: '
             'attendee_name and sessions (delimited list of session names with optional :yes/:maybe suffix)'
    )
    
    parser.add_argument(
        '--delimiter',
        default=',',
        help='Delimiter for sessions field when using --delimited-sessions (default: comma)'
    )
    
    parser.add_argument(
        '--sessions',
        required=True,
        help='Path to sessions file (CSV, XLSX, or MD) with columns: session_name, max_attendees, '
             'presenters, length, required, priority, number_of_sessions, max_per_day. '
             'number_of_sessions can be: single number (3), range (2-5), or auto-determine (? or 0)'
    )
    
    parser.add_argument(
        '--locations',
        required=True,
        help='Path to locations file (CSV, XLSX, or MD) with columns: location_name, soft_limit, '
             'hard_limit, time_available, and optional days_available (CSV of 0-based day indices). '
             'Locations can be listed multiple times with different availability.'
    )
    
    parser.add_argument(
        '--time',
        help='Global time constraints (e.g., "8am-12pm,1pm-5pm"). Overrides location times if more restrictive'
    )
    
    parser.add_argument(
        '--days',
        type=int,
        default=1,
        help='Number of days to schedule across (default: 1)'
    )
    
    parser.add_argument(
        '--day-names',
        help='CSV string of custom day names in order (e.g., "Monday,Tuesday,Wednesday"). '
             'If not specified, defaults to "Day 1", "Day 2", etc.'
    )
    
    parser.add_argument(
        '--blackout',
        help='JSON array of blackout periods. Format: \'[{"day": 0, "time": ["12pm-1pm"], "name": "Lunch"}]\''
    )
    
    parser.add_argument(
        '--slice',
        default='60m',
        help='Time increment for schedule display (default: 60m). Examples: 30m, 1h'
    )
    
    parser.add_argument(
        '--include-overlaps',
        action='store_true',
        help='Allow scheduling conflicts but mark them with "(overlap)" for manual resolution'
    )
    
    parser.add_argument(
        '--format',
        choices=['md', 'csv', 'xlsx'],
        default='md',
        help='Output format (default: md)'
    )
    
    parser.add_argument(
        '--output',
        help='Output file path. If not specified, outputs to stdout'
    )
    
    parser.add_argument(
        '--output-roster',
        help='Output file path for detailed roster listing sessions with presenters, attendees, location, day and time. '
             'Uses the same format as --format'
    )
    
    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Show scheduling statistics and unscheduled sessions'
    )
    
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Enable debug output to stderr for troubleshooting'
    )
    
    parser.add_argument(
        '--dump-output',
        action='store_true',
        help='Dump partial schedule output even on failure (useful for debugging failed schedules)'
    )
    
    return parser


def main():
    """Main entry point"""
    parser = create_arg_parser()
    args = parser.parse_args()
    
    # Set global debug flag
    global DEBUG
    DEBUG = args.debug
    
    if DEBUG:
        debug_log("Debug mode enabled")
        debug_log(f"Arguments: {vars(args)}")
    
    try:
        # Read input files
        attendees_df = read_input_file(args.attendees, "attendees")
        sessions_df = read_input_file(args.sessions, "sessions")
        locations_df = read_input_file(args.locations, "locations")
        
        # Validate and parse data
        if args.delimited_sessions:
            attendees = validate_attendees_delimited(attendees_df, sessions_df, args.delimiter)
        else:
            attendees = validate_attendees(attendees_df, sessions_df)
        sessions = validate_sessions(sessions_df, attendees)
        locations = validate_locations(locations_df)
        
        # Parse other parameters
        global_time = parse_time_list(args.time) if args.time else None
        blackouts = parse_blackout(args.blackout) if args.blackout else []
        slice_duration = parse_slice_duration(args.slice)
        day_names = parse_day_names(args.day_names, args.days)
        
        # Validate days vs blackouts
        max_blackout_day = max([b['day'] for b in blackouts], default=-1)
        if max_blackout_day >= args.days:
            raise SchedulingError(
                f"Blackout day {max_blackout_day} exceeds number of days ({args.days})"
            )
        
        # Generate time slots
        time_slots = generate_time_slots(
            args.days, global_time, locations, blackouts, slice_duration
        )
        
        if not time_slots or all(len(slots) == 0 for slots in time_slots.values()):
            raise SchedulingError(
                "No available time slots found. Check time constraints and blackout periods."
            )
        
        # Run scheduler
        scheduler = Scheduler(sessions, locations, attendees, time_slots, args.include_overlaps)
        scheduler.run()
        
        # Check if there were any critical errors
        if scheduler.scheduling_errors:
            if args.dump_output:
                print("\nERROR: Scheduling failed but --dump-output specified.", file=sys.stderr)
                print("Dumping partial schedule...\n", file=sys.stderr)
                
                # Generate partial output despite errors
                try:
                    if args.format == 'md':
                        output = generate_markdown_output(
                            scheduler.schedule, locations, args.days, time_slots, blackouts, slice_duration, day_names
                        )
                        if args.output:
                            with open(args.output, 'w') as f:
                                f.write(output)
                            print(f"Partial schedule written to {args.output}", file=sys.stderr)
                        else:
                            print(output)
                            
                    elif args.format == 'csv':
                        output = generate_csv_output(
                            scheduler.schedule, locations, args.days, time_slots, blackouts, slice_duration, day_names
                        )
                        if args.output:
                            with open(args.output, 'w') as f:
                                f.write(output)
                            print(f"Partial schedule written to {args.output}", file=sys.stderr)
                        else:
                            print(output)
                            
                    elif args.format == 'xlsx':
                        if not args.output:
                            print("ERROR: Excel format requires --output parameter", file=sys.stderr)
                        else:
                            generate_xlsx_output(
                                scheduler.schedule, locations, args.days, time_slots, 
                                blackouts, slice_duration, args.output, day_names
                            )
                            print(f"Partial schedule written to {args.output}", file=sys.stderr)
                    
                    # Also generate roster if requested
                    if args.output_roster:
                        if args.format == 'md':
                            roster_output = generate_roster_markdown(scheduler.schedule, day_names)
                            with open(args.output_roster, 'w') as f:
                                f.write(roster_output)
                            print(f"Partial roster written to {args.output_roster}", file=sys.stderr)
                                
                        elif args.format == 'csv':
                            roster_output = generate_roster_csv(scheduler.schedule, day_names)
                            with open(args.output_roster, 'w') as f:
                                f.write(roster_output)
                            print(f"Partial roster written to {args.output_roster}", file=sys.stderr)
                                
                        elif args.format == 'xlsx':
                            generate_roster_xlsx(scheduler.schedule, args.output_roster, day_names)
                            print(f"Partial roster written to {args.output_roster}", file=sys.stderr)
                            
                except Exception as e:
                    print(f"ERROR while dumping partial output: {e}", file=sys.stderr)
                
                # Print the scheduling errors
                print("\nScheduling errors encountered:", file=sys.stderr)
                for error in scheduler.scheduling_errors:
                    print(f"  - {error}", file=sys.stderr)
                
                # Still exit with error
                raise SchedulingError("\n".join(scheduler.scheduling_errors))
            else:
                # Normal error handling without dump
                raise SchedulingError("\n".join(scheduler.scheduling_errors))
        
        # Generate output
        if args.format == 'md':
            output = generate_markdown_output(
                scheduler.schedule, locations, args.days, time_slots, blackouts, slice_duration, day_names
            )
            if args.output:
                with open(args.output, 'w') as f:
                    f.write(output)
            else:
                print(output)
                
        elif args.format == 'csv':
            output = generate_csv_output(
                scheduler.schedule, locations, args.days, time_slots, blackouts, slice_duration, day_names
            )
            if args.output:
                with open(args.output, 'w') as f:
                    f.write(output)
            else:
                print(output)
                
        elif args.format == 'xlsx':
            if not args.output:
                raise SchedulingError("Excel format requires --output parameter")
            generate_xlsx_output(
                scheduler.schedule, locations, args.days, time_slots, 
                blackouts, slice_duration, args.output, day_names
            )
            print(f"Schedule written to {args.output}")
        
        # Generate roster if requested
        if args.output_roster:
            if args.format == 'md':
                roster_output = generate_roster_markdown(scheduler.schedule, day_names)
                with open(args.output_roster, 'w') as f:
                    f.write(roster_output)
                print(f"Roster written to {args.output_roster}")
                    
            elif args.format == 'csv':
                roster_output = generate_roster_csv(scheduler.schedule, day_names)
                with open(args.output_roster, 'w') as f:
                    f.write(roster_output)
                print(f"Roster written to {args.output_roster}")
                    
            elif args.format == 'xlsx':
                generate_roster_xlsx(scheduler.schedule, args.output_roster, day_names)
                print(f"Roster written to {args.output_roster}")
        
        # Show verbose output
        if args.verbose:
            print("\n--- Scheduling Statistics ---", file=sys.stderr)
            print(f"Sessions scheduled: {len(scheduler.schedule)}", file=sys.stderr)
            
            if scheduler.unscheduled_sessions:
                print(f"\nUnscheduled sessions ({len(scheduler.unscheduled_sessions)}):", file=sys.stderr)
                for session, reason in scheduler.unscheduled_sessions:
                    print(f"  - {session.name}: {reason}", file=sys.stderr)
            
            # Calculate metrics
            total_conflicts = sum(
                1 for s in scheduler.schedule 
                if any("(overlap)" in str(a) for a in s.attendees)
            )
            print(f"\nTotal conflicts: {total_conflicts}", file=sys.stderr)
            
            # Room utilization
            room_usage = defaultdict(int)
            for scheduled in scheduler.schedule:
                room_usage[scheduled.location.name] += 1
            
            print("\nRoom utilization:", file=sys.stderr)
            for room, count in sorted(room_usage.items()):
                print(f"  - {room}: {count} sessions", file=sys.stderr)
    
    except SchedulingError as e:
        print(f"ERROR: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


# CSV string writer helper
class StringWriter:
    def __init__(self):
        self.rows = []
    
    def writerow(self, row):
        self.rows.append(row)
    
    def getvalue(self):
        import io
        output = io.StringIO()
        writer = csv.writer(output)
        for row in self.rows:
            writer.writerow(row)
        return output.getvalue()


if __name__ == '__main__':
    main()