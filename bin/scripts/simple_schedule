#!/usr/bin/python3

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
Simple Schedule - Multi-session event scheduling tool

This script helps schedule multi-session events across multiple locations while minimizing
attendee conflicts and respecting various constraints like room capacity, presenter availability,
and time restrictions.

Required sessions (required=true) are automatically assigned to ALL attendees regardless of
signup preferences. Non-required sessions only include attendees who explicitly signed up.
"""

import argparse
import json
import sys
import os
import re
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Set, Any, NamedTuple
from dataclasses import dataclass
from collections import defaultdict
import csv
from pathlib import Path
from subprocess import run

# Check if we're in the correct distrobox
ctr_id = os.environ.get("CONTAINER_ID", "")

# Check if distrobox check should be skipped
no_dbox_check = os.environ.get("NO_DBOX_CHECK", "").lower() in ("1", "true")

# If we are not in the 'dev' distrobox, re-exec the script inside it
if not no_dbox_check and ctr_id != "dev":
    cmd = ["distrobox", "enter", "dev", "--", *sys.argv]
    result = run(cmd)
    sys.exit(result.returncode)

# Check for required dependencies
try:
    import pandas as pd
except ImportError:
    print("ERROR: pandas is required but not installed.", file=sys.stderr)
    print("\nThis script requires the 'dev' distrobox environment.", file=sys.stderr)
    print("The script should automatically run in the dev distrobox.", file=sys.stderr)
    print("\nIf you're bypassing the distrobox check, install dependencies with:", file=sys.stderr)
    print("  pip install pandas openpyxl", file=sys.stderr)
    sys.exit(1)

try:
    import openpyxl
    XLSX_SUPPORT = True
except ImportError:
    XLSX_SUPPORT = False

try:
    from tabulate import tabulate
    TABULATE_SUPPORT = True
except ImportError:
    TABULATE_SUPPORT = False


@dataclass
class Session:
    """Represents a session to be scheduled"""
    name: str
    max_attendees: int  # 0 means unlimited
    presenters: List[str]
    length: int  # minutes
    required: bool
    priority: int  # -20 to 19
    min_sessions: int  # Minimum number of sessions to schedule
    max_sessions: int  # Maximum number of sessions to schedule (0 means auto-determine)
    max_per_day: int
    interested_attendees: Set[str]
    maybe_attendees: Set[str]
    blacklist_days: Optional[Set[int]] = None  # Days this session cannot be scheduled on
    blacklist_times: Optional[List[Tuple[datetime, datetime]]] = None  # Time ranges this session cannot be scheduled during


@dataclass
class Location:
    """Represents a location/room"""
    name: str
    soft_limit: int
    hard_limit: int
    time_available: List[Tuple[datetime, datetime]]
    days_available: Optional[Set[int]] = None  # None means available all days


@dataclass
class TimeSlot:
    """Represents a time slot in the schedule"""
    day: int
    start_time: datetime
    end_time: datetime
    
    def overlaps_with(self, other: 'TimeSlot') -> bool:
        """Check if this time slot overlaps with another"""
        if self.day != other.day:
            return False
        return (self.start_time < other.end_time and 
                self.end_time > other.start_time)
    
    def overlaps_with_time_range(self, start: datetime, end: datetime) -> bool:
        """Check if this time slot overlaps with a time range (ignoring day)"""
        # Extract just the time portions for comparison
        slot_start_time = self.start_time.time()
        slot_end_time = self.end_time.time()
        range_start_time = start.time()
        range_end_time = end.time()
        
        # Check for overlap
        return (slot_start_time < range_end_time and 
                slot_end_time > range_start_time)


@dataclass
class ScheduledSession:
    """Represents a scheduled session"""
    session: Session
    location: Location
    time_slot: TimeSlot
    attendees: Set[str]
    
    def conflicts_with(self, other: 'ScheduledSession') -> bool:
        """Check if this scheduled session conflicts with another"""
        return self.time_slot.overlaps_with(other.time_slot)


class SchedulingError(Exception):
    """Custom exception for scheduling errors"""
    pass


# Global debug flag
DEBUG = False


def debug_log(message: str, indent: int = 0):
    """Print debug message to stderr if debug mode is enabled"""
    if DEBUG:
        prefix = "  " * indent
        print(f"[DEBUG] {prefix}{message}", file=sys.stderr)


def parse_time(time_str: str) -> datetime:
    """
    Parse time string in various formats
    
    Args:
        time_str: Time string like "8am", "8:00am", "08:00", "8:30pm", "20:30"
        
    Returns:
        datetime object with the parsed time
        
    Raises:
        ValueError: If time format is invalid
    """
    time_str = time_str.strip().lower()
    
    # Try different time formats
    formats = [
        "%I%p",           # 8am
        "%I:%M%p",        # 8:00am
        "%H:%M",          # 08:00 or 20:30
    ]
    
    for fmt in formats:
        try:
            # Use a dummy date for parsing time only
            return datetime.strptime(f"2000-01-01 {time_str}", f"%Y-%m-%d {fmt}")
        except ValueError:
            continue
    
    raise ValueError(f"Invalid time format: '{time_str}'. Use formats like '8am', '8:00am', or '20:30'")


def parse_time_range(time_range: str) -> Tuple[datetime, datetime]:
    """
    Parse a time range string
    
    Args:
        time_range: Time range like "8am-12pm" or "09:00-17:00"
        
    Returns:
        Tuple of (start_time, end_time)
        
    Raises:
        ValueError: If format is invalid or start >= end
    """
    parts = time_range.strip().split('-')
    if len(parts) != 2:
        raise ValueError(f"Invalid time range format: '{time_range}'. Use 'start-end' format")
    
    start = parse_time(parts[0])
    end = parse_time(parts[1])
    
    if start >= end:
        raise ValueError(f"Start time must be before end time in range: '{time_range}'")
    
    return start, end


def parse_time_list(time_list: str) -> List[Tuple[datetime, datetime]]:
    """Parse comma-separated list of time ranges"""
    ranges = []
    for time_range in time_list.split(','):
        ranges.append(parse_time_range(time_range))
    return ranges


def parse_slice_duration(slice_str: str) -> timedelta:
    """
    Parse slice duration string
    
    Args:
        slice_str: Duration like "30m" or "1h"
        
    Returns:
        timedelta object
    """
    match = re.match(r'^(\d+)([mh])$', slice_str.lower())
    if not match:
        raise ValueError(f"Invalid slice format: '{slice_str}'. Use '<number>m' or '<number>h'")
    
    value = int(match.group(1))
    unit = match.group(2)
    
    if unit == 'm':
        return timedelta(minutes=value)
    else:  # 'h'
        return timedelta(hours=value)


def read_csv_file(filepath: Path) -> pd.DataFrame:
    """Read CSV file with error handling"""
    try:
        return pd.read_csv(filepath)
    except Exception as e:
        raise SchedulingError(f"Error reading CSV file '{filepath}': {str(e)}")


def read_xlsx_file(filepath: Path) -> pd.DataFrame:
    """Read Excel file with error handling"""
    if not XLSX_SUPPORT:
        raise SchedulingError("Excel support not available. Install openpyxl: pip install openpyxl")
    try:
        return pd.read_excel(filepath)
    except Exception as e:
        raise SchedulingError(f"Error reading Excel file '{filepath}': {str(e)}")


def read_markdown_table(filepath: Path) -> pd.DataFrame:
    """Read Markdown table file"""
    try:
        with open(filepath, 'r') as f:
            content = f.read()
        
        # Find the table in the markdown
        lines = content.strip().split('\n')
        table_lines = []
        in_table = False
        
        for line in lines:
            if '|' in line:
                if not in_table:
                    in_table = True
                table_lines.append(line)
            elif in_table and line.strip() == '':
                break
        
        if not table_lines:
            raise ValueError("No markdown table found in file")
        
        # Parse the table
        header = [cell.strip() for cell in table_lines[0].split('|')[1:-1]]
        
        # Skip separator line
        data_lines = []
        for line in table_lines[2:]:
            if line.strip():
                row = [cell.strip() for cell in line.split('|')[1:-1]]
                data_lines.append(row)
        
        return pd.DataFrame(data_lines, columns=header)
        
    except Exception as e:
        raise SchedulingError(f"Error reading Markdown file '{filepath}': {str(e)}")


def read_input_file(filepath: str, file_type: str) -> pd.DataFrame:
    """Read input file based on extension"""
    path = Path(filepath)
    
    debug_log(f"Reading {file_type} file: {filepath}")
    
    if not path.exists():
        raise SchedulingError(f"File not found: '{filepath}'")
    
    ext = path.suffix.lower()
    debug_log(f"File extension: {ext}", 1)
    
    if ext == '.csv':
        df = read_csv_file(path)
    elif ext in ['.xlsx', '.xls']:
        df = read_xlsx_file(path)
    elif ext == '.md':
        df = read_markdown_table(path)
    else:
        raise SchedulingError(
            f"Unsupported file format '{ext}' for {file_type}. "
            f"Supported formats: csv, xlsx, md"
        )
    
    debug_log(f"Read {len(df)} rows from {file_type} file", 1)
    if DEBUG and len(df) > 0:
        debug_log(f"Columns: {list(df.columns)}", 2)
    
    return df


def normalize_bool_value(value: Any) -> bool:
    """Normalize various boolean representations"""
    if pd.isna(value):
        return False
    str_val = str(value).lower().strip()
    return str_val in ['true', '1', 'yes', 'y']


def normalize_interest_value(value: Any) -> str:
    """Normalize attendee interest values"""
    if pd.isna(value) or value == '':
        return ''
    str_val = str(value).lower().strip()
    
    if str_val in ['1', 'x', 'yes', 'true']:
        return 'yes'
    elif str_val in ['?', 'maybe']:
        return 'maybe'
    else:
        return ''


def parse_session_count(value: Any, session_name: str) -> Tuple[int, int]:
    """
    Parse session count which can be:
    - Single number: "3" -> (3, 3)
    - Range: "2-5" -> (2, 5)
    - Auto-determine: "?" or "0" -> (1, 0) where 0 means unlimited
    
    Returns: (min_sessions, max_sessions)
    """
    if pd.isna(value):
        raise ValueError(f"number_of_sessions is required")
    
    str_val = str(value).strip()
    
    # Check for auto-determine
    if str_val in ['?', '0']:
        return (1, 0)  # min 1, max unlimited (auto-determine)
    
    # Check for range
    if '-' in str_val:
        parts = str_val.split('-')
        if len(parts) != 2:
            raise ValueError(f"Invalid range format: '{str_val}'. Use 'min-max' format")
        
        try:
            min_val = int(parts[0].strip())
            max_val = int(parts[1].strip())
        except ValueError:
            raise ValueError(f"Invalid range values: '{str_val}'. Must be integers")
        
        if min_val <= 0:
            raise ValueError(f"Minimum sessions must be > 0, got {min_val}")
        if max_val < min_val:
            raise ValueError(f"Maximum sessions ({max_val}) must be >= minimum ({min_val})")
        
        return (min_val, max_val)
    
    # Single number
    try:
        num = int(str_val)
        if num <= 0:
            raise ValueError(f"number_of_sessions must be > 0, got {num}")
        return (num, num)
    except ValueError:
        raise ValueError(f"Invalid number_of_sessions value: '{str_val}'")


def validate_attendees_delimited(df: pd.DataFrame, sessions_df: pd.DataFrame, delimiter: str) -> Dict[str, Dict[str, str]]:
    """
    Validate and parse attendees data in delimited format
    
    Expected format:
        attendee_name | sessions
        John Doe      | Intro to AI:yes,Workshop A,Panel Discussion:maybe
        Jane Smith    | Workshop B:yes,Closing Keynote
    
    Returns:
        Dict mapping attendee_name to dict of session_name -> interest_level
    """
    debug_log("Validating attendees data (delimited format)")
    debug_log(f"Using delimiter: '{delimiter}'", 1)
    
    if df.empty:
        raise SchedulingError("Attendees file is empty")
    
    if len(df.columns) != 2:
        raise SchedulingError(
            "Attendees file in delimited format must have exactly 2 columns: "
            "attendee_name and sessions"
        )
    
    # Column names
    attendee_col = df.columns[0]
    sessions_col = df.columns[1]
    
    debug_log(f"Attendee column: {attendee_col}", 1)
    debug_log(f"Sessions column: {sessions_col}", 1)
    
    # Check for duplicate attendee names
    duplicates = df[attendee_col].duplicated()
    if duplicates.any():
        dup_names = df[attendee_col][duplicates].unique()
        raise SchedulingError(f"Duplicate attendee names found: {', '.join(dup_names)}")
    
    # Get valid session names from sessions file
    valid_sessions = set(sessions_df[sessions_df.columns[0]].values)
    
    # Build attendee interest map
    attendees = {}
    for _, row in df.iterrows():
        attendee_name = str(row[attendee_col]).strip()
        sessions_str = str(row[sessions_col]).strip()
        interests = {}
        
        if sessions_str and not pd.isna(row[sessions_col]):
            # Parse delimited sessions
            session_entries = [s.strip() for s in sessions_str.split(delimiter) if s.strip()]
            
            for entry in session_entries:
                # Check if interest level is specified with :suffix
                if ':' in entry:
                    parts = entry.split(':', 1)
                    session_name = parts[0].strip()
                    interest_suffix = parts[1].strip().lower()
                    
                    if interest_suffix in ['yes', 'maybe']:
                        interest = interest_suffix
                    else:
                        # Normalize the suffix
                        interest = normalize_interest_value(interest_suffix)
                        if not interest:
                            debug_log(f"Warning: Unknown interest suffix '{interest_suffix}' for session '{session_name}', treating as 'yes'", 2)
                            interest = 'yes'
                else:
                    # No suffix means definite interest
                    session_name = entry
                    interest = 'yes'
                
                # Validate session exists
                if session_name not in valid_sessions:
                    raise SchedulingError(
                        f"Session '{session_name}' for attendee '{attendee_name}' not found in sessions file"
                    )
                
                interests[session_name] = interest
        
        attendees[attendee_name] = interests
    
    debug_log(f"Processed {len(attendees)} attendees", 1)
    if DEBUG and attendees:
        sample_attendee = list(attendees.keys())[0]
        debug_log(f"Sample: {sample_attendee} -> {attendees[sample_attendee]}", 2)
    
    return attendees


def validate_attendees(df: pd.DataFrame, sessions_df: pd.DataFrame) -> Dict[str, Dict[str, str]]:
    """
    Validate and parse attendees data
    
    Returns:
        Dict mapping attendee_name to dict of session_name -> interest_level
    """
    debug_log("Validating attendees data")
    
    if df.empty:
        raise SchedulingError("Attendees file is empty")
    
    if len(df.columns) < 2:
        raise SchedulingError("Attendees file must have at least 2 columns (attendee_name and one session)")
    
    # First column is attendee name
    attendee_col = df.columns[0]
    session_cols = df.columns[1:]
    
    debug_log(f"Attendee column: {attendee_col}", 1)
    debug_log(f"Session columns: {list(session_cols)}", 1)
    
    # Check for duplicate attendee names
    duplicates = df[attendee_col].duplicated()
    if duplicates.any():
        dup_names = df[attendee_col][duplicates].unique()
        raise SchedulingError(f"Duplicate attendee names found: {', '.join(dup_names)}")
    
    # Get valid session names from sessions file
    valid_sessions = set(sessions_df[sessions_df.columns[0]].values)
    
    # Validate session columns match sessions in sessions file
    invalid_sessions = []
    for session in session_cols:
        if session not in valid_sessions:
            invalid_sessions.append(session)
    
    if invalid_sessions:
        raise SchedulingError(
            f"Sessions in attendees file not found in sessions file: {', '.join(invalid_sessions)}"
        )
    
    # Build attendee interest map
    attendees = {}
    for _, row in df.iterrows():
        attendee_name = str(row[attendee_col]).strip()
        interests = {}
        
        for session in session_cols:
            interest = normalize_interest_value(row[session])
            if interest:
                interests[session] = interest
        
        attendees[attendee_name] = interests
    
    debug_log(f"Processed {len(attendees)} attendees", 1)
    if DEBUG and attendees:
        sample_attendee = list(attendees.keys())[0]
        debug_log(f"Sample: {sample_attendee} -> {attendees[sample_attendee]}", 2)
    
    return attendees


def validate_sessions(df: pd.DataFrame, attendees: Dict[str, Dict[str, str]]) -> List[Session]:
    """Validate and parse sessions data"""
    if df.empty:
        raise SchedulingError("Sessions file is empty")
    
    required_cols = [
        'session_name', 'max_attendees', 'presenters', 'length',
        'required', 'priority', 'number_of_sessions', 'max_per_day'
    ]
    
    # Check column names (case-insensitive)
    df_cols_lower = [col.lower() for col in df.columns]
    missing_cols = []
    col_mapping = {}
    
    for req_col in required_cols:
        found = False
        for i, df_col in enumerate(df_cols_lower):
            if req_col.lower() == df_col:
                col_mapping[req_col] = df.columns[i]
                found = True
                break
        if not found:
            missing_cols.append(req_col)
    
    if missing_cols:
        raise SchedulingError(
            f"Missing required columns in sessions file: {', '.join(missing_cols)}\n"
            f"Expected columns: {', '.join(required_cols)}"
        )
    
    # Check for optional columns
    optional_cols = ['blacklist_days', 'blacklist_time']
    for opt_col in optional_cols:
        for i, df_col in enumerate(df_cols_lower):
            if opt_col.lower() == df_col:
                col_mapping[opt_col] = df.columns[i]
                break
    
    sessions = []
    all_attendee_names = set(attendees.keys())
    
    for idx, row in df.iterrows():
        try:
            name = str(row[col_mapping['session_name']]).strip()
            max_attendees = int(row[col_mapping['max_attendees']])
            
            if max_attendees < 0:
                raise ValueError(f"max_attendees must be >= 0, got {max_attendees}")
            
            # Parse presenters
            presenters_str = str(row[col_mapping['presenters']]).strip()
            # Handle empty/nan values properly
            if pd.isna(row[col_mapping['presenters']]) or presenters_str.lower() == 'nan' or not presenters_str:
                presenters = []
            else:
                presenters = [p.strip() for p in presenters_str.split(',') if p.strip()]
            
            length = int(row[col_mapping['length']])
            if length <= 0:
                raise ValueError(f"length must be > 0, got {length}")
            if length > 480:  # 8 hours
                raise ValueError(f"length seems too long ({length} minutes). Maximum recommended: 480")
            
            required = normalize_bool_value(row[col_mapping['required']])
            
            priority = int(row[col_mapping['priority']])
            if priority < -20 or priority > 19:
                raise ValueError(f"priority must be between -20 and 19, got {priority}")
            
            # Parse number_of_sessions (can be range or auto)
            min_sessions, max_sessions = parse_session_count(
                row[col_mapping['number_of_sessions']], 
                name
            )
            
            max_per_day = int(row[col_mapping['max_per_day']])
            if max_per_day <= 0:
                raise ValueError(f"max_per_day must be > 0, got {max_per_day}")
            
            # Validate max_per_day against session counts
            if max_sessions > 0 and max_per_day > max_sessions:
                raise ValueError(f"max_per_day ({max_per_day}) cannot exceed max_sessions ({max_sessions})")
            if max_per_day < min_sessions and min_sessions <= 3:
                # Only warn if min_sessions is reasonable (<=3)
                debug_log(f"Warning: max_per_day ({max_per_day}) < min_sessions ({min_sessions}) for '{name}'", 1)
            
            # Parse blacklist_days if column exists
            blacklist_days = None
            if 'blacklist_days' in col_mapping:
                blacklist_str = str(row[col_mapping['blacklist_days']]).strip()
                if blacklist_str and not pd.isna(row[col_mapping['blacklist_days']]):
                    # Handle special values: '-1' or '?' means no blacklist
                    if blacklist_str in ['-1', '?']:
                        blacklist_days = None
                    else:
                        try:
                            # Parse CSV string of day indices (0-based)
                            blacklist_days = set()
                            for day_str in blacklist_str.split(','):
                                day_str = day_str.strip()
                                if day_str:
                                    day_num = int(day_str)
                                    if day_num < 0:
                                        # Negative values (except -1) are invalid
                                        raise ValueError(f"Day index must be >= 0 or -1/'?', got {day_num}")
                                    blacklist_days.add(day_num)
                        except ValueError as e:
                            raise ValueError(f"Invalid blacklist_days format: {e}")
            
            # Parse blacklist_time if column exists
            blacklist_times = None
            if 'blacklist_time' in col_mapping:
                blacklist_time_str = str(row[col_mapping['blacklist_time']]).strip()
                if blacklist_time_str and not pd.isna(row[col_mapping['blacklist_time']]):
                    # Handle special values: '-1', '?', or '0' means no blacklist
                    if blacklist_time_str in ['-1', '?', '0']:
                        blacklist_times = None
                    else:
                        try:
                            # Parse CSV string of time ranges like "9am-11am,1pm-2pm"
                            blacklist_times = []
                            for time_range_str in blacklist_time_str.split(','):
                                time_range_str = time_range_str.strip()
                                if time_range_str:
                                    # Parse each time range
                                    start_time, end_time = parse_time_range(time_range_str)
                                    blacklist_times.append((start_time, end_time))
                        except (ValueError, Exception) as e:
                            raise ValueError(f"Invalid blacklist_time format '{blacklist_time_str}': {e}")
            
            # Find interested attendees
            interested = set()
            maybe = set()
            
            # If session is required, ALL attendees are interested
            if required:
                interested = all_attendee_names.copy()
                debug_log(f"  Session '{name}' is required - adding all {len(interested)} attendees", 1)
            else:
                # Only add those who explicitly signed up
                for attendee, interests in attendees.items():
                    if name in interests:
                        if interests[name] == 'yes':
                            interested.add(attendee)
                        elif interests[name] == 'maybe':
                            maybe.add(attendee)
            
            sessions.append(Session(
                name=name,
                max_attendees=max_attendees,
                presenters=presenters,
                length=length,
                required=required,
                priority=priority,
                min_sessions=min_sessions,
                max_sessions=max_sessions,
                max_per_day=max_per_day,
                interested_attendees=interested,
                maybe_attendees=maybe,
                blacklist_days=blacklist_days,
                blacklist_times=blacklist_times
            ))
            
        except ValueError as e:
            raise SchedulingError(f"Error in sessions file row {idx + 2} ('{name}'): {str(e)}")
    
    return sessions


def validate_locations(df: pd.DataFrame) -> List[Location]:
    """Validate and parse locations data"""
    if df.empty:
        raise SchedulingError("Locations file is empty")
    
    required_cols = ['location_name', 'soft_limit', 'hard_limit', 'time_available']
    optional_cols = ['days_available']
    
    # Check column names (case-insensitive)
    df_cols_lower = [col.lower() for col in df.columns]
    missing_cols = []
    col_mapping = {}
    
    for req_col in required_cols:
        found = False
        for i, df_col in enumerate(df_cols_lower):
            if req_col.lower() == df_col:
                col_mapping[req_col] = df.columns[i]
                found = True
                break
        if not found:
            missing_cols.append(req_col)
    
    if missing_cols:
        raise SchedulingError(
            f"Missing required columns in locations file: {', '.join(missing_cols)}\n"
            f"Expected columns: {', '.join(required_cols)}"
        )
    
    # Check for optional columns
    for opt_col in optional_cols:
        for i, df_col in enumerate(df_cols_lower):
            if opt_col.lower() == df_col:
                col_mapping[opt_col] = df.columns[i]
                break
    
    locations = []
    
    for idx, row in df.iterrows():
        try:
            name = str(row[col_mapping['location_name']]).strip()
            soft_limit = int(row[col_mapping['soft_limit']])
            hard_limit = int(row[col_mapping['hard_limit']])
            
            if soft_limit <= 0:
                raise ValueError(f"soft_limit must be > 0, got {soft_limit}")
            if hard_limit <= 0:
                raise ValueError(f"hard_limit must be > 0, got {hard_limit}")
            if soft_limit > hard_limit:
                raise ValueError(f"soft_limit ({soft_limit}) cannot exceed hard_limit ({hard_limit})")
            
            time_available_str = str(row[col_mapping['time_available']]).strip()
            time_available = parse_time_list(time_available_str)
            
            # Parse days_available if column exists
            days_available = None
            if 'days_available' in col_mapping:
                days_str = str(row[col_mapping['days_available']]).strip()
                if days_str and not pd.isna(row[col_mapping['days_available']]):
                    try:
                        # Parse CSV string of day indices (0-based)
                        days_available = set()
                        for day_str in days_str.split(','):
                            day_str = day_str.strip()
                            if day_str:
                                day_num = int(day_str)
                                if day_num < 0:
                                    raise ValueError(f"Day index must be >= 0, got {day_num}")
                                days_available.add(day_num)
                    except ValueError as e:
                        raise ValueError(f"Invalid days_available format: {e}")
            
            locations.append(Location(
                name=name,
                soft_limit=soft_limit,
                hard_limit=hard_limit,
                time_available=time_available,
                days_available=days_available
            ))
            
        except ValueError as e:
            raise SchedulingError(f"Error in locations file row {idx + 2} ('{name}'): {str(e)}")
    
    return locations


def parse_day_names(day_names_str: str, num_days: int) -> List[str]:
    """
    Parse day names from CSV string
    
    Args:
        day_names_str: CSV string of day names
        num_days: Expected number of days
        
    Returns:
        List of day names
        
    Raises:
        SchedulingError: If number of names doesn't match days
    """
    if not day_names_str:
        # Default to "Day 1", "Day 2", etc.
        return [f"Day {i + 1}" for i in range(num_days)]
    
    # Parse CSV string
    day_names = [name.strip() for name in day_names_str.split(',')]
    
    if len(day_names) != num_days:
        raise SchedulingError(
            f"Number of day names ({len(day_names)}) doesn't match number of days ({num_days}). "
            f"Provide exactly {num_days} comma-separated names."
        )
    
    debug_log(f"Using custom day names: {day_names}")
    
    return day_names


def parse_blackout(blackout_str: str) -> List[Dict[str, Any]]:
    """Parse blackout JSON string"""
    if not blackout_str:
        return []
    
    try:
        blackouts = json.loads(blackout_str)
        if not isinstance(blackouts, list):
            raise ValueError("Blackout must be a JSON array")
        
        parsed = []
        for i, blackout in enumerate(blackouts):
            if not isinstance(blackout, dict):
                raise ValueError(f"Blackout entry {i} must be a JSON object")
            
            if 'day' not in blackout:
                raise ValueError(f"Blackout entry {i} missing 'day' field")
            if 'time' not in blackout:
                raise ValueError(f"Blackout entry {i} missing 'time' field")
            
            day = int(blackout['day'])
            if day < 0:
                raise ValueError(f"Blackout entry {i}: day must be >= 0")
            
            time_ranges = []
            for time_str in blackout['time']:
                time_ranges.append(parse_time_range(time_str))
            
            name = blackout.get('name', 'blackout')
            
            parsed.append({
                'day': day,
                'time_ranges': time_ranges,
                'name': name
            })
        
        return parsed
        
    except json.JSONDecodeError as e:
        raise SchedulingError(f"Invalid JSON in blackout parameter: {str(e)}")
    except ValueError as e:
        raise SchedulingError(f"Invalid blackout format: {str(e)}")


def generate_time_slots(
    days: int,
    global_time: Optional[List[Tuple[datetime, datetime]]],
    locations: List[Location],
    blackouts: List[Dict[str, Any]],
    slice_duration: timedelta
) -> Dict[int, List[TimeSlot]]:
    """Generate all available time slots per day"""
    debug_log(f"Generating time slots for {days} days with {slice_duration} slices")
    
    slots_by_day = defaultdict(list)
    
    for day in range(days):
        # Start with location availability
        day_ranges = []
        for location in locations:
            # Skip locations not available on this day
            if location.days_available is not None and day not in location.days_available:
                continue
                
            for start, end in location.time_available:
                if global_time:
                    # Intersect with global time constraints
                    for g_start, g_end in global_time:
                        intersect_start = max(start, g_start)
                        intersect_end = min(end, g_end)
                        if intersect_start < intersect_end:
                            day_ranges.append((intersect_start, intersect_end))
                else:
                    day_ranges.append((start, end))
        
        # Merge overlapping ranges
        if day_ranges:
            day_ranges.sort()
            merged = [day_ranges[0]]
            for start, end in day_ranges[1:]:
                if start <= merged[-1][1]:
                    merged[-1] = (merged[-1][0], max(merged[-1][1], end))
                else:
                    merged.append((start, end))
            
            # Generate time slots
            for start, end in merged:
                current = start
                while current + slice_duration <= end:
                    slot = TimeSlot(day, current, current + slice_duration)
                    
                    # Check blackouts
                    is_blackout = False
                    for blackout in blackouts:
                        if blackout['day'] == day:
                            for b_start, b_end in blackout['time_ranges']:
                                if (current >= b_start and current < b_end) or \
                                   (current + slice_duration > b_start and current + slice_duration <= b_end):
                                    is_blackout = True
                                    break
                        if is_blackout:
                            break
                    
                    if not is_blackout:
                        slots_by_day[day].append(slot)
                    
                    current += slice_duration
    
    return dict(slots_by_day)


class Scheduler:
    """Main scheduling algorithm implementation"""
    
    def __init__(
        self,
        sessions: List[Session],
        locations: List[Location],
        attendees: Dict[str, Dict[str, str]],
        time_slots: Dict[int, List[TimeSlot]],
        include_overlaps: bool = False,
        no_back_to_back: bool = False,
        sessions_between: int = 1,
        minimum_session_size: int = 1
    ):
        # Sort sessions: required first, then by priority (lower number = higher priority), then by number of interested attendees
        self.sessions = sorted(sessions, key=lambda s: (-s.required, s.priority, -len(s.interested_attendees)))
        self.locations = locations
        self.attendees = attendees
        self.time_slots = time_slots
        self.include_overlaps = include_overlaps
        self.no_back_to_back = no_back_to_back
        self.sessions_between = sessions_between
        self.minimum_session_size = minimum_session_size
        self.schedule: List[ScheduledSession] = []
        self.unscheduled_sessions: List[Tuple[Session, str]] = []
        # Track attendees who have already been scheduled for each session name
        self.scheduled_attendees_by_session: Dict[str, Set[str]] = defaultdict(set)
        # Track scheduling errors for required sessions
        self.scheduling_errors: List[str] = []
    
    def is_presenter_available(self, presenter: str, time_slot: TimeSlot) -> bool:
        """Check if presenter is available during time slot"""
        for scheduled in self.schedule:
            if presenter in scheduled.session.presenters and \
               scheduled.time_slot.overlaps_with(time_slot):
                return False
        return True
    
    def is_location_available(self, location: Location, time_slot: TimeSlot) -> bool:
        """Check if location is available during time slot"""
        for scheduled in self.schedule:
            if scheduled.location.name == location.name and \
               scheduled.time_slot.overlaps_with(time_slot):
                return False
        return True
    
    def get_attendee_conflicts(self, attendees: Set[str], time_slot: TimeSlot) -> Set[str]:
        """Get attendees who have conflicts at this time"""
        conflicts = set()
        for scheduled in self.schedule:
            if scheduled.time_slot.overlaps_with(time_slot):
                conflicts.update(scheduled.attendees & attendees)
        return conflicts
    
    def violates_back_to_back_constraint(self, session: Session, time_slot: TimeSlot) -> bool:
        """Check if scheduling this session would violate the no-back-to-back constraint"""
        if not self.no_back_to_back:
            return False
        
        # Get all scheduled instances of this session on the same day
        same_day_sessions = []
        for scheduled in self.schedule:
            if scheduled.session.name == session.name and scheduled.time_slot.day == time_slot.day:
                same_day_sessions.append(scheduled)
        
        if not same_day_sessions:
            return False
        
        # Sort sessions by start time
        same_day_sessions.sort(key=lambda s: s.time_slot.start_time)
        
        # Check if the new slot would be too close to any existing session
        for scheduled in same_day_sessions:
            # Calculate time-based distance
            if time_slot.start_time < scheduled.time_slot.start_time:
                # New session would be before this one
                # Count sessions between
                sessions_between = 0
                for other in self.schedule:
                    if (other.time_slot.day == time_slot.day and 
                        time_slot.end_time <= other.time_slot.start_time and
                        other.time_slot.end_time <= scheduled.time_slot.start_time and
                        other.session.name != session.name):
                        sessions_between += 1
                
                if sessions_between < self.sessions_between:
                    debug_log(f"      ✗ Violates back-to-back constraint: only {sessions_between} sessions between instances (need {self.sessions_between})", 5)
                    return True
            else:
                # New session would be after this one
                # Count sessions between
                sessions_between = 0
                for other in self.schedule:
                    if (other.time_slot.day == time_slot.day and 
                        scheduled.time_slot.end_time <= other.time_slot.start_time and
                        other.time_slot.end_time <= time_slot.start_time and
                        other.session.name != session.name):
                        sessions_between += 1
                
                if sessions_between < self.sessions_between:
                    debug_log(f"      ✗ Violates back-to-back constraint: only {sessions_between} sessions between instances (need {self.sessions_between})", 5)
                    return True
        
        return False
    
    def fits_in_location(self, session: Session, location: Location, time_slot: TimeSlot) -> bool:
        """Check if session fits in location during time slot"""
        # Check day availability first
        if location.days_available is not None and time_slot.day not in location.days_available:
            if DEBUG:
                debug_log(f"        Location not available on day {time_slot.day}", 6)
            return False
        
        # Check time availability
        slot_fits = False
        for start, end in location.time_available:
            if time_slot.start_time >= start and time_slot.end_time <= end:
                slot_fits = True
                break
        
        if not slot_fits:
            if DEBUG:
                debug_log(f"        Time {format_time(time_slot.start_time)}-{format_time(time_slot.end_time)} not in location's available times", 6)
            return False
        
        # Check capacity
        num_attendees = len(session.interested_attendees)
        if session.max_attendees > 0:
            num_attendees = min(num_attendees, session.max_attendees)
        
        if num_attendees > location.hard_limit:
            if DEBUG:
                debug_log(f"        {num_attendees} attendees exceeds location capacity of {location.hard_limit}", 6)
            return False
            
        return True
    
    def calculate_session_duration_slots(self, session: Session, slice_duration: timedelta) -> int:
        """Calculate how many time slots a session needs"""
        session_duration = timedelta(minutes=session.length)
        slots_needed = int(session_duration / slice_duration)
        if session_duration % slice_duration:
            slots_needed += 1
        return slots_needed
    
    def find_consecutive_slots(
        self, 
        day: int, 
        slots_needed: int,
        slice_duration: timedelta
    ) -> List[List[TimeSlot]]:
        """Find all possible consecutive time slot groups for a session"""
        if day not in self.time_slots:
            return []
        
        day_slots = self.time_slots[day]
        if len(day_slots) < slots_needed:
            return []
        
        consecutive_groups = []
        
        for i in range(len(day_slots) - slots_needed + 1):
            # Check if slots are consecutive
            is_consecutive = True
            for j in range(slots_needed - 1):
                if day_slots[i + j].end_time != day_slots[i + j + 1].start_time:
                    is_consecutive = False
                    break
            
            if is_consecutive:
                consecutive_groups.append(day_slots[i:i + slots_needed])
        
        return consecutive_groups
    
    def schedule_session_instance(
        self, 
        session: Session, 
        instance_num: int,
        sessions_per_day: Dict[int, int]
    ) -> bool:
        """Try to schedule one instance of a session"""
        debug_log(f"  Trying to schedule instance {instance_num + 1} of {session.name}", 1)
        
        slice_duration = None
        if self.time_slots:
            first_day_slots = next(iter(self.time_slots.values()))
            if len(first_day_slots) >= 2:
                slice_duration = first_day_slots[1].start_time - first_day_slots[0].start_time
            else:
                slice_duration = timedelta(hours=1)
        else:
            slice_duration = timedelta(hours=1)
        
        slots_needed = self.calculate_session_duration_slots(session, slice_duration)
        debug_log(f"  Session needs {slots_needed} time slots ({session.length} minutes)", 2)
        
        # Collect all possible slots with their conflict scores
        possible_slots = []
        
        # Get available attendees for this session (not already scheduled)
        available_attendees = session.interested_attendees - self.scheduled_attendees_by_session[session.name]
        
        # Try each day
        for day in sorted(self.time_slots.keys()):
            debug_log(f"  Day {day + 1}:", 2)
            
            # Check if this day is blacklisted for this session
            if session.blacklist_days and day in session.blacklist_days:
                debug_log(f"    ✗ Day {day} is blacklisted for this session", 3)
                continue
            
            # Check max_per_day constraint
            if sessions_per_day[session.name].get(day, 0) >= session.max_per_day:
                debug_log(f"    ✗ Already scheduled {sessions_per_day[session.name].get(day, 0)} sessions (max: {session.max_per_day})", 3)
                continue
            
            # Get possible time slot groups
            slot_groups = self.find_consecutive_slots(day, slots_needed, slice_duration)
            
            if not slot_groups:
                debug_log(f"    ✗ No consecutive slots available for {slots_needed} time slots", 3)
                continue
            
            # Try each location
            for location in self.locations:
                debug_log(f"    Trying location: {location.name}", 3)
                
                # Try each time slot group
                for slot_group in slot_groups:
                    # Create combined time slot
                    combined_slot = TimeSlot(
                        day=day,
                        start_time=slot_group[0].start_time,
                        end_time=slot_group[-1].end_time
                    )
                    
                    debug_log(f"      Time slot: {format_time(combined_slot.start_time)}-{format_time(combined_slot.end_time)}", 4)
                    
                    # Check if this time slot is blacklisted for this session
                    if session.blacklist_times:
                        time_blacklisted = False
                        for blacklist_start, blacklist_end in session.blacklist_times:
                            if combined_slot.overlaps_with_time_range(blacklist_start, blacklist_end):
                                debug_log(f"      ✗ Time slot overlaps with blacklisted time {format_time(blacklist_start)}-{format_time(blacklist_end)}", 5)
                                time_blacklisted = True
                                break
                        if time_blacklisted:
                            continue
                    
                    # Check if session fits in location
                    if not self.fits_in_location(session, location, combined_slot):
                        debug_log(f"      ✗ Session doesn't fit in location (capacity or time)", 5)
                        continue
                    
                    # Check if location is available at this time
                    if not self.is_location_available(location, combined_slot):
                        debug_log(f"      ✗ Location already occupied", 5)
                        continue
                    
                    # Check presenter availability
                    presenters_available = all(
                        self.is_presenter_available(p, combined_slot)
                        for p in session.presenters
                    )
                    if not presenters_available:
                        debug_log(f"      ✗ Presenter(s) not available", 5)
                        continue
                    
                    # If no attendees are available (all already scheduled), skip this slot
                    if not available_attendees:
                        debug_log(f"      ✗ All interested attendees already scheduled for {session.name}", 5)
                        continue
                    
                    # Check if we have enough attendees for minimum session size
                    if len(available_attendees) < self.minimum_session_size:
                        debug_log(f"      ✗ Only {len(available_attendees)} available attendees, less than minimum {self.minimum_session_size}", 5)
                        continue
                    
                    # Check back-to-back constraint
                    if self.violates_back_to_back_constraint(session, combined_slot):
                        continue
                    
                    # Check attendee conflicts (only for available attendees)
                    conflicts = self.get_attendee_conflicts(
                        available_attendees, 
                        combined_slot
                    )
                    
                    # For required sessions, we should still schedule them even with conflicts
                    # Only skip if ALL available attendees have conflicts
                    if session.required and len(conflicts) == len(available_attendees) and not self.include_overlaps:
                        debug_log(f"      ✗ All available attendees have conflicts for required session", 5)
                        continue
                    
                    # Calculate score (minimize conflicts)
                    score = len(conflicts)
                    
                    # Add to possible slots
                    possible_slots.append({
                        'location': location,
                        'time_slot': combined_slot,
                        'conflicts': conflicts,
                        'score': score,
                        'day': day
                    })
                    
                    debug_log(f"      ✓ Added as possible slot (score={score}, conflicts={len(conflicts)})", 5)
        
        # If no possible slots, return False
        if not possible_slots:
            debug_log(f"  ✗ No possible slots found for {session.name} instance {instance_num + 1}", 1)
            debug_log(f"    Available attendees: {len(available_attendees)}", 2)
            if len(available_attendees) == 0:
                debug_log(f"    Reason: All {len(session.interested_attendees)} interested attendees already scheduled", 2)
            else:
                debug_log(f"    Check: location capacity, time availability, presenter conflicts", 2)
            return False
        
        # Sort by score (fewest conflicts first), then by day (earlier days first)
        possible_slots.sort(key=lambda x: (x['score'], x['day']))
        
        # Use the best slot (fewest conflicts)
        best_slot = possible_slots[0]
        
        # Schedule the session
        scheduled_attendees = available_attendees - best_slot['conflicts']
        if self.include_overlaps:
            scheduled_attendees = available_attendees
        
        # Check minimum session size before applying max limit
        if len(scheduled_attendees) < self.minimum_session_size:
            debug_log(f"      ✗ Only {len(scheduled_attendees)} attendees available, less than minimum {self.minimum_session_size}", 2)
            return False
        
        # Apply max_attendees limit
        if session.max_attendees > 0 and len(scheduled_attendees) > session.max_attendees:
            # Sort attendees to ensure consistent selection
            sorted_attendees = sorted(list(scheduled_attendees))
            scheduled_attendees = set(sorted_attendees[:session.max_attendees])
        
        self.schedule.append(ScheduledSession(
            session=session,
            location=best_slot['location'],
            time_slot=best_slot['time_slot'],
            attendees=scheduled_attendees
        ))
        
        # Update tracking of scheduled attendees for this session
        self.scheduled_attendees_by_session[session.name].update(scheduled_attendees)
        
        sessions_per_day[session.name][best_slot['day']] = \
            sessions_per_day[session.name].get(best_slot['day'], 0) + 1
        
        debug_log(f"      ✓ Scheduled successfully with {len(scheduled_attendees)} attendees at {format_time(best_slot['time_slot'].start_time)}", 5)
        if best_slot['conflicts']:
            debug_log(f"        Conflicts: {len(best_slot['conflicts'])} attendees", 6)
        
        return True
    
    def run(self):
        """Run the scheduling algorithm"""
        debug_log(f"Starting scheduler with {len(self.sessions)} sessions")
        debug_log(f"Available locations: {[loc.name for loc in self.locations]}")
        debug_log(f"Include overlaps: {self.include_overlaps}")
        
        # Track sessions scheduled per day
        sessions_per_day = defaultdict(lambda: defaultdict(int))
        
        # Schedule each session
        for session in self.sessions:
            debug_log(f"\nScheduling session: {session.name} (priority={session.priority})")
            scheduled_count = 0
            
            # Determine target number of sessions
            if session.max_sessions == 0:
                # Auto-determine based on attendee count and max_attendees per session
                if session.max_attendees > 0:
                    # Calculate how many sessions needed to accommodate all interested attendees
                    total_interested = len(session.interested_attendees)
                    sessions_needed = (total_interested + session.max_attendees - 1) // session.max_attendees
                    # Increase cap to 20 sessions for better coverage, can schedule more if needed
                    target_sessions = max(session.min_sessions, min(sessions_needed, 20))
                else:
                    # No attendee limit, try to accommodate everyone (cap at reasonable number)
                    # Base on total interested attendees and assume reasonable group size
                    total_interested = len(session.interested_attendees)
                    estimated_group_size = min(20, total_interested)  # Assume groups of up to 20
                    sessions_needed = (total_interested + estimated_group_size - 1) // estimated_group_size
                    target_sessions = max(session.min_sessions, min(sessions_needed, 20))
                debug_log(f"  Auto-determined target sessions: {target_sessions} (min={session.min_sessions}, interested={len(session.interested_attendees)})", 1)
            else:
                # Use the specified max as target
                target_sessions = session.max_sessions
            
            # Try to schedule up to target_sessions
            attempts = 0
            consecutive_failures = 0
            max_attempts = max(target_sessions * 3, 50)  # More attempts for auto-determine
            
            # For auto-determine, keep trying as long as attendees remain unscheduled
            continue_scheduling = True
            while continue_scheduling and attempts < max_attempts:
                if self.schedule_session_instance(session, scheduled_count, sessions_per_day):
                    scheduled_count += 1
                    consecutive_failures = 0
                    
                    # Check if we should continue scheduling
                    if session.max_sessions == 0:
                        # Auto-determine mode: keep going until all attendees scheduled or no more slots
                        unscheduled = session.interested_attendees - self.scheduled_attendees_by_session[session.name]
                        if len(unscheduled) == 0:
                            debug_log(f"  All interested attendees scheduled, stopping at {scheduled_count} sessions", 1)
                            continue_scheduling = False
                        elif len(unscheduled) < self.minimum_session_size:
                            debug_log(f"  Only {len(unscheduled)} attendees remaining (less than minimum {self.minimum_session_size}), stopping at {scheduled_count} sessions", 1)
                            continue_scheduling = False
                        elif scheduled_count >= 30:  # Absolute maximum to prevent infinite loops
                            debug_log(f"  Reached maximum of 30 sessions, stopping with {len(unscheduled)} unscheduled", 1)
                            continue_scheduling = False
                        else:
                            # Keep going - there are still enough unscheduled attendees
                            debug_log(f"  {len(unscheduled)} attendees still unscheduled, continuing (session {scheduled_count})", 2)
                    else:
                        # Fixed number mode: stop when we reach the target
                        if scheduled_count >= target_sessions:
                            continue_scheduling = False
                else:
                    consecutive_failures += 1
                    # For auto-determine, be more persistent if attendees remain unscheduled
                    if session.max_sessions == 0:
                        unscheduled = session.interested_attendees - self.scheduled_attendees_by_session[session.name]
                        # Give up after more attempts if in auto-determine mode and people are unscheduled
                        # But be VERY persistent if we haven't scheduled minimum sessions yet
                        if scheduled_count < session.min_sessions:
                            failure_threshold = 20  # Very persistent for minimum sessions
                        elif len(unscheduled) > 0:
                            failure_threshold = 15  # Persistent if people remain unscheduled
                        else:
                            failure_threshold = 3  # Can stop quickly if everyone is scheduled
                            
                        if consecutive_failures >= failure_threshold:
                            debug_log(f"  Stopping after {failure_threshold} consecutive scheduling failures", 1)
                            if len(unscheduled) > 0:
                                debug_log(f"  WARNING: {len(unscheduled)} attendees remain unscheduled for {session.name}", 1)
                            continue_scheduling = False
                    else:
                        # For fixed number of sessions, check if we've met the target
                        if scheduled_count >= target_sessions:
                            continue_scheduling = False
                        elif consecutive_failures >= 5:  # A bit more persistent
                            debug_log(f"  Stopping after 5 consecutive scheduling failures", 1)
                            continue_scheduling = False
                
                attempts += 1
            
            # Check if we met minimum requirements
            if scheduled_count < session.min_sessions:
                # Provide more context about why scheduling failed
                details = []
                if len(session.interested_attendees) == 0:
                    details.append("no attendees signed up")
                else:
                    details.append(f"{len(session.interested_attendees)} interested attendees")
                
                if len(session.presenters) > 0:
                    details.append(f"presenter(s): {', '.join(session.presenters)}")
                
                details.append(f"{session.length} minutes")
                
                if session.required:
                    self.scheduling_errors.append(
                        f"Unable to schedule minimum required sessions for '{session.name}'. "
                        f"Scheduled {scheduled_count} but minimum is {session.min_sessions}. "
                        f"Details: {', '.join(details)}"
                    )
                else:
                    self.unscheduled_sessions.append(
                        (session, f"Could only schedule {scheduled_count} of minimum {session.min_sessions} sessions ({', '.join(details)})")
                    )
            elif scheduled_count < target_sessions:
                # Scheduled some but not all target sessions
                debug_log(f"  Scheduled {scheduled_count} of target {target_sessions} sessions", 1)


def format_time(dt: datetime) -> str:
    """Format datetime as time string"""
    return dt.strftime("%-I:%M%p").lower()


def parse_schedule_file(filepath: str, format_type: str) -> List[Dict[str, Any]]:
    """Parse a schedule file and extract session information"""
    schedule_data = []
    
    if format_type == 'csv':
        with open(filepath, 'r') as f:
            reader = csv.DictReader(f)
            current_day = None
            
            for row in reader:
                day = row.get('Day', '')
                time_str = row.get('Time', '')
                
                if day:
                    current_day = day
                
                # Parse each location column
                for location in row.keys():
                    if location not in ['Day', 'Time'] and row[location] and row[location] != '-' and row[location] != '---':
                        # Extract session name and count
                        session_info = row[location]
                        if '↓' in session_info:
                            continue  # Skip continuation markers
                        
                        match = re.match(r'^(.+?)\s*\((\d+)\)', session_info)
                        if match:
                            session_name = match.group(1).strip()
                            attendee_count = int(match.group(2))
                            
                            schedule_data.append({
                                'day': current_day,
                                'time': time_str,
                                'location': location,
                                'session': session_name,
                                'attendee_count': attendee_count
                            })
                        else:
                            # Handle sessions without count
                            schedule_data.append({
                                'day': current_day,
                                'time': time_str,
                                'location': location,
                                'session': session_info.strip(),
                                'attendee_count': 0
                            })
    
    elif format_type == 'md':
        with open(filepath, 'r') as f:
            content = f.read()
            
        current_day = None
        in_table = False
        location_columns = []
        
        for line in content.split('\n'):
            if line.startswith('## '):
                current_day = line[3:].strip()
                in_table = False
            elif '|' in line and current_day:
                cells = [cell.strip() for cell in line.split('|')[1:-1]]
                
                if not in_table and cells[0].lower() == 'time':
                    # Header row
                    location_columns = cells[1:]
                    in_table = True
                elif in_table and len(cells) > 1 and '-' not in cells[0]:
                    # Data row
                    time_str = cells[0]
                    
                    for i, cell in enumerate(cells[1:]):
                        if i < len(location_columns) and cell and cell != '-' and '↓' not in cell:
                            location = location_columns[i]
                            
                            match = re.match(r'^(.+?)\s*\((\d+)\)', cell)
                            if match:
                                session_name = match.group(1).strip()
                                attendee_count = int(match.group(2))
                            else:
                                session_name = cell.strip()
                                attendee_count = 0
                            
                            schedule_data.append({
                                'day': current_day,
                                'time': time_str,
                                'location': location,
                                'session': session_name,
                                'attendee_count': attendee_count
                            })
    
    else:
        raise SchedulingError(f"Schedule validation not supported for format: {format_type}")
    
    return schedule_data


def parse_roster_file(filepath: str, format_type: str) -> List[Dict[str, Any]]:
    """Parse a roster file and extract detailed session information"""
    roster_data = []
    
    if format_type == 'csv':
        with open(filepath, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                attendees = []
                if row.get('Attendees'):
                    attendees = [a.strip() for a in row['Attendees'].split(';') if a.strip()]
                
                roster_data.append({
                    'day': row.get('Day', ''),
                    'session': row.get('Session', ''),
                    'start_time': row.get('Start Time', ''),
                    'end_time': row.get('End Time', ''),
                    'duration': int(row.get('Duration (min)', 0)),
                    'location': row.get('Location', ''),
                    'presenters': [p.strip() for p in row.get('Presenters', '').split(';') if p.strip()],
                    'attendee_count': int(row.get('Attendee Count', 0)),
                    'attendees': attendees
                })
    
    elif format_type == 'md':
        # Parse markdown roster format
        with open(filepath, 'r') as f:
            content = f.read()
        
        current_day = None
        current_session = None
        
        for line in content.split('\n'):
            if line.startswith('## '):
                current_day = line[3:].strip()
            elif line.startswith('### '):
                current_session = {
                    'day': current_day,
                    'session': line[4:].strip(),
                    'attendees': []
                }
            elif current_session and line.startswith('- **'):
                # Parse session details
                if 'Time:' in line:
                    time_match = re.search(r'(\d+:\d+[ap]m)\s*-\s*(\d+:\d+[ap]m)', line)
                    if time_match:
                        current_session['start_time'] = time_match.group(1)
                        current_session['end_time'] = time_match.group(2)
                elif 'Location:' in line:
                    current_session['location'] = line.split(':', 1)[1].strip()
                elif 'Duration:' in line:
                    duration_match = re.search(r'(\d+)\s*minutes', line)
                    if duration_match:
                        current_session['duration'] = int(duration_match.group(1))
                elif 'Presenter(s):' in line:
                    presenters_str = line.split(':', 1)[1].strip()
                    current_session['presenters'] = [p.strip() for p in presenters_str.split(',')]
                elif 'Attendees' in line:
                    count_match = re.search(r'\((\d+)\)', line)
                    if count_match:
                        current_session['attendee_count'] = int(count_match.group(1))
            elif current_session and line.strip().startswith('- ') and not line.startswith('- **'):
                # Attendee line
                attendee = line.strip()[2:].replace(' ⚠️', '').strip()
                if attendee and attendee != 'No attendees scheduled':
                    current_session['attendees'].append(attendee)
            elif line.strip() == '' and current_session:
                # End of session
                roster_data.append(current_session)
                current_session = None
    
    else:
        raise SchedulingError(f"Roster validation not supported for format: {format_type}")
    
    return roster_data


def validate_schedule(
    schedule_data: List[Dict[str, Any]],
    roster_data: List[Dict[str, Any]],
    sessions: List[Session],
    locations: List[Location],
    attendees: Dict[str, Dict[str, str]],
    days: int,
    day_names: List[str]
) -> Tuple[List[str], List[str]]:
    """
    Validate a schedule against constraints
    
    Returns: (errors, warnings)
    """
    errors = []
    warnings = []
    
    # Build lookup structures
    sessions_by_name = {s.name: s for s in sessions}
    locations_by_name = {l.name: l for l in locations}
    
    # Track scheduled instances per session
    session_instance_count = defaultdict(int)
    attendees_per_session = defaultdict(set)
    presenter_schedule = defaultdict(list)
    location_schedule = defaultdict(list)
    
    # If we have roster data, use it for more detailed validation
    if roster_data:
        for entry in roster_data:
            session_name = entry['session']
            session_instance_count[session_name] += 1
            
            # Track attendees
            for attendee in entry.get('attendees', []):
                attendees_per_session[session_name].add(attendee)
            
            # Track presenter conflicts
            for presenter in entry.get('presenters', []):
                presenter_schedule[presenter].append({
                    'session': session_name,
                    'day': entry['day'],
                    'start': entry.get('start_time', ''),
                    'end': entry.get('end_time', '')
                })
            
            # Track location usage
            location = entry.get('location', '')
            if location:
                location_schedule[location].append({
                    'session': session_name,
                    'day': entry['day'],
                    'start': entry.get('start_time', ''),
                    'end': entry.get('end_time', '')
                })
    else:
        # Use schedule data for basic validation
        for entry in schedule_data:
            session_instance_count[entry['session']] += 1
    
    # Validate session constraints
    for session in sessions:
        instances = session_instance_count.get(session.name, 0)
        
        # Check minimum sessions
        if instances < session.min_sessions:
            if session.required:
                errors.append(f"Required session '{session.name}' has {instances} instances but minimum is {session.min_sessions}")
            else:
                warnings.append(f"Session '{session.name}' has {instances} instances but minimum is {session.min_sessions}")
        
        # Check maximum sessions
        if session.max_sessions > 0 and instances > session.max_sessions:
            errors.append(f"Session '{session.name}' has {instances} instances but maximum is {session.max_sessions}")
        
        # Check if required sessions cover all attendees
        if session.required:
            scheduled_attendees = attendees_per_session.get(session.name, set())
            all_attendees = set(attendees.keys())
            missing = all_attendees - scheduled_attendees
            
            if missing:
                missing_list = sorted(list(missing))
                if len(missing_list) <= 10:
                    errors.append(f"Required session '{session.name}' missing {len(missing)} attendees: {missing_list}")
                else:
                    errors.append(f"Required session '{session.name}' missing {len(missing)} attendees: {missing_list[:10]}... (and {len(missing_list) - 10} more)")
    
    # Validate no duplicate attendees per session
    for session_name, session_attendees in attendees_per_session.items():
        if len(session_attendees) < len([a for entry in roster_data if entry['session'] == session_name for a in entry.get('attendees', [])]):
            errors.append(f"Session '{session_name}' has duplicate attendee assignments")
    
    # Validate location capacity
    if roster_data:
        for entry in roster_data:
            location_name = entry.get('location', '')
            if location_name in locations_by_name:
                location = locations_by_name[location_name]
                attendee_count = entry.get('attendee_count', 0)
                
                if attendee_count > location.hard_limit:
                    errors.append(
                        f"Session '{entry['session']}' on {entry['day']} has {attendee_count} attendees "
                        f"but {location_name} hard limit is {location.hard_limit}"
                    )
                elif attendee_count > location.soft_limit:
                    warnings.append(
                        f"Session '{entry['session']}' on {entry['day']} has {attendee_count} attendees "
                        f"exceeding {location_name} soft limit of {location.soft_limit}"
                    )
    
    # Validate presenter conflicts
    for presenter, schedule in presenter_schedule.items():
        # Sort by day and time
        schedule.sort(key=lambda x: (x['day'], x['start']))
        
        # Check for overlaps
        for i in range(len(schedule) - 1):
            curr = schedule[i]
            next_item = schedule[i + 1]
            
            if curr['day'] == next_item['day']:
                # Simple check: if start times are the same, it's a conflict
                if curr['start'] == next_item['start']:
                    errors.append(
                        f"Presenter '{presenter}' has conflicting sessions: "
                        f"'{curr['session']}' and '{next_item['session']}' on {curr['day']} at {curr['start']}"
                    )
    
    # Validate all interested attendees are scheduled
    for session in sessions:
        if not session.required:  # Required sessions already checked above
            scheduled = attendees_per_session.get(session.name, set())
            interested = session.interested_attendees
            unscheduled = interested - scheduled
            
            if unscheduled:
                unscheduled_list = sorted(list(unscheduled))
                if len(unscheduled_list) <= 10:
                    warnings.append(
                        f"Session '{session.name}' has {len(unscheduled)} interested attendees not scheduled: "
                        f"{unscheduled_list}"
                    )
                else:
                    warnings.append(
                        f"Session '{session.name}' has {len(unscheduled)} interested attendees not scheduled: "
                        f"{unscheduled_list[:10]}... (and {len(unscheduled_list) - 10} more)"
                    )
    
    return errors, warnings


def generate_markdown_output(
    schedule: List[ScheduledSession],
    locations: List[Location],
    days: int,
    time_slots: Dict[int, List[TimeSlot]],
    blackouts: List[Dict[str, Any]],
    slice_duration: timedelta,
    day_names: List[str]
) -> str:
    """Generate markdown table output"""
    output = []
    
    for day in range(days):
        output.append(f"## {day_names[day]}\n")
        
        if day not in time_slots or not time_slots[day]:
            output.append("*No sessions scheduled*\n")
            continue
        
        # Create time slot index
        all_times = set()
        for slot in time_slots[day]:
            all_times.add(slot.start_time)
        
        # Add blackout times
        for blackout in blackouts:
            if blackout['day'] == day:
                for start, end in blackout['time_ranges']:
                    current = start
                    while current < end:
                        all_times.add(current)
                        current += slice_duration
        
        sorted_times = sorted(all_times)
        
        # Create table header (deduplicate location names for display)
        unique_location_names = []
        seen_names = set()
        for loc in locations:
            if loc.name not in seen_names:
                unique_location_names.append(loc.name)
                seen_names.add(loc.name)
        
        header = ["Time"] + unique_location_names
        output.append("| " + " | ".join(header) + " |")
        output.append("|" + "|".join(["-" * (len(h) + 2) for h in header]) + "|")
        
        # Fill in schedule
        for time in sorted_times:
            row = [format_time(time)]
            
            # Check if this is a blackout time
            is_blackout = False
            blackout_name = "blackout"
            for blackout in blackouts:
                if blackout['day'] == day:
                    for start, end in blackout['time_ranges']:
                        if time >= start and time < end:
                            is_blackout = True
                            blackout_name = blackout['name']
                            break
            
            if is_blackout:
                for _ in unique_location_names:
                    row.append(f"-- {blackout_name} --")
            else:
                for location_name in unique_location_names:
                    # Find session at this time and location name
                    session_found = False
                    for scheduled in schedule:
                        if (scheduled.time_slot.day == day and
                            scheduled.location.name == location_name and
                            time >= scheduled.time_slot.start_time and
                            time < scheduled.time_slot.end_time):
                            
                            if time == scheduled.time_slot.start_time:
                                # First slot of session - show name and count
                                overlaps = ""
                                if any("(overlap)" in str(a) for a in scheduled.attendees):
                                    overlaps = " ⚠️"
                                row.append(f"{scheduled.session.name} ({len(scheduled.attendees)}){overlaps}")
                            else:
                                # Continuation of session
                                row.append("↓")
                            session_found = True
                            break
                    
                    if not session_found:
                        row.append("-")
            
            output.append("| " + " | ".join(row) + " |")
        
        output.append("")
    
    return "\n".join(output)


def generate_csv_output(
    schedule: List[ScheduledSession],
    locations: List[Location],
    days: int,
    time_slots: Dict[int, List[TimeSlot]],
    blackouts: List[Dict[str, Any]],
    slice_duration: timedelta,
    day_names: List[str]
) -> str:
    """Generate CSV output"""
    output = []
    writer = StringWriter()
    
    # Write header (deduplicate location names)
    unique_location_names = []
    seen_names = set()
    for loc in locations:
        if loc.name not in seen_names:
            unique_location_names.append(loc.name)
            seen_names.add(loc.name)
    
    header = ["Day", "Time"] + unique_location_names
    writer.writerow(header)
    
    for day in range(days):
        if day not in time_slots or not time_slots[day]:
            continue
        
        # Create time slot index
        all_times = set()
        for slot in time_slots[day]:
            all_times.add(slot.start_time)
        
        # Add blackout times
        for blackout in blackouts:
            if blackout['day'] == day:
                for start, end in blackout['time_ranges']:
                    current = start
                    while current < end:
                        all_times.add(current)
                        current += slice_duration
        
        sorted_times = sorted(all_times)
        
        # Fill in schedule
        for time in sorted_times:
            row = [day_names[day], format_time(time)]
            
            # Check if this is a blackout time
            is_blackout = False
            blackout_name = "blackout"
            for blackout in blackouts:
                if blackout['day'] == day:
                    for start, end in blackout['time_ranges']:
                        if time >= start and time < end:
                            is_blackout = True
                            blackout_name = blackout['name']
                            break
            
            if is_blackout:
                for _ in unique_location_names:
                    row.append(f"{blackout_name} (blackout)")
            else:
                for location_name in unique_location_names:
                    # Find session at this time and location
                    session_found = False
                    for scheduled in schedule:
                        if (scheduled.time_slot.day == day and
                            scheduled.location.name == location_name and
                            time >= scheduled.time_slot.start_time and
                            time < scheduled.time_slot.end_time):
                            
                            if time == scheduled.time_slot.start_time:
                                row.append(f"{scheduled.session.name} ({len(scheduled.attendees)})")
                            else:
                                row.append(scheduled.session.name)
                            session_found = True
                            break
                    
                    if not session_found:
                        row.append("---")
            
            writer.writerow(row)
    
    return writer.getvalue()


def generate_roster_markdown(
    schedule: List[ScheduledSession],
    day_names: List[str]
) -> str:
    """Generate markdown roster output with session details"""
    output = []
    output.append("# Session Roster\n")
    
    # Group sessions by day
    sessions_by_day = defaultdict(list)
    for scheduled in schedule:
        sessions_by_day[scheduled.time_slot.day].append(scheduled)
    
    # Sort days and sessions within each day
    for day in sorted(sessions_by_day.keys()):
        output.append(f"## {day_names[day]}\n")
        
        # Sort sessions by start time
        day_sessions = sorted(sessions_by_day[day], key=lambda s: s.time_slot.start_time)
        
        for scheduled in day_sessions:
            output.append(f"### {scheduled.session.name}\n")
            output.append(f"- **Time**: {format_time(scheduled.time_slot.start_time)} - {format_time(scheduled.time_slot.end_time)}")
            output.append(f"- **Location**: {scheduled.location.name}")
            output.append(f"- **Duration**: {scheduled.session.length} minutes")
            
            if scheduled.session.presenters:
                output.append(f"- **Presenter(s)**: {', '.join(scheduled.session.presenters)}")
            
            output.append(f"- **Attendees** ({len(scheduled.attendees)}):")
            if scheduled.attendees:
                # Sort attendees alphabetically
                for attendee in sorted(scheduled.attendees):
                    # Check if this is an overlap attendee
                    if "(overlap)" in str(attendee):
                        output.append(f"  - {attendee} ⚠️")
                    else:
                        output.append(f"  - {attendee}")
            else:
                output.append("  - No attendees scheduled")
            
            output.append("")  # Empty line between sessions
    
    return "\n".join(output)


def generate_roster_csv(
    schedule: List[ScheduledSession],
    day_names: List[str]
) -> str:
    """Generate CSV roster output with session details"""
    writer = StringWriter()
    
    # Write header
    header = [
        "Day", "Session", "Start Time", "End Time", "Duration (min)",
        "Location", "Presenters", "Attendee Count", "Attendees"
    ]
    writer.writerow(header)
    
    # Sort sessions by day and time
    sorted_schedule = sorted(
        schedule,
        key=lambda s: (s.time_slot.day, s.time_slot.start_time)
    )
    
    for scheduled in sorted_schedule:
        row = [
            day_names[scheduled.time_slot.day],
            scheduled.session.name,
            format_time(scheduled.time_slot.start_time),
            format_time(scheduled.time_slot.end_time),
            scheduled.session.length,
            scheduled.location.name,
            "; ".join(scheduled.session.presenters),
            len(scheduled.attendees),
            "; ".join(sorted(str(a) for a in scheduled.attendees))
        ]
        writer.writerow(row)
    
    return writer.getvalue()


def generate_roster_xlsx(
    schedule: List[ScheduledSession],
    output_file: str,
    day_names: List[str]
):
    """Generate Excel roster output with session details"""
    if not XLSX_SUPPORT:
        raise SchedulingError("Excel output requires openpyxl. Install with: pip install openpyxl")
    
    from openpyxl import Workbook
    from openpyxl.styles import PatternFill, Font, Alignment, Border, Side
    from openpyxl.utils import get_column_letter
    
    wb = Workbook()
    ws = wb.active
    ws.title = "Session Roster"
    
    # Styles
    header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
    header_font = Font(color="FFFFFF", bold=True)
    day_fill = PatternFill(start_color="D9E1F2", end_color="D9E1F2", fill_type="solid")
    day_font = Font(bold=True, size=12)
    session_fill = PatternFill(start_color="E7F3FF", end_color="E7F3FF", fill_type="solid")
    border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )
    
    # Write header
    headers = [
        "Day", "Session", "Time", "Duration", "Location", 
        "Presenter(s)", "# Attendees", "Attendee List"
    ]
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=1, column=col, value=header)
        cell.fill = header_fill
        cell.font = header_font
        cell.alignment = Alignment(horizontal="center", vertical="center")
        cell.border = border
    
    # Group and sort sessions
    sessions_by_day = defaultdict(list)
    for scheduled in schedule:
        sessions_by_day[scheduled.time_slot.day].append(scheduled)
    
    row_num = 2
    for day in sorted(sessions_by_day.keys()):
        # Day header row
        ws.merge_cells(f'A{row_num}:H{row_num}')
        day_cell = ws.cell(row=row_num, column=1, value=day_names[day])
        day_cell.fill = day_fill
        day_cell.font = day_font
        day_cell.alignment = Alignment(horizontal="center", vertical="center")
        for col in range(1, 9):
            ws.cell(row=row_num, column=col).border = border
        row_num += 1
        
        # Sort sessions by start time
        day_sessions = sorted(sessions_by_day[day], key=lambda s: s.time_slot.start_time)
        
        for scheduled in day_sessions:
            time_str = f"{format_time(scheduled.time_slot.start_time)} - {format_time(scheduled.time_slot.end_time)}"
            duration_str = f"{scheduled.session.length} min"
            presenters_str = ", ".join(scheduled.session.presenters) if scheduled.session.presenters else "N/A"
            attendees_str = ", ".join(sorted(str(a) for a in scheduled.attendees)) if scheduled.attendees else "No attendees"
            
            # Check for overlaps in attendees
            has_overlaps = any("(overlap)" in str(a) for a in scheduled.attendees)
            
            values = [
                "",  # Day column (empty for session rows)
                scheduled.session.name,
                time_str,
                duration_str,
                scheduled.location.name,
                presenters_str,
                len(scheduled.attendees),
                attendees_str
            ]
            
            for col, value in enumerate(values, 1):
                cell = ws.cell(row=row_num, column=col, value=value)
                if col == 2:  # Session name
                    cell.fill = session_fill
                    cell.font = Font(bold=True)
                cell.alignment = Alignment(
                    horizontal="left" if col in [2, 6, 8] else "center",
                    vertical="center",
                    wrap_text=(col == 8)  # Wrap attendee list
                )
                cell.border = border
                
                # Add warning color for overlaps
                if has_overlaps and col == 7:
                    cell.font = Font(color="FF0000")
            
            row_num += 1
    
    # Add summary sheet
    ws_summary = wb.create_sheet(title="Summary")
    ws_summary.append(["Session Roster Summary"])
    ws_summary.append([])
    ws_summary.append(["Total Sessions Scheduled:", len(schedule)])
    ws_summary.append(["Total Unique Sessions:", len(set(s.session.name for s in schedule))])
    ws_summary.append([])
    
    # Session counts
    session_counts = defaultdict(int)
    total_attendees_by_session = defaultdict(set)
    for scheduled in schedule:
        session_counts[scheduled.session.name] += 1
        total_attendees_by_session[scheduled.session.name].update(scheduled.attendees)
    
    ws_summary.append(["Session", "Times Scheduled", "Total Unique Attendees"])
    for session_name in sorted(session_counts.keys()):
        ws_summary.append([
            session_name,
            session_counts[session_name],
            len(total_attendees_by_session[session_name])
        ])
    
    # Adjust column widths
    for col in range(1, 9):
        if col == 8:  # Attendee list column
            ws.column_dimensions[get_column_letter(col)].width = 50
        elif col == 2:  # Session name
            ws.column_dimensions[get_column_letter(col)].width = 30
        elif col == 6:  # Presenters
            ws.column_dimensions[get_column_letter(col)].width = 25
        else:
            ws.column_dimensions[get_column_letter(col)].width = 15
    
    # Set row heights for better readability
    for row in ws.iter_rows():
        ws.row_dimensions[row[0].row].height = 20
    
    wb.save(output_file)


def generate_xlsx_output(
    schedule: List[ScheduledSession],
    locations: List[Location],
    days: int,
    time_slots: Dict[int, List[TimeSlot]],
    blackouts: List[Dict[str, Any]],
    slice_duration: timedelta,
    output_file: str,
    day_names: List[str]
):
    """Generate Excel output"""
    if not XLSX_SUPPORT:
        raise SchedulingError("Excel output requires openpyxl. Install with: pip install openpyxl")
    
    from openpyxl import Workbook
    from openpyxl.styles import PatternFill, Font, Alignment
    
    wb = Workbook()
    
    # Remove default sheet
    wb.remove(wb.active)
    
    # Colors
    header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
    header_font = Font(color="FFFFFF", bold=True)
    blackout_fill = PatternFill(start_color="808080", end_color="808080", fill_type="solid")
    session_fills = [
        PatternFill(start_color="E7F3FF", end_color="E7F3FF", fill_type="solid"),
        PatternFill(start_color="FFF2CC", end_color="FFF2CC", fill_type="solid"),
        PatternFill(start_color="E7FFE7", end_color="E7FFE7", fill_type="solid"),
        PatternFill(start_color="FFE7E7", end_color="FFE7E7", fill_type="solid"),
    ]
    
    session_colors = {}
    color_idx = 0
    
    for day in range(days):
        # Use custom day name for sheet title, but truncate if too long for Excel
        sheet_title = day_names[day][:31]  # Excel has 31 char limit for sheet names
        ws = wb.create_sheet(title=sheet_title)
        
        if day not in time_slots or not time_slots[day]:
            ws.append(["No sessions scheduled"])
            continue
        
        # Create time slot index
        all_times = set()
        for slot in time_slots[day]:
            all_times.add(slot.start_time)
        
        # Add blackout times
        for blackout in blackouts:
            if blackout['day'] == day:
                for start, end in blackout['time_ranges']:
                    current = start
                    while current < end:
                        all_times.add(current)
                        current += slice_duration
        
        sorted_times = sorted(all_times)
        
        # Write header (deduplicate location names)
        unique_location_names = []
        seen_names = set()
        for loc in locations:
            if loc.name not in seen_names:
                unique_location_names.append(loc.name)
                seen_names.add(loc.name)
        
        header = ["Time"] + unique_location_names
        ws.append(header)
        
        # Style header
        for col in range(1, len(header) + 1):
            cell = ws.cell(row=1, column=col)
            cell.fill = header_fill
            cell.font = header_font
            cell.alignment = Alignment(horizontal="center")
        
        # Fill in schedule
        for time_idx, time in enumerate(sorted_times):
            row = [format_time(time)]
            
            # Check if this is a blackout time
            is_blackout = False
            blackout_name = "blackout"
            for blackout in blackouts:
                if blackout['day'] == day:
                    for start, end in blackout['time_ranges']:
                        if time >= start and time < end:
                            is_blackout = True
                            blackout_name = blackout['name']
                            break
            
            if is_blackout:
                for _ in unique_location_names:
                    row.append(blackout_name)
            else:
                for location_name in unique_location_names:
                    # Find session at this time and location
                    session_found = False
                    for scheduled in schedule:
                        if (scheduled.time_slot.day == day and
                            scheduled.location.name == location_name and
                            time >= scheduled.time_slot.start_time and
                            time < scheduled.time_slot.end_time):
                            
                            if time == scheduled.time_slot.start_time:
                                row.append(f"{scheduled.session.name}\n({len(scheduled.attendees)} attendees)")
                            else:
                                row.append(scheduled.session.name)
                            session_found = True
                            
                            # Assign color to session
                            if scheduled.session.name not in session_colors:
                                session_colors[scheduled.session.name] = session_fills[color_idx % len(session_fills)]
                                color_idx += 1
                            
                            break
                    
                    if not session_found:
                        row.append("")
            
            ws.append(row)
            
            # Style the row
            row_num = time_idx + 2
            if is_blackout:
                for col in range(2, len(header) + 1):
                    cell = ws.cell(row=row_num, column=col)
                    cell.fill = blackout_fill
                    cell.alignment = Alignment(horizontal="center")
            else:
                # Color code sessions
                for col, location_name in enumerate(unique_location_names, start=2):
                    for scheduled in schedule:
                        if (scheduled.time_slot.day == day and
                            scheduled.location.name == location_name and
                            time >= scheduled.time_slot.start_time and
                            time < scheduled.time_slot.end_time):
                            
                            cell = ws.cell(row=row_num, column=col)
                            cell.fill = session_colors[scheduled.session.name]
                            cell.alignment = Alignment(horizontal="center", wrap_text=True)
                            break
        
        # Adjust column widths
        for col in range(1, len(header) + 1):
            ws.column_dimensions[chr(64 + col)].width = 20
    
    # Add summary sheet
    ws_summary = wb.create_sheet(title="Summary", index=0)
    ws_summary.append(["Scheduling Summary"])
    ws_summary.append([])
    ws_summary.append(["Sessions Scheduled:"])
    
    # Count sessions
    session_counts = defaultdict(int)
    for scheduled in schedule:
        session_counts[scheduled.session.name] += 1
    
    for session_name, count in sorted(session_counts.items()):
        ws_summary.append([f"  {session_name}: {count} sessions"])
    
    ws_summary.append([])
    ws_summary.append(["Total Conflicts:", sum(1 for s in schedule if any("(overlap)" in str(a) for a in s.attendees))])
    
    wb.save(output_file)


def create_arg_parser():
    """Create argument parser with detailed help"""
    parser = argparse.ArgumentParser(
        prog='simple_schedule',
        description='Simple Schedule - Multi-session event scheduling tool',
        epilog='''Examples:
  # Basic scheduling for a single-day event
  simple_schedule --attendees attendees.csv --sessions sessions.csv --locations rooms.csv

  # Multi-day conference with lunch breaks
  simple_schedule --attendees people.xlsx --sessions talks.xlsx --locations venues.xlsx \\
      --days 3 --time "9am-12pm,1pm-5pm" --slice 30m \\
      --blackout '[{"day": 0, "time": ["12pm-1pm"], "name": "Lunch"},
                   {"day": 1, "time": ["12pm-1pm"], "name": "Lunch"},
                   {"day": 2, "time": ["12pm-1pm"], "name": "Lunch"}]'

  # Generate markdown output with overlaps allowed for manual resolution
  simple_schedule --attendees attendees.md --sessions sessions.md --locations locations.md \\
      --include-overlaps --format md --output schedule.md

  # Complex scheduling with all options
  simple_schedule --attendees participants.csv --sessions workshops.csv --locations rooms.csv \\
      --days 2 --time "8:30am-12:30pm,2pm-6pm" --slice 15m \\
      --blackout '[{"day": 0, "time": ["12:30pm-2pm"], "name": "Lunch & Keynote"},
                   {"day": 1, "time": ["5pm-6pm"], "name": "Closing Reception"}]' \\
      --format xlsx --output "conference_schedule.xlsx"

  # Using delimited sessions format with custom delimiter
  simple_schedule --attendees attendees_delimited.csv --sessions sessions.csv --locations rooms.csv \\
      --delimited-sessions --delimiter ";" \\
      --format md --output schedule.md

  # Generate both schedule and detailed roster
  simple_schedule --attendees attendees.csv --sessions sessions.csv --locations rooms.csv \\
      --days 2 --format xlsx --output "schedule.xlsx" --output-roster "roster.xlsx"

  # Debug a failing schedule by dumping partial output
  simple_schedule --attendees attendees.csv --sessions sessions.csv --locations rooms.csv \\
      --dump-output --output debug_schedule.md --verbose

  # Validate an existing schedule
  simple_schedule --validate --attendees attendees.csv --sessions sessions.csv --locations rooms.csv \\
      --schedule generated_schedule.csv --roster generated_roster.csv --format csv

Template files are available at:
  /var/home/zach/Documents/notes/03_resources/templates/simple_schedule/

For more information, see the documentation at:
  https://github.com/yourusername/simple_schedule
        ''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        '--attendees',
        required=True,
        help='Path to attendees file (CSV, XLSX, or MD). Rows are attendees, columns are sessions. '
             'Values: 1/x/yes/true = definite interest, ?/maybe = optional interest'
    )
    
    parser.add_argument(
        '--delimited-sessions',
        action='store_true',
        help='Use delimited sessions format. Attendees file should have two columns: '
             'attendee_name and sessions (delimited list of session names with optional :yes/:maybe suffix)'
    )
    
    parser.add_argument(
        '--delimiter',
        default=',',
        help='Delimiter for sessions field when using --delimited-sessions (default: comma)'
    )
    
    parser.add_argument(
        '--sessions',
        required=True,
        help='Path to sessions file (CSV, XLSX, or MD) with columns: session_name, max_attendees, '
             'presenters, length, required, priority, number_of_sessions, max_per_day. '
             'Optional: blacklist_days (CSV of day indices 0-based, or -1/? for no blacklist), '
             'blacklist_time (CSV of time ranges like "9am-11am,1pm-2pm" or -1/?/0 for no blacklist). '
             'number_of_sessions can be: single number (3), range (2-5), or auto-determine (? or 0)'
    )
    
    parser.add_argument(
        '--locations',
        required=True,
        help='Path to locations file (CSV, XLSX, or MD) with columns: location_name, soft_limit, '
             'hard_limit, time_available, and optional days_available (CSV of 0-based day indices). '
             'Locations can be listed multiple times with different availability.'
    )
    
    parser.add_argument(
        '--time',
        help='Global time constraints (e.g., "8am-12pm,1pm-5pm"). Overrides location times if more restrictive'
    )
    
    parser.add_argument(
        '--days',
        type=int,
        default=1,
        help='Number of days to schedule across (default: 1)'
    )
    
    parser.add_argument(
        '--day-names',
        help='CSV string of custom day names in order (e.g., "Monday,Tuesday,Wednesday"). '
             'If not specified, defaults to "Day 1", "Day 2", etc.'
    )
    
    parser.add_argument(
        '--blackout',
        help='JSON array of blackout periods. Format: \'[{"day": 0, "time": ["12pm-1pm"], "name": "Lunch"}]\''
    )
    
    parser.add_argument(
        '--slice',
        default='60m',
        help='Time increment for schedule display (default: 60m). Examples: 30m, 1h'
    )
    
    parser.add_argument(
        '--include-overlaps',
        action='store_true',
        help='Allow scheduling conflicts but mark them with "(overlap)" for manual resolution'
    )
    
    parser.add_argument(
        '--no-back-to-back',
        action='store_true',
        help='Prevent the same session from being scheduled consecutively (back-to-back)'
    )
    
    parser.add_argument(
        '--sessions-between',
        type=int,
        default=1,
        help='Number of other sessions required between instances of the same session (default: 1, used with --no-back-to-back)'
    )
    
    parser.add_argument(
        '--minimum-session-size',
        type=int,
        default=1,
        help='Minimum number of attendees per session (default: 1). Sessions with fewer attendees will not be created.'
    )
    
    parser.add_argument(
        '--format',
        default='md',
        help='Output format(s), comma-separated for multiple (default: md). Options: md, csv, xlsx'
    )
    
    parser.add_argument(
        '--output',
        help='Output file path. If not specified, outputs to stdout'
    )
    
    parser.add_argument(
        '--output-roster',
        help='Output file path for detailed roster listing sessions with presenters, attendees, location, day and time. '
             'Uses the same format as --format'
    )
    
    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Show scheduling statistics and unscheduled sessions'
    )
    
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Enable debug output to stderr for troubleshooting'
    )
    
    parser.add_argument(
        '--dump-output',
        action='store_true',
        help='Dump partial schedule output even on failure (useful for debugging failed schedules)'
    )
    
    # Validation mode arguments
    parser.add_argument(
        '--validate',
        action='store_true',
        help='Validate an existing schedule against constraints instead of generating a new one'
    )
    
    parser.add_argument(
        '--schedule',
        help='Path to schedule file to validate (required with --validate)'
    )
    
    parser.add_argument(
        '--roster',
        help='Path to roster file to validate (optional with --validate, provides more detailed validation)'
    )
    
    return parser


def main():
    """Main entry point"""
    parser = create_arg_parser()
    args = parser.parse_args()
    
    # Set global debug flag
    global DEBUG
    DEBUG = args.debug
    
    if DEBUG:
        debug_log("Debug mode enabled")
        debug_log(f"Arguments: {vars(args)}")
    
    try:
        # Check if we're in validation mode
        if args.validate:
            if not args.schedule:
                raise SchedulingError("--schedule is required when using --validate")
            
            # Read input files for constraints
            attendees_df = read_input_file(args.attendees, "attendees")
            sessions_df = read_input_file(args.sessions, "sessions")
            locations_df = read_input_file(args.locations, "locations")
            
            # Validate and parse data
            if args.delimited_sessions:
                attendees = validate_attendees_delimited(attendees_df, sessions_df, args.delimiter)
            else:
                attendees = validate_attendees(attendees_df, sessions_df)
            sessions = validate_sessions(sessions_df, attendees)
            locations = validate_locations(locations_df)
            
            # Parse day names if provided
            day_names = parse_day_names(args.day_names, args.days) if args.day_names else [f"Day {i+1}" for i in range(args.days)]
            
            # Parse schedule and roster files
            # For validation, use the first format specified
            validation_format = args.format.split(',')[0].strip().lower()
            schedule_data = parse_schedule_file(args.schedule, validation_format)
            roster_data = []
            if args.roster:
                roster_data = parse_roster_file(args.roster, validation_format)
            
            # Validate the schedule
            errors, warnings = validate_schedule(
                schedule_data, roster_data, sessions, locations, 
                attendees, args.days, day_names
            )
            
            # Print validation results
            print("=== SCHEDULE VALIDATION REPORT ===\n")
            
            if not errors and not warnings:
                print("✓ Schedule is valid! All constraints are satisfied.")
            else:
                if errors:
                    print(f"ERRORS ({len(errors)}):")
                    for error in errors:
                        print(f"  ✗ {error}")
                    print()
                
                if warnings:
                    print(f"WARNINGS ({len(warnings)}):")
                    for warning in warnings:
                        print(f"  ⚠ {warning}")
                    print()
                
                # Summary statistics
                print("\n=== SUMMARY ===")
                session_count = defaultdict(int)
                attendee_assignments = defaultdict(set)
                
                if roster_data:
                    for entry in roster_data:
                        session_count[entry['session']] += 1
                        for attendee in entry.get('attendees', []):
                            attendee_assignments[attendee].add(entry['session'])
                else:
                    for entry in schedule_data:
                        session_count[entry['session']] += 1
                
                print(f"Total unique sessions: {len(session_count)}")
                print(f"Total session instances: {sum(session_count.values())}")
                if roster_data:
                    print(f"Total unique attendees scheduled: {len(attendee_assignments)}")
                    if len(attendee_assignments) > 0:
                        avg_sessions = sum(len(s) for s in attendee_assignments.values()) / len(attendee_assignments)
                        print(f"Average sessions per attendee: {avg_sessions:.1f}")
                    else:
                        print(f"Average sessions per attendee: 0.0 (no attendees scheduled)")
                
                # Exit with error if validation failed
                if errors:
                    sys.exit(1)
            
            return
        
        # Normal scheduling mode
        # Read input files
        attendees_df = read_input_file(args.attendees, "attendees")
        sessions_df = read_input_file(args.sessions, "sessions")
        locations_df = read_input_file(args.locations, "locations")
        
        # Validate and parse data
        if args.delimited_sessions:
            attendees = validate_attendees_delimited(attendees_df, sessions_df, args.delimiter)
        else:
            attendees = validate_attendees(attendees_df, sessions_df)
        sessions = validate_sessions(sessions_df, attendees)
        locations = validate_locations(locations_df)
        
        # Parse other parameters
        global_time = parse_time_list(args.time) if args.time else None
        blackouts = parse_blackout(args.blackout) if args.blackout else []
        slice_duration = parse_slice_duration(args.slice)
        day_names = parse_day_names(args.day_names, args.days)
        
        # Validate days vs blackouts
        max_blackout_day = max([b['day'] for b in blackouts], default=-1)
        if max_blackout_day >= args.days:
            raise SchedulingError(
                f"Blackout day {max_blackout_day} exceeds number of days ({args.days})"
            )
        
        # Generate time slots
        time_slots = generate_time_slots(
            args.days, global_time, locations, blackouts, slice_duration
        )
        
        if not time_slots or all(len(slots) == 0 for slots in time_slots.values()):
            raise SchedulingError(
                "No available time slots found. Check time constraints and blackout periods."
            )
        
        # Run scheduler
        scheduler = Scheduler(
            sessions, locations, attendees, time_slots, 
            args.include_overlaps, args.no_back_to_back, args.sessions_between,
            args.minimum_session_size
        )
        scheduler.run()
        
        # Check if there were any critical errors
        if scheduler.scheduling_errors:
            if args.dump_output:
                print("\nERROR: Scheduling failed but --dump-output specified.", file=sys.stderr)
                print("Dumping partial schedule...\n", file=sys.stderr)
                
                # Generate partial output despite errors
                try:
                    if args.format == 'md':
                        output = generate_markdown_output(
                            scheduler.schedule, locations, args.days, time_slots, blackouts, slice_duration, day_names
                        )
                        if args.output:
                            with open(args.output, 'w') as f:
                                f.write(output)
                            print(f"Partial schedule written to {args.output}", file=sys.stderr)
                        else:
                            print(output)
                            
                    elif args.format == 'csv':
                        output = generate_csv_output(
                            scheduler.schedule, locations, args.days, time_slots, blackouts, slice_duration, day_names
                        )
                        if args.output:
                            with open(args.output, 'w') as f:
                                f.write(output)
                            print(f"Partial schedule written to {args.output}", file=sys.stderr)
                        else:
                            print(output)
                            
                    elif args.format == 'xlsx':
                        if not args.output:
                            print("ERROR: Excel format requires --output parameter", file=sys.stderr)
                        else:
                            generate_xlsx_output(
                                scheduler.schedule, locations, args.days, time_slots, 
                                blackouts, slice_duration, args.output, day_names
                            )
                            print(f"Partial schedule written to {args.output}", file=sys.stderr)
                    
                    # Also generate roster if requested
                    if args.output_roster:
                        if args.format == 'md':
                            roster_output = generate_roster_markdown(scheduler.schedule, day_names)
                            with open(args.output_roster, 'w') as f:
                                f.write(roster_output)
                            print(f"Partial roster written to {args.output_roster}", file=sys.stderr)
                                
                        elif args.format == 'csv':
                            roster_output = generate_roster_csv(scheduler.schedule, day_names)
                            with open(args.output_roster, 'w') as f:
                                f.write(roster_output)
                            print(f"Partial roster written to {args.output_roster}", file=sys.stderr)
                                
                        elif args.format == 'xlsx':
                            generate_roster_xlsx(scheduler.schedule, args.output_roster, day_names)
                            print(f"Partial roster written to {args.output_roster}", file=sys.stderr)
                            
                except Exception as e:
                    print(f"ERROR while dumping partial output: {e}", file=sys.stderr)
                
                # Print the scheduling errors
                print("\nScheduling errors encountered:", file=sys.stderr)
                for error in scheduler.scheduling_errors:
                    print(f"  - {error}", file=sys.stderr)
                
                # Still exit with error
                raise SchedulingError("\n".join(scheduler.scheduling_errors))
            else:
                # Normal error handling without dump
                raise SchedulingError("\n".join(scheduler.scheduling_errors))
        
        # Parse output formats
        formats = [f.strip().lower() for f in args.format.split(',')]
        valid_formats = ['md', 'csv', 'xlsx']
        for fmt in formats:
            if fmt not in valid_formats:
                raise SchedulingError(f"Invalid format '{fmt}'. Valid formats: {', '.join(valid_formats)}")
        
        # Generate output
        for fmt in formats:
            # Determine output file name
            if args.output and len(formats) > 1:
                # Multiple formats: append extension
                base_output = args.output.rsplit('.', 1)[0] if '.' in args.output else args.output
                output_file = f"{base_output}.{fmt}"
            else:
                output_file = args.output
            
            if fmt == 'md':
                output = generate_markdown_output(
                    scheduler.schedule, locations, args.days, time_slots, blackouts, slice_duration, day_names
                )
                if output_file:
                    with open(output_file, 'w') as f:
                        f.write(output)
                    if len(formats) > 1:
                        print(f"Markdown schedule written to {output_file}")
                else:
                    print(output)
                    
            elif fmt == 'csv':
                output = generate_csv_output(
                    scheduler.schedule, locations, args.days, time_slots, blackouts, slice_duration, day_names
                )
                if output_file:
                    with open(output_file, 'w') as f:
                        f.write(output)
                    if len(formats) > 1:
                        print(f"CSV schedule written to {output_file}")
                else:
                    print(output)
                    
            elif fmt == 'xlsx':
                if not output_file:
                    raise SchedulingError("Excel format requires --output parameter")
                generate_xlsx_output(
                    scheduler.schedule, locations, args.days, time_slots, 
                    blackouts, slice_duration, output_file, day_names
                )
                print(f"Excel schedule written to {output_file}")
        
        # Generate roster if requested
        if args.output_roster:
            for fmt in formats:
                # Determine roster file name
                if len(formats) > 1:
                    # Multiple formats: append extension
                    base_roster = args.output_roster.rsplit('.', 1)[0] if '.' in args.output_roster else args.output_roster
                    roster_file = f"{base_roster}.{fmt}"
                else:
                    roster_file = args.output_roster
                
                if fmt == 'md':
                    roster_output = generate_roster_markdown(scheduler.schedule, day_names)
                    with open(roster_file, 'w') as f:
                        f.write(roster_output)
                    print(f"Markdown roster written to {roster_file}")
                        
                elif fmt == 'csv':
                    roster_output = generate_roster_csv(scheduler.schedule, day_names)
                    with open(roster_file, 'w') as f:
                        f.write(roster_output)
                    print(f"CSV roster written to {roster_file}")
                        
                elif fmt == 'xlsx':
                    generate_roster_xlsx(scheduler.schedule, roster_file, day_names)
                    print(f"Excel roster written to {roster_file}")
        
        # Show verbose output
        if args.verbose:
            print("\n--- Scheduling Statistics ---", file=sys.stderr)
            print(f"Sessions scheduled: {len(scheduler.schedule)}", file=sys.stderr)
            
            if scheduler.unscheduled_sessions:
                print(f"\nUnscheduled sessions ({len(scheduler.unscheduled_sessions)}):", file=sys.stderr)
                for session, reason in scheduler.unscheduled_sessions:
                    print(f"  - {session.name}: {reason}", file=sys.stderr)
            
            # Calculate metrics
            total_conflicts = sum(
                1 for s in scheduler.schedule 
                if any("(overlap)" in str(a) for a in s.attendees)
            )
            print(f"\nTotal conflicts: {total_conflicts}", file=sys.stderr)
            
            # Room utilization
            room_usage = defaultdict(int)
            for scheduled in scheduler.schedule:
                room_usage[scheduled.location.name] += 1
            
            print("\nRoom utilization:", file=sys.stderr)
            for room, count in sorted(room_usage.items()):
                print(f"  - {room}: {count} sessions", file=sys.stderr)
    
    except SchedulingError as e:
        print(f"ERROR: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


# CSV string writer helper
class StringWriter:
    def __init__(self):
        self.rows = []
    
    def writerow(self, row):
        self.rows.append(row)
    
    def getvalue(self):
        import io
        output = io.StringIO()
        writer = csv.writer(output)
        for row in self.rows:
            writer.writerow(row)
        return output.getvalue()


if __name__ == '__main__':
    main()
