#!/bin/bash
set -euo pipefail

# ==============================================================================
# compress_video - Video Compression Utility
# ==============================================================================
# Author: Zach
# Version: 1.0
# Last Updated: $(date)
# Location: ~/.dotfiles/bin/scripts/compress_video
#
# Description:
# A robust video compression script that uses podman with the linuxserver/ffmpeg
# container. Supports hardware acceleration via VAAPI when available, configurable
# codecs, quality settings, and various output options.
#
# Features:
# - Hardware acceleration support (VAAPI) with automatic detection
# - H.265/HEVC default encoding with H.264 fallback
# - Vorbis audio encoding by default
# - Configurable quality settings
# - Batch processing support
# - Output directory management
# - Flexible codec and format options
#
# Dependencies:
# - podman: Container runtime
# - linuxserver/ffmpeg container image
# - /dev/dri/renderD128: For hardware acceleration (optional)
#
# Usage: See show_help() function or run with -h/--help
# ==============================================================================

# Default configuration
QUALITY="medium"
VIDEO_CODEC="h265"
AUDIO_CODEC="vorbis"
OUTPUT_FORMAT="mkv"
USE_HWACCEL="auto"
PREFER_VULKAN=false
PREFER_SOFTWARE=false
OUTPUT_DIR="output"
CONTAINER_IMAGE="docker.io/linuxserver/ffmpeg:latest"
HWACCEL_DEVICE="/dev/dri/renderD128"
VERBOSE=false
DRY_RUN=false
USE_JOURNAL=false
JOURNAL_FILE=""
FORCE_RECONVERT=false
CUSTOM_CRF=""

# Quality presets (CRF values)
declare -A QUALITY_PRESETS=(
    ["low"]="28"
    ["medium"]="23"
    ["high"]="18"
    ["veryhigh"]="15"
)

# Quality presets for bitrate (used for Vulkan)
declare -A QUALITY_BITRATES=(
    ["low"]="2M"
    ["medium"]="5M"
    ["high"]="10M"
    ["veryhigh"]="20M"
)

# Video codec mapping
declare -A VIDEO_CODEC_MAP=(
    ["h264"]="libx264"
    ["h265"]="libx265"
    ["vp9"]="libvpx-vp9"
    ["av1"]="libaom-av1"
)

# Audio codec mapping
declare -A AUDIO_CODEC_MAP=(
    ["vorbis"]="libvorbis"
    ["opus"]="libopus"
    ["aac"]="aac"
    ["mp3"]="libmp3lame"
    ["copy"]="copy"
)

# Show help message
show_help() {
    cat << EOF
compress_video - Video compression utility using podman and ffmpeg

USAGE:
    compress_video [OPTIONS] <input_file> [input_file2 ...]

DESCRIPTION:
    Compress video files using ffmpeg in a podman container with optional
    hardware acceleration support.

OPTIONS:
    -h, --help                  Show this help message
    -q, --quality QUALITY       Quality preset: low, medium, high, veryhigh (default: medium)
    -c, --crf VALUE            Custom CRF value (overrides quality preset)
    -v, --video-codec CODEC    Video codec: h264, h265, vp9, av1 (default: h265)
    -a, --audio-codec CODEC    Audio codec: vorbis, opus, aac, mp3, copy (default: vorbis)
    -f, --format FORMAT        Output format: mkv, mp4, webm (default: mkv)
    -o, --output-dir DIR       Output directory (default: ./output)
    -O, --output-file FILE     Specific output filename (single file mode only)
    --no-hwaccel               Disable hardware acceleration
    --force-hwaccel            Force hardware acceleration (fail if unavailable)
    --vulkan                   Prefer Vulkan over VAAPI when available
    --resolution RES           Scale to resolution (e.g., 1280x720, 1920x1080)
    --bitrate RATE             Target bitrate (e.g., 4M, 8M)
    --preset PRESET            FFmpeg preset: ultrafast, fast, medium, slow, veryslow
    --dry-run                  Show command without executing
    --verbose                  Enable verbose output
    --container IMAGE          Use custom container image (default: docker.io/linuxserver/ffmpeg:latest)
    --journal                  Enable journal tracking to skip already converted files
    --journal-file FILE        Custom journal file path (default: ./compress_video_status.log)
    --force-reconvert          Force reconversion even if file is in journal
    --list-encoders            List available video encoders in the container
    --prefer-software          Prefer software encoding over hardware acceleration

EXAMPLES:
    # Basic compression with defaults (H.265, medium quality)
    compress_video input.mp4

    # High quality H.264 compression
    compress_video -q high -v h264 input.mp4

    # Custom CRF with specific output
    compress_video -c 20 -O compressed.mkv input.mp4

    # Batch processing with VP9
    compress_video -v vp9 -f webm *.mp4

    # Force software encoding with custom resolution
    compress_video --no-hwaccel --resolution 1280x720 input.mp4

    # Batch processing with journal (resumable)
    compress_video --journal *.mp4

    # Resume interrupted batch processing
    compress_video --journal *.mp4  # Will skip already converted files

    # Use Vulkan hardware acceleration
    compress_video --vulkan input.mp4

    # Force software encoding (if hardware encoders fail)
    compress_video --prefer-software input.mp4

QUALITY GUIDE:
    Software/VAAPI (CRF mode):
    - low (CRF 28): Smaller files, acceptable quality
    - medium (CRF 23): Balanced size/quality (default)
    - high (CRF 18): Very good quality, larger files
    - veryhigh (CRF 15): Excellent quality, much larger files
    
    Vulkan (Bitrate mode):
    - low: 2 Mbps bitrate
    - medium: 5 Mbps bitrate (default)
    - high: 10 Mbps bitrate
    - veryhigh: 20 Mbps bitrate

VULKAN SUPPORT:
    The script automatically detects your GPU vendor and sets the appropriate
    environment variables for Vulkan video decode:
    - Intel GPUs: ANV_VIDEO_DECODE=1
    - AMD GPUs: RADV_PERFTEST=video_decode
    - NVIDIA GPUs: Requires Vulkan Beta drivers installed on host

EOF
}

# Logging functions
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

error() {
    echo "[ERROR] $*" >&2
}

debug() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "[DEBUG] $*" >&2
    fi
}

# Journal functions
init_journal() {
    if [[ "$USE_JOURNAL" == "true" ]]; then
        # Set default journal file if not specified
        if [[ -z "$JOURNAL_FILE" ]]; then
            JOURNAL_FILE="./compress_video_status.log"
        fi
        
        # Create journal file if it doesn't exist
        if [[ ! -f "$JOURNAL_FILE" ]]; then
            touch "$JOURNAL_FILE"
            debug "Created journal file: $JOURNAL_FILE"
        else
            debug "Using existing journal file: $JOURNAL_FILE"
        fi
    fi
}

# Check if a file has been converted based on journal
is_converted() {
    local input_file="$1"
    local output_file="$2"
    
    if [[ "$USE_JOURNAL" != "true" ]] || [[ "$FORCE_RECONVERT" == "true" ]]; then
        return 1  # Not converted or force reconvert
    fi
    
    # Create a unique identifier for this conversion
    local entry="${input_file}|${output_file}|${VIDEO_CODEC}|${AUDIO_CODEC}|${QUALITY}${CUSTOM_CRF:+|crf:$CUSTOM_CRF}"
    
    # Check if entry exists in journal
    if grep -Fxq "$entry" "$JOURNAL_FILE" 2>/dev/null; then
        return 0  # Already converted
    fi
    
    return 1  # Not converted
}

# Add entry to journal
add_to_journal() {
    local input_file="$1"
    local output_file="$2"
    
    if [[ "$USE_JOURNAL" == "true" ]]; then
        # Create a unique identifier for this conversion
        local entry="${input_file}|${output_file}|${VIDEO_CODEC}|${AUDIO_CODEC}|${QUALITY}${CUSTOM_CRF:+|crf:$CUSTOM_CRF}"
        
        # Add entry with timestamp
        echo "$entry" >> "$JOURNAL_FILE"
        debug "Added to journal: $entry"
    fi
}

# Check if hardware acceleration is available
check_hwaccel() {
    if [[ -c "$HWACCEL_DEVICE" ]]; then
        debug "Hardware acceleration device found: $HWACCEL_DEVICE"
        return 0
    else
        debug "Hardware acceleration device not found: $HWACCEL_DEVICE"
        return 1
    fi
}

# Check if Vulkan is available and detect GPU vendor
check_vulkan() {
    # Check if DRI device exists (required for Vulkan)
    if [[ ! -d "/dev/dri" ]]; then
        debug "No DRI devices found, Vulkan not available"
        return 1
    fi
    
    # Detect GPU vendor
    local gpu_vendor=""
    if command -v lspci >/dev/null 2>&1; then
        local gpu_info=$(lspci 2>/dev/null | grep -E "VGA|3D|Display" | head -1)
        if [[ "$gpu_info" =~ Intel ]]; then
            gpu_vendor="intel"
            debug "Intel GPU detected for Vulkan"
        elif [[ "$gpu_info" =~ AMD|ATI|Radeon ]]; then
            gpu_vendor="amd"
            debug "AMD GPU detected for Vulkan"
        elif [[ "$gpu_info" =~ NVIDIA|GeForce ]]; then
            gpu_vendor="nvidia"
            debug "NVIDIA GPU detected for Vulkan"
        fi
    fi
    
    # If lspci is not available, try checking render nodes
    if [[ -z "$gpu_vendor" ]] && [[ -e "/sys/class/drm/renderD128/device/vendor" ]]; then
        local vendor_id=$(cat /sys/class/drm/renderD128/device/vendor 2>/dev/null)
        case "$vendor_id" in
            "0x8086") gpu_vendor="intel" ;;
            "0x1002") gpu_vendor="amd" ;;
            "0x10de") gpu_vendor="nvidia" ;;
        esac
        debug "GPU vendor detected via sysfs: $gpu_vendor"
    fi
    
    if [[ -n "$gpu_vendor" ]]; then
        echo "$gpu_vendor"
        return 0
    else
        debug "Could not detect GPU vendor, but Vulkan may still work"
        echo "unknown"
        return 0
    fi
}

# List available encoders
list_encoders() {
    log "Listing available video encoders in container..."
    
    local podman_cmd=(
        "podman" "run" "--rm" "-it"
        "--security-opt" "label=disable"
        "$CONTAINER_IMAGE"
        "-encoders"
    )
    
    # Run the command and filter for video encoders
    "${podman_cmd[@]}" 2>/dev/null | grep -E "^ V.*" | sort
    
    exit 0
}

# Parse command line arguments
parse_args() {
    local args=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -q|--quality)
                QUALITY="$2"
                if [[ ! "${QUALITY_PRESETS[$QUALITY]+isset}" ]]; then
                    error "Invalid quality preset: $QUALITY"
                    exit 1
                fi
                shift 2
                ;;
            -c|--crf)
                CUSTOM_CRF="$2"
                shift 2
                ;;
            -v|--video-codec)
                VIDEO_CODEC="$2"
                if [[ ! "${VIDEO_CODEC_MAP[$VIDEO_CODEC]+isset}" ]]; then
                    error "Invalid video codec: $VIDEO_CODEC"
                    exit 1
                fi
                shift 2
                ;;
            -a|--audio-codec)
                AUDIO_CODEC="$2"
                if [[ ! "${AUDIO_CODEC_MAP[$AUDIO_CODEC]+isset}" ]]; then
                    error "Invalid audio codec: $AUDIO_CODEC"
                    exit 1
                fi
                shift 2
                ;;
            -f|--format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            -o|--output-dir)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -O|--output-file)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            --no-hwaccel)
                USE_HWACCEL="no"
                shift
                ;;
            --force-hwaccel)
                USE_HWACCEL="force"
                shift
                ;;
            --vulkan)
                PREFER_VULKAN=true
                shift
                ;;
            --resolution)
                RESOLUTION="$2"
                shift 2
                ;;
            --bitrate)
                BITRATE="$2"
                shift 2
                ;;
            --preset)
                FFMPEG_PRESET="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --container)
                CONTAINER_IMAGE="$2"
                shift 2
                ;;
            --journal)
                USE_JOURNAL=true
                shift
                ;;
            --journal-file)
                USE_JOURNAL=true
                JOURNAL_FILE="$2"
                shift 2
                ;;
            --force-reconvert)
                FORCE_RECONVERT=true
                shift
                ;;
            --list-encoders)
                list_encoders
                ;;
            --prefer-software)
                PREFER_SOFTWARE=true
                shift
                ;;
            -*)
                error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    
    # Store remaining arguments as input files
    INPUT_FILES=("${args[@]}")
    
    # Validate input files
    if [[ ${#INPUT_FILES[@]} -eq 0 ]]; then
        error "No input files specified"
        show_help
        exit 1
    fi
    
    # Check for conflicting options
    if [[ -n "${OUTPUT_FILE:-}" ]] && [[ ${#INPUT_FILES[@]} -gt 1 ]]; then
        error "Cannot use --output-file with multiple input files"
        exit 1
    fi
}

# Build FFmpeg command arguments
build_ffmpeg_args() {
    local input_file="$1"
    local output_file="$2"
    local input_dir="$3"
    local output_dir="$4"
    local args=()
    
    # Determine CRF value
    local crf="${CUSTOM_CRF:-${QUALITY_PRESETS[$QUALITY]}}"
    
    # Determine hardware acceleration type
    local hw_type="none"
    local use_hw=false
    local gpu_vendor=""
    
    if [[ "$USE_HWACCEL" != "no" ]] && [[ "$PREFER_SOFTWARE" != "true" ]]; then
        # Check for Vulkan first if preferred
        if [[ "$PREFER_VULKAN" == "true" ]]; then
            gpu_vendor=$(check_vulkan)
            if [[ $? -eq 0 ]]; then
                hw_type="vulkan"
                use_hw=true
                debug "Using Vulkan with GPU vendor: $gpu_vendor"
            fi
        fi
        
        # Fall back to VAAPI if Vulkan not available or not preferred
        if [[ "$use_hw" == "false" ]] && check_hwaccel; then
            hw_type="vaapi"
            use_hw=true
        fi
        
        # Handle force mode
        if [[ "$USE_HWACCEL" == "force" ]] && [[ "$use_hw" == "false" ]]; then
            error "Hardware acceleration forced but no device available"
            exit 1
        fi
    else
        debug "Using software encoding (hardware acceleration disabled or software preferred)"
    fi
    
    # Build FFmpeg arguments based on acceleration type
    if [[ "$hw_type" == "vulkan" ]]; then
        args+=("-init_hw_device" "vulkan=vk:0")
        args+=("-hwaccel" "vulkan")
        args+=("-hwaccel_output_format" "vulkan")
    elif [[ "$hw_type" == "vaapi" ]]; then
        args+=("-vaapi_device" "/dev/dri/renderD128")
    fi
    
    # Determine input path in container
    local input_basename
    input_basename="$(basename "$input_file")"
    if [[ "$input_dir" == "$output_dir" ]]; then
        args+=("-i" "/config/${input_basename}")
    else
        args+=("-i" "/input/${input_basename}")
    fi
    
    # Video codec settings
    if [[ "$hw_type" == "vulkan" ]]; then
        # Vulkan uses h264_vulkan or hevc_vulkan encoders
        if [[ "$VIDEO_CODEC" == "h264" ]]; then
            args+=("-c:v" "h264_vulkan")
        elif [[ "$VIDEO_CODEC" == "h265" ]]; then
            args+=("-c:v" "hevc_vulkan")
        else
            # For other codecs, fall back to software (Vulkan only supports h264/h265)
            args+=("-c:v" "${VIDEO_CODEC_MAP[$VIDEO_CODEC]}")
            debug "Warning: Vulkan only supports h264/h265, falling back to software for $VIDEO_CODEC"
        fi
        
        # Vulkan needs format conversion and proper filter chain
        if [[ -n "${RESOLUTION:-}" ]]; then
            args+=("-vf" "format=nv12,hwupload,scale_vulkan=${RESOLUTION}")
        else
            # Even without scaling, Vulkan needs format conversion
            args+=("-vf" "format=nv12,hwupload")
        fi
    elif [[ "$hw_type" == "vaapi" ]] && [[ "$VIDEO_CODEC" == "h264" || "$VIDEO_CODEC" == "h265" ]]; then
        # VAAPI uses h264_vaapi but hevc_vaapi (not h265_vaapi)
        if [[ "$VIDEO_CODEC" == "h265" ]]; then
            args+=("-c:v" "hevc_vaapi")
        else
            args+=("-c:v" "${VIDEO_CODEC}_vaapi")
        fi
        
        # Hardware scaling if resolution is specified
        if [[ -n "${RESOLUTION:-}" ]]; then
            local width="${RESOLUTION%x*}"
            local height="${RESOLUTION#*x}"
            args+=("-vf" "format=nv12|vaapi,hwupload,scale_vaapi=w=${width}:h=${height}")
        else
            args+=("-vf" "format=nv12|vaapi,hwupload")
        fi
    else
        args+=("-c:v" "${VIDEO_CODEC_MAP[$VIDEO_CODEC]}")
        
        # Software scaling if resolution is specified
        if [[ -n "${RESOLUTION:-}" ]]; then
            args+=("-vf" "scale=${RESOLUTION}")
        fi
    fi
    
    # Quality settings
    if [[ -n "${BITRATE:-}" ]]; then
        # User specified bitrate
        args+=("-b:v" "$BITRATE")
    elif [[ "$hw_type" == "vulkan" ]]; then
        # Vulkan doesn't support CRF, use bitrate based on quality preset
        local vulkan_bitrate="${QUALITY_BITRATES[$QUALITY]}"
        args+=("-b:v" "$vulkan_bitrate")
        debug "Using bitrate $vulkan_bitrate for Vulkan (quality: $QUALITY)"
    else
        # Use CRF for software and VAAPI encoding
        args+=("-crf" "$crf")
    fi
    
    # FFmpeg preset if specified
    if [[ -n "${FFMPEG_PRESET:-}" ]]; then
        args+=("-preset" "$FFMPEG_PRESET")
    fi
    
    # Audio codec settings
    if [[ "$AUDIO_CODEC" == "copy" ]]; then
        args+=("-c:a" "copy")
    else
        args+=("-c:a" "${AUDIO_CODEC_MAP[$AUDIO_CODEC]}")
        
        # Audio quality settings
        if [[ "$AUDIO_CODEC" == "vorbis" ]]; then
            args+=("-q:a" "4")
        elif [[ "$AUDIO_CODEC" == "opus" ]]; then
            args+=("-b:a" "128k")
        fi
    fi
    
    # Determine output path in container
    local output_basename
    output_basename="$(basename "$output_file")"
    if [[ "$input_dir" == "$output_dir" ]]; then
        args+=("/config/${output_basename}")
    else
        args+=("/output/${output_basename}")
    fi
    
    # Output each argument on a separate line
    printf '%s\n' "${args[@]}"
    
    # Output GPU vendor info on a special line if using Vulkan
    if [[ "$hw_type" == "vulkan" ]] && [[ -n "$gpu_vendor" ]]; then
        printf '__GPU_VENDOR__%s\n' "$gpu_vendor"
    fi
}

# Process a single video file
process_video() {
    local input_file="$1"
    local output_file="$2"
    
    # Check journal to see if already converted
    if is_converted "$input_file" "$output_file"; then
        log "Skipping (already converted): $input_file"
        return 0
    fi
    
    log "Processing: $input_file -> $output_file"
    
    # Get absolute paths
    local input_dir="$(dirname "$(realpath "$input_file")")"
    
    # Create output directory if needed
    local output_parent="$(dirname "$output_file")"
    if [[ ! -d "$output_parent" ]]; then
        mkdir -p "$output_parent"
    fi
    
    local output_dir="$(realpath "$output_parent")"
    
    # Build FFmpeg arguments as array and extract GPU vendor
    local ffmpeg_args=()
    local gpu_vendor=""
    while IFS= read -r arg; do
        if [[ "$arg" =~ ^__GPU_VENDOR__(.*)$ ]]; then
            gpu_vendor="${BASH_REMATCH[1]}"
        else
            ffmpeg_args+=("$arg")
        fi
    done < <(build_ffmpeg_args "$input_file" "$output_file" "$input_dir" "$output_dir")
    
    # Build podman command
    local podman_cmd=(
        "podman" "run" "--rm" "-it"
        "--security-opt" "label=disable"
    )
    
    # Add hardware acceleration device if needed
    if [[ "$USE_HWACCEL" != "no" ]]; then
        # For Vulkan, we need the entire /dev/dri directory
        if [[ "$PREFER_VULKAN" == "true" ]] && [[ -n "$gpu_vendor" ]]; then
            podman_cmd+=("--device=/dev/dri:/dev/dri")
            
            # Add vendor-specific Vulkan environment variable
            case "$gpu_vendor" in
                "intel")
                    podman_cmd+=("-e" "ANV_VIDEO_DECODE=1")
                    debug "Setting Intel Vulkan env: ANV_VIDEO_DECODE=1"
                    ;;
                "amd")
                    podman_cmd+=("-e" "RADV_PERFTEST=video_decode")
                    debug "Setting AMD Vulkan env: RADV_PERFTEST=video_decode"
                    ;;
                "nvidia")
                    # Nvidia requires beta drivers on host
                    debug "NVIDIA GPU detected - ensure Vulkan Beta drivers are installed"
                    ;;
                *)
                    # Try Intel env var as default
                    podman_cmd+=("-e" "ANV_VIDEO_DECODE=1")
                    debug "Unknown GPU vendor, trying Intel Vulkan env"
                    ;;
            esac
        elif check_hwaccel; then
            podman_cmd+=("--device=$HWACCEL_DEVICE:$HWACCEL_DEVICE")
        fi
    fi
    
    # Add volume mounts
    # If input and output directories are the same, mount once
    if [[ "$input_dir" == "$output_dir" ]]; then
        podman_cmd+=("-v" "${input_dir}:/config:z")
    else
        # Mount both directories - we'll need to adjust paths
        podman_cmd+=(
            "-v" "${input_dir}:/input:z"
            "-v" "${output_dir}:/output:z"
        )
    fi
    
    # Add container image and ffmpeg command
    podman_cmd+=(
        "$CONTAINER_IMAGE"
        "${ffmpeg_args[@]}"
    )
    
    # Show command if verbose or dry run
    if [[ "$VERBOSE" == "true" ]] || [[ "$DRY_RUN" == "true" ]]; then
        debug "Command: ${podman_cmd[*]}"
    fi
    
    # Execute command
    if [[ "$DRY_RUN" == "false" ]]; then
        if "${podman_cmd[@]}"; then
            log "Successfully compressed: $output_file"
            # Add to journal on success
            add_to_journal "$input_file" "$output_file"
        else
            error "Failed to compress: $input_file"
            return 1
        fi
    else
        log "[DRY RUN] Would execute: ${podman_cmd[*]}"
    fi
}

# Main function
main() {
    parse_args "$@"
    
    # Initialize journal if enabled
    init_journal
    
    # Create output directory if it doesn't exist
    if [[ -z "${OUTPUT_FILE:-}" ]] && [[ "$DRY_RUN" == "false" ]]; then
        mkdir -p "$OUTPUT_DIR"
    fi
    
    # Process each input file
    local failed=0
    local skipped=0
    for input_file in "${INPUT_FILES[@]}"; do
        # Check if input file exists
        if [[ ! -f "$input_file" ]]; then
            error "Input file not found: $input_file"
            ((failed++))
            continue
        fi
        
        # Determine output filename
        local output_file
        if [[ -n "${OUTPUT_FILE:-}" ]]; then
            output_file="$OUTPUT_FILE"
        else
            local basename="$(basename "$input_file")"
            local name="${basename%.*}"
            output_file="${OUTPUT_DIR}/${name}.${OUTPUT_FORMAT}"
        fi
        
        # Check if already converted (for counting)
        if is_converted "$input_file" "$output_file"; then
            ((skipped++))
        fi
        
        # Process the video
        if ! process_video "$input_file" "$output_file"; then
            ((failed++))
        fi
    done
    
    # Summary
    if [[ ${#INPUT_FILES[@]} -gt 1 ]]; then
        local processed=$((${#INPUT_FILES[@]} - failed - skipped))
        log "Summary: Processed $processed, Skipped $skipped, Failed $failed (Total: ${#INPUT_FILES[@]})"
        if [[ "$USE_JOURNAL" == "true" ]]; then
            log "Journal file: $JOURNAL_FILE"
        fi
    fi
    
    # Exit with error if any files failed
    if [[ $failed -gt 0 ]]; then
        exit 1
    fi
}

# Run main function
main "$@"