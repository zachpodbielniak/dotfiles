#!/bin/bash
set -euo pipefail

# ==============================================================================
# compress_video - Video Compression Utility
# ==============================================================================
# Author: Zach
# Version: 1.0
# Last Updated: $(date)
# Location: ~/.dotfiles/bin/scripts/compress_video
#
# Description:
# A robust video compression script that uses podman with the linuxserver/ffmpeg
# container. Supports hardware acceleration via VAAPI when available, configurable
# codecs, quality settings, and various output options.
#
# Features:
# - Hardware acceleration support (VAAPI) with automatic detection
# - H.265/HEVC default encoding with H.264 fallback
# - Vorbis audio encoding by default
# - Configurable quality settings
# - Batch processing support
# - Output directory management
# - Flexible codec and format options
#
# Dependencies:
# - podman: Container runtime
# - linuxserver/ffmpeg container image
# - /dev/dri/renderD128: For hardware acceleration (optional)
# - parallel: GNU parallel for concurrent processing (optional)
#
# Usage: See show_help() function or run with -h/--help
# ==============================================================================

# Default configuration
QUALITY="medium"
VIDEO_CODEC="h265"
AUDIO_CODEC="vorbis"
OUTPUT_FORMAT="mkv"
USE_HWACCEL="auto"
PREFER_VULKAN=false
PREFER_SOFTWARE=false
OUTPUT_DIR="output"
CONTAINER_IMAGE="docker.io/linuxserver/ffmpeg:latest"
HWACCEL_DEVICE="/dev/dri/renderD128"
VERBOSE=false
DRY_RUN=false
USE_JOURNAL=false
JOURNAL_FILE=""
FORCE_RECONVERT=false
CUSTOM_CRF=""
PARALLEL_JOBS=1
PARALLEL_TYPE=""
PARALLEL_CHILD=false

# Quality presets (CRF values)
declare -A QUALITY_PRESETS=(
    ["low"]="28"
    ["medium"]="23"
    ["high"]="18"
    ["veryhigh"]="15"
)

# Quality presets for bitrate (used for Vulkan)
declare -A QUALITY_BITRATES=(
    ["low"]="2M"
    ["medium"]="5M"
    ["high"]="10M"
    ["veryhigh"]="20M"
)

# Video codec mapping
declare -A VIDEO_CODEC_MAP=(
    ["h264"]="libx264"
    ["h265"]="libx265"
    ["vp9"]="libvpx-vp9"
    ["av1"]="libaom-av1"
)

# Audio codec mapping
declare -A AUDIO_CODEC_MAP=(
    ["vorbis"]="libvorbis"
    ["opus"]="libopus"
    ["aac"]="aac"
    ["mp3"]="libmp3lame"
    ["copy"]="copy"
)

# Show help message
show_help() {
    cat << EOF
compress_video - Video compression utility using podman and ffmpeg

USAGE:
    compress_video [OPTIONS] <input_file> [input_file2 ...]

DESCRIPTION:
    Compress video files using ffmpeg in a podman container with optional
    hardware acceleration support.

OPTIONS:
    -h, --help                  Show this help message
    -q, --quality QUALITY       Quality preset: low, medium, high, veryhigh (default: medium)
    -c, --crf VALUE            Custom CRF value (overrides quality preset)
    -v, --video-codec CODEC    Video codec: h264, h265, vp9, av1 (default: h265)
    -a, --audio-codec CODEC    Audio codec: vorbis, opus, aac, mp3, copy (default: vorbis)
    -f, --format FORMAT        Output format: mkv, mp4, webm (default: mkv)
    -o, --output-dir DIR       Output directory (default: ./output)
    -O, --output-file FILE     Specific output filename (single file mode only)
    --no-hwaccel               Disable hardware acceleration
    --force-hwaccel            Force hardware acceleration (fail if unavailable)
    --vulkan                   Prefer Vulkan over VAAPI when available
    --resolution RES           Scale to resolution (e.g., 1280x720, 1920x1080)
    --bitrate RATE             Target bitrate (e.g., 4M, 8M)
    --preset PRESET            FFmpeg preset: ultrafast, fast, medium, slow, veryslow
    --dry-run                  Show command without executing
    --verbose                  Enable verbose output
    --container IMAGE          Use custom container image (default: docker.io/linuxserver/ffmpeg:latest)
    --journal                  Enable journal tracking to skip already converted files
    --journal-file FILE        Custom journal file path (default: ./compress_video_journal.md)
    --force-reconvert          Force reconversion even if file is in journal
    --list-encoders            List available video encoders in the container
    --prefer-software          Prefer software encoding over hardware acceleration
    --parallel N               Process N files in parallel (default: 1)

EXAMPLES:
    # Basic compression with defaults (H.265, medium quality)
    compress_video input.mp4

    # High quality H.264 compression
    compress_video -q high -v h264 input.mp4

    # Custom CRF with specific output
    compress_video -c 20 -O compressed.mkv input.mp4

    # Batch processing with VP9
    compress_video -v vp9 -f webm *.mp4

    # Force software encoding with custom resolution
    compress_video --no-hwaccel --resolution 1280x720 input.mp4

    # Batch processing with journal (resumable)
    compress_video --journal *.mp4

    # Resume interrupted batch processing
    compress_video --journal *.mp4  # Will skip already converted files

    # Use Vulkan hardware acceleration
    compress_video --vulkan input.mp4

    # Force software encoding (if hardware encoders fail)
    compress_video --prefer-software input.mp4
    
    # Process 2 files in parallel
    compress_video --parallel 2 *.mp4
    
    # Parallel processing with journal
    compress_video --parallel 3 --journal *.mp4
    
JOURNAL ANALYSIS EXAMPLES:
    # Enable journal and compress videos
    compress_video --journal --quality high *.mp4
    
    # Get comprehensive statistics summary
    md_table_summarize --comprehensive compress_video_journal.md
    
    # Find all failed operations
    md_table_query --query "SELECT * FROM data WHERE status='FAILED'" compress_video_journal.md
    
    # Calculate average compression ratio by codec
    md_table_query --query "SELECT video_codec, AVG(CAST(REPLACE(compression_ratio, ':1', '') AS FLOAT)) as avg_ratio FROM data WHERE status='SUCCESS' GROUP BY video_codec" compress_video_journal.md
    
    # Find videos with best compression ratios
    md_table_query --query "SELECT input_file, compression_ratio FROM data WHERE status='SUCCESS' ORDER BY CAST(REPLACE(compression_ratio, ':1', '') AS FLOAT) DESC LIMIT 10" compress_video_journal.md
    
    # Calculate total space saved
    md_table_calc "SUM(\$_input_size) - SUM(\$_output_size)" compress_video_journal.md
    
    # Visualize compression performance by codec
    md_table_plot --type bar --columns "video_codec,compression_ratio" --title "Compression Ratios by Codec" compress_video_journal.md
    
    # Create dashboard for monitoring
    md_table_dashboard --title "Video Compression Analytics" compress_video_journal.md
    
    # Export detailed report to Excel
    md_table_export_enhanced --format excel --style professional --sheet-name "Compression Log" compress_video_journal.md

JOURNAL INTEGRATION:
    The --journal flag creates a markdown table (compress_video_journal.md) that tracks:
    - File sizes, compression ratios, processing times
    - Success/failure status with detailed notes  
    - Video codec, audio codec, and quality settings used
    
    Journal columns available for analysis:
    - timestamp, input_file, output_file, input_size, output_size
    - compression_ratio, video_codec, audio_codec, quality, duration
    - status, notes

QUALITY GUIDE:
    Software/VAAPI (CRF mode):
    - low (CRF 28): Smaller files, acceptable quality
    - medium (CRF 23): Balanced size/quality (default)
    - high (CRF 18): Very good quality, larger files
    - veryhigh (CRF 15): Excellent quality, much larger files
    
    Vulkan (Bitrate mode):
    - low: 2 Mbps bitrate
    - medium: 5 Mbps bitrate (default)
    - high: 10 Mbps bitrate
    - veryhigh: 20 Mbps bitrate

VULKAN SUPPORT:
    The script automatically detects your GPU vendor and sets the appropriate
    environment variables for Vulkan video decode:
    - Intel GPUs: ANV_VIDEO_DECODE=1
    - AMD GPUs: RADV_PERFTEST=video_decode
    - NVIDIA GPUs: Requires Vulkan Beta drivers installed on host

EOF
}

# Logging functions
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"
}

error() {
    echo "[ERROR] $*" >&2
}

debug() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo "[DEBUG] $*" >&2
    fi
}

# Journal functions
init_journal() {
    if [[ "$USE_JOURNAL" == "true" ]]; then
        # Set default journal file if not specified
        if [[ -z "$JOURNAL_FILE" ]]; then
            JOURNAL_FILE="./compress_video_journal.md"
        fi
        
        # Create journal file if it doesn't exist
        if [[ ! -f "$JOURNAL_FILE" ]]; then
            create_journal_header "$JOURNAL_FILE"
            debug "Created journal file: $JOURNAL_FILE"
        else
            debug "Using existing journal file: $JOURNAL_FILE"
        fi
    fi
}

# Create markdown table header for journal
create_journal_header() {
    local journal_file="$1"
    cat > "$journal_file" << 'EOF'
# Video Compression Journal

This file tracks video compression operations performed by compress_video script.

| timestamp | input_file | output_file | input_size | output_size | compression_ratio | video_codec | audio_codec | quality | duration | status | notes |
|-----------|------------|-------------|------------|-------------|-------------------|-------------|-------------|---------|----------|--------|-------|
EOF
}

# Check if a file has been converted based on journal
is_converted() {
    local input_file="$1"
    local output_file="$2"
    
    if [[ "$USE_JOURNAL" != "true" ]] || [[ "$FORCE_RECONVERT" == "true" ]]; then
        return 1  # Not converted or force reconvert
    fi
    
    # Check if entry exists in journal by looking for the input and output file combination
    if [[ -f "$JOURNAL_FILE" ]]; then
        # Skip header lines and check for matching input/output files
        if tail -n +4 "$JOURNAL_FILE" | grep -q "| .* | $(basename "$input_file") | $(basename "$output_file") | .* | .* | .* | .* | .* | .* | .* | SUCCESS |"; then
            return 0  # Already converted successfully
        fi
    fi
    
    return 1  # Not converted
}

# Add entry to journal
add_to_journal() {
    local input_file="$1"
    local output_file="$2"
    local status="${3:-SUCCESS}"
    local notes="${4:-}"
    
    if [[ "$USE_JOURNAL" == "true" ]]; then
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        local input_basename=$(basename "$input_file")
        local output_basename=$(basename "$output_file")
        
        # Get file sizes
        local input_size="N/A"
        local output_size="N/A"
        local compression_ratio="N/A"
        
        if [[ -f "$input_file" ]]; then
            input_size=$(stat -c%s "$input_file" 2>/dev/null || echo "N/A")
            if [[ "$input_size" != "N/A" ]]; then
                input_size=$(numfmt --to=iec --suffix=B "$input_size" 2>/dev/null || echo "$input_size bytes")
            fi
        fi
        
        if [[ -f "$output_file" && "$status" == "SUCCESS" ]]; then
            output_size=$(stat -c%s "$output_file" 2>/dev/null || echo "N/A")
            if [[ "$output_size" != "N/A" ]]; then
                output_size=$(numfmt --to=iec --suffix=B "$output_size" 2>/dev/null || echo "$output_size bytes")
                
                # Calculate compression ratio if both sizes are available
                if [[ "$input_size" != "N/A" ]]; then
                    local input_bytes=$(stat -c%s "$input_file" 2>/dev/null)
                    local output_bytes=$(stat -c%s "$output_file" 2>/dev/null)
                    if [[ -n "$input_bytes" && -n "$output_bytes" && "$output_bytes" -gt 0 ]]; then
                        compression_ratio=$(echo "scale=2; $input_bytes / $output_bytes" | bc 2>/dev/null || echo "N/A")
                        if [[ "$compression_ratio" != "N/A" ]]; then
                            compression_ratio="${compression_ratio}:1"
                        fi
                    fi
                fi
            fi
        fi
        
        # Get video duration if available (requires ffprobe, but we'll make it optional)
        local duration="N/A"
        if [[ -f "$input_file" ]] && command -v ffprobe >/dev/null 2>&1; then
            duration=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$input_file" 2>/dev/null | cut -d. -f1)
            if [[ -n "$duration" && "$duration" != "N/A" ]]; then
                # Convert seconds to HH:MM:SS
                duration=$(printf "%02d:%02d:%02d" $((duration/3600)) $(((duration%3600)/60)) $((duration%60)))
            else
                duration="N/A"
            fi
        fi
        
        # Determine quality string
        local quality_str="$QUALITY"
        if [[ -n "$CUSTOM_CRF" ]]; then
            quality_str="crf:$CUSTOM_CRF"
        fi
        
        # Create markdown table row
        local row="| $timestamp | $input_basename | $output_basename | $input_size | $output_size | $compression_ratio | $VIDEO_CODEC | $AUDIO_CODEC | $quality_str | $duration | $status | $notes |"
        
        # Add to journal file
        echo "$row" >> "$JOURNAL_FILE"
        debug "Added to journal: $input_basename -> $output_basename ($status)"
    fi
}

# Check if hardware acceleration is available
check_hwaccel() {
    if [[ -c "$HWACCEL_DEVICE" ]]; then
        debug "Hardware acceleration device found: $HWACCEL_DEVICE"
        return 0
    else
        debug "Hardware acceleration device not found: $HWACCEL_DEVICE"
        return 1
    fi
}

# Check if Vulkan is available and detect GPU vendor
check_vulkan() {
    # Check if DRI device exists (required for Vulkan)
    if [[ ! -d "/dev/dri" ]]; then
        debug "No DRI devices found, Vulkan not available"
        return 1
    fi
    
    # Detect GPU vendor
    local gpu_vendor=""
    if command -v lspci >/dev/null 2>&1; then
        local gpu_info=$(lspci 2>/dev/null | grep -E "VGA|3D|Display" | head -1)
        if [[ "$gpu_info" =~ Intel ]]; then
            gpu_vendor="intel"
            debug "Intel GPU detected for Vulkan"
        elif [[ "$gpu_info" =~ AMD|ATI|Radeon ]]; then
            gpu_vendor="amd"
            debug "AMD GPU detected for Vulkan"
        elif [[ "$gpu_info" =~ NVIDIA|GeForce ]]; then
            gpu_vendor="nvidia"
            debug "NVIDIA GPU detected for Vulkan"
        fi
    fi
    
    # If lspci is not available, try checking render nodes
    if [[ -z "$gpu_vendor" ]] && [[ -e "/sys/class/drm/renderD128/device/vendor" ]]; then
        local vendor_id=$(cat /sys/class/drm/renderD128/device/vendor 2>/dev/null)
        case "$vendor_id" in
            "0x8086") gpu_vendor="intel" ;;
            "0x1002") gpu_vendor="amd" ;;
            "0x10de") gpu_vendor="nvidia" ;;
        esac
        debug "GPU vendor detected via sysfs: $gpu_vendor"
    fi
    
    if [[ -n "$gpu_vendor" ]]; then
        echo "$gpu_vendor"
        return 0
    else
        debug "Could not detect GPU vendor, but Vulkan may still work"
        echo "unknown"
        return 0
    fi
}

# List available encoders
list_encoders() {
    log "Listing available video encoders in container..."
    
    local podman_cmd=(
        "podman" "run" "--rm" "-it"
        "--security-opt" "label=disable"
        "$CONTAINER_IMAGE"
        "-encoders"
    )
    
    # Run the command and filter for video encoders
    "${podman_cmd[@]}" 2>/dev/null | grep -E "^ V.*" | sort
    
    exit 0
}

# Parse command line arguments
parse_args() {
    local args=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -q|--quality)
                QUALITY="$2"
                if [[ ! "${QUALITY_PRESETS[$QUALITY]+isset}" ]]; then
                    error "Invalid quality preset: $QUALITY"
                    exit 1
                fi
                shift 2
                ;;
            -c|--crf)
                CUSTOM_CRF="$2"
                shift 2
                ;;
            -v|--video-codec)
                VIDEO_CODEC="$2"
                if [[ ! "${VIDEO_CODEC_MAP[$VIDEO_CODEC]+isset}" ]]; then
                    error "Invalid video codec: $VIDEO_CODEC"
                    exit 1
                fi
                shift 2
                ;;
            -a|--audio-codec)
                AUDIO_CODEC="$2"
                if [[ ! "${AUDIO_CODEC_MAP[$AUDIO_CODEC]+isset}" ]]; then
                    error "Invalid audio codec: $AUDIO_CODEC"
                    exit 1
                fi
                shift 2
                ;;
            -f|--format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            -o|--output-dir)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -O|--output-file)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            --no-hwaccel)
                USE_HWACCEL="no"
                shift
                ;;
            --force-hwaccel)
                USE_HWACCEL="force"
                shift
                ;;
            --vulkan)
                PREFER_VULKAN=true
                shift
                ;;
            --resolution)
                RESOLUTION="$2"
                shift 2
                ;;
            --bitrate)
                BITRATE="$2"
                shift 2
                ;;
            --preset)
                FFMPEG_PRESET="$2"
                shift 2
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --container)
                CONTAINER_IMAGE="$2"
                shift 2
                ;;
            --journal)
                USE_JOURNAL=true
                shift
                ;;
            --journal-file)
                USE_JOURNAL=true
                JOURNAL_FILE="$2"
                shift 2
                ;;
            --force-reconvert)
                FORCE_RECONVERT=true
                shift
                ;;
            --list-encoders)
                list_encoders
                ;;
            --prefer-software)
                PREFER_SOFTWARE=true
                shift
                ;;
            --parallel)
                PARALLEL_JOBS="$2"
                if ! [[ "$PARALLEL_JOBS" =~ ^[1-9][0-9]*$ ]]; then
                    error "Invalid parallel jobs count: $PARALLEL_JOBS (must be a positive integer)"
                    exit 1
                fi
                shift 2
                ;;
            --parallel-child)
                # Internal flag to indicate this is a child process from moreutils parallel
                PARALLEL_CHILD=true
                shift
                ;;
            -*)
                error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    
    # Store remaining arguments as input files
    INPUT_FILES=("${args[@]}")
    
    # Validate input files
    if [[ ${#INPUT_FILES[@]} -eq 0 ]]; then
        error "No input files specified"
        show_help
        exit 1
    fi
    
    # Check for conflicting options
    if [[ -n "${OUTPUT_FILE:-}" ]] && [[ ${#INPUT_FILES[@]} -gt 1 ]]; then
        error "Cannot use --output-file with multiple input files"
        exit 1
    fi
}

# Build FFmpeg command arguments
build_ffmpeg_args() {
    local input_file="$1"
    local output_file="$2"
    local input_dir="$3"
    local output_dir="$4"
    local args=()
    
    # Determine CRF value
    local crf="${CUSTOM_CRF:-${QUALITY_PRESETS[$QUALITY]}}"
    
    # Determine hardware acceleration type
    local hw_type="none"
    local use_hw=false
    local gpu_vendor=""
    
    if [[ "$USE_HWACCEL" != "no" ]] && [[ "$PREFER_SOFTWARE" != "true" ]]; then
        # Check for Vulkan first if preferred
        if [[ "$PREFER_VULKAN" == "true" ]]; then
            gpu_vendor=$(check_vulkan)
            if [[ $? -eq 0 ]]; then
                hw_type="vulkan"
                use_hw=true
                debug "Using Vulkan with GPU vendor: $gpu_vendor"
            fi
        fi
        
        # Fall back to VAAPI if Vulkan not available or not preferred
        if [[ "$use_hw" == "false" ]] && check_hwaccel; then
            hw_type="vaapi"
            use_hw=true
        fi
        
        # Handle force mode
        if [[ "$USE_HWACCEL" == "force" ]] && [[ "$use_hw" == "false" ]]; then
            error "Hardware acceleration forced but no device available"
            exit 1
        fi
    else
        debug "Using software encoding (hardware acceleration disabled or software preferred)"
    fi
    
    # Build FFmpeg arguments based on acceleration type
    if [[ "$hw_type" == "vulkan" ]]; then
        args+=("-init_hw_device" "vulkan=vk:0")
        args+=("-hwaccel" "vulkan")
        args+=("-hwaccel_output_format" "vulkan")
    elif [[ "$hw_type" == "vaapi" ]]; then
        args+=("-vaapi_device" "/dev/dri/renderD128")
    fi
    
    # Determine input path in container
    local input_basename
    input_basename="$(basename "$input_file")"
    if [[ "$input_dir" == "$output_dir" ]]; then
        args+=("-i" "/config/${input_basename}")
    else
        args+=("-i" "/input/${input_basename}")
    fi
    
    # Video codec settings
    if [[ "$hw_type" == "vulkan" ]]; then
        # Vulkan uses h264_vulkan or hevc_vulkan encoders
        if [[ "$VIDEO_CODEC" == "h264" ]]; then
            args+=("-c:v" "h264_vulkan")
        elif [[ "$VIDEO_CODEC" == "h265" ]]; then
            args+=("-c:v" "hevc_vulkan")
        else
            # For other codecs, fall back to software (Vulkan only supports h264/h265)
            args+=("-c:v" "${VIDEO_CODEC_MAP[$VIDEO_CODEC]}")
            debug "Warning: Vulkan only supports h264/h265, falling back to software for $VIDEO_CODEC"
        fi
        
        # Vulkan needs format conversion and proper filter chain
        if [[ -n "${RESOLUTION:-}" ]]; then
            args+=("-vf" "format=nv12,hwupload,scale_vulkan=${RESOLUTION}")
        else
            # Even without scaling, Vulkan needs format conversion
            args+=("-vf" "format=nv12,hwupload")
        fi
    elif [[ "$hw_type" == "vaapi" ]] && [[ "$VIDEO_CODEC" == "h264" || "$VIDEO_CODEC" == "h265" ]]; then
        # VAAPI uses h264_vaapi but hevc_vaapi (not h265_vaapi)
        if [[ "$VIDEO_CODEC" == "h265" ]]; then
            args+=("-c:v" "hevc_vaapi")
        else
            args+=("-c:v" "${VIDEO_CODEC}_vaapi")
        fi
        
        # Hardware scaling if resolution is specified
        if [[ -n "${RESOLUTION:-}" ]]; then
            local width="${RESOLUTION%x*}"
            local height="${RESOLUTION#*x}"
            args+=("-vf" "format=nv12|vaapi,hwupload,scale_vaapi=w=${width}:h=${height}")
        else
            args+=("-vf" "format=nv12|vaapi,hwupload")
        fi
    else
        args+=("-c:v" "${VIDEO_CODEC_MAP[$VIDEO_CODEC]}")
        
        # Software scaling if resolution is specified
        if [[ -n "${RESOLUTION:-}" ]]; then
            args+=("-vf" "scale=${RESOLUTION}")
        fi
    fi
    
    # Quality settings
    if [[ -n "${BITRATE:-}" ]]; then
        # User specified bitrate
        args+=("-b:v" "$BITRATE")
    elif [[ "$hw_type" == "vulkan" ]]; then
        # Vulkan doesn't support CRF, use bitrate based on quality preset
        local vulkan_bitrate="${QUALITY_BITRATES[$QUALITY]}"
        args+=("-b:v" "$vulkan_bitrate")
        debug "Using bitrate $vulkan_bitrate for Vulkan (quality: $QUALITY)"
    else
        # Use CRF for software and VAAPI encoding
        args+=("-crf" "$crf")
    fi
    
    # FFmpeg preset if specified
    if [[ -n "${FFMPEG_PRESET:-}" ]]; then
        args+=("-preset" "$FFMPEG_PRESET")
    fi
    
    # Audio codec settings
    if [[ "$AUDIO_CODEC" == "copy" ]]; then
        args+=("-c:a" "copy")
    else
        args+=("-c:a" "${AUDIO_CODEC_MAP[$AUDIO_CODEC]}")
        
        # Audio quality settings
        if [[ "$AUDIO_CODEC" == "vorbis" ]]; then
            args+=("-q:a" "4")
        elif [[ "$AUDIO_CODEC" == "opus" ]]; then
            args+=("-b:a" "128k")
        fi
    fi
    
    # Determine output path in container
    local output_basename
    output_basename="$(basename "$output_file")"
    if [[ "$input_dir" == "$output_dir" ]]; then
        args+=("/config/${output_basename}")
    else
        args+=("/output/${output_basename}")
    fi
    
    # Output each argument on a separate line
    printf '%s\n' "${args[@]}"
    
    # Output GPU vendor info on a special line if using Vulkan
    if [[ "$hw_type" == "vulkan" ]] && [[ -n "$gpu_vendor" ]]; then
        printf '__GPU_VENDOR__%s\n' "$gpu_vendor"
    fi
}

# Process a single video file
process_video() {
    local input_file="$1"
    local output_file="$2"
    
    # Check journal to see if already converted
    if is_converted "$input_file" "$output_file"; then
        log "Skipping (already converted): $input_file"
        return 0
    fi
    
    log "Processing: $input_file -> $output_file"
    
    # Get absolute paths
    local input_dir="$(dirname "$(realpath "$input_file")")"
    
    # Create output directory if needed
    local output_parent="$(dirname "$output_file")"
    if [[ ! -d "$output_parent" ]]; then
        mkdir -p "$output_parent"
    fi
    
    local output_dir="$(realpath "$output_parent")"
    
    # Build FFmpeg arguments as array and extract GPU vendor
    local ffmpeg_args=()
    local gpu_vendor=""
    while IFS= read -r arg; do
        if [[ "$arg" =~ ^__GPU_VENDOR__(.*)$ ]]; then
            gpu_vendor="${BASH_REMATCH[1]}"
        else
            ffmpeg_args+=("$arg")
        fi
    done < <(build_ffmpeg_args "$input_file" "$output_file" "$input_dir" "$output_dir")
    
    # Build podman command
    local podman_cmd=(
        "podman" "run" "--rm" "-it"
        "--security-opt" "label=disable"
    )
    
    # Add hardware acceleration device if needed
    if [[ "$USE_HWACCEL" != "no" ]]; then
        # For Vulkan, we need the entire /dev/dri directory
        if [[ "$PREFER_VULKAN" == "true" ]] && [[ -n "$gpu_vendor" ]]; then
            podman_cmd+=("--device=/dev/dri:/dev/dri")
            
            # Add vendor-specific Vulkan environment variable
            case "$gpu_vendor" in
                "intel")
                    podman_cmd+=("-e" "ANV_VIDEO_DECODE=1")
                    debug "Setting Intel Vulkan env: ANV_VIDEO_DECODE=1"
                    ;;
                "amd")
                    podman_cmd+=("-e" "RADV_PERFTEST=video_decode")
                    debug "Setting AMD Vulkan env: RADV_PERFTEST=video_decode"
                    ;;
                "nvidia")
                    # Nvidia requires beta drivers on host
                    debug "NVIDIA GPU detected - ensure Vulkan Beta drivers are installed"
                    ;;
                *)
                    # Try Intel env var as default
                    podman_cmd+=("-e" "ANV_VIDEO_DECODE=1")
                    debug "Unknown GPU vendor, trying Intel Vulkan env"
                    ;;
            esac
        elif check_hwaccel; then
            podman_cmd+=("--device=$HWACCEL_DEVICE:$HWACCEL_DEVICE")
        fi
    fi
    
    # Add volume mounts
    # If input and output directories are the same, mount once
    if [[ "$input_dir" == "$output_dir" ]]; then
        podman_cmd+=("-v" "${input_dir}:/config:z")
    else
        # Mount both directories - we'll need to adjust paths
        podman_cmd+=(
            "-v" "${input_dir}:/input:z"
            "-v" "${output_dir}:/output:z"
        )
    fi
    
    # Add container image and ffmpeg command
    podman_cmd+=(
        "$CONTAINER_IMAGE"
        "${ffmpeg_args[@]}"
    )
    
    # Show command if verbose or dry run
    if [[ "$VERBOSE" == "true" ]] || [[ "$DRY_RUN" == "true" ]]; then
        debug "Command: ${podman_cmd[*]}"
    fi
    
    # Execute command
    if [[ "$DRY_RUN" == "false" ]]; then
        # Record start time for duration calculation
        local start_time=$(date +%s)
        
        if "${podman_cmd[@]}"; then
            local end_time=$(date +%s)
            local process_duration=$((end_time - start_time))
            local duration_str=$(printf "%02d:%02d:%02d" $((process_duration/3600)) $(((process_duration%3600)/60)) $((process_duration%60)))
            
            log "Successfully compressed: $output_file (took $duration_str)"
            # Add to journal on success
            add_to_journal "$input_file" "$output_file" "SUCCESS" "Processed in $duration_str"
        else
            error "Failed to compress: $input_file"
            # Add failure to journal
            add_to_journal "$input_file" "$output_file" "FAILED" "Compression failed"
            return 1
        fi
    else
        log "[DRY RUN] Would execute: ${podman_cmd[*]}"
        # Add dry run entry to journal
        add_to_journal "$input_file" "$output_file" "DRY_RUN" "Command would be: ${podman_cmd[*]:0:50}..."
    fi
}

# Check if parallel is available for concurrent processing
check_parallel() {
    if ! command -v parallel >/dev/null 2>&1; then
        error "parallel is required for --parallel option but not found"
        error "Install with: sudo apt install parallel (or equivalent for your distro)"
        exit 1
    fi
    
    # Detect which version of parallel we have
    if parallel --version 2>&1 | grep -q "GNU parallel"; then
        PARALLEL_TYPE="gnu"
        debug "GNU parallel detected"
    else
        PARALLEL_TYPE="moreutils"
        debug "moreutils parallel detected"
    fi
}

# Export function for parallel to use
export -f process_video log error debug is_converted add_to_journal check_hwaccel check_vulkan build_ffmpeg_args

# Wrapper function that parallel can call
process_video_wrapper() {
    local input_file="$1"
    local output_file="$2"
    
    # Reconstruct associative arrays from environment variables
    declare -A QUALITY_PRESETS=(["low"]="28" ["medium"]="23" ["high"]="18" ["veryhigh"]="15")
    declare -A QUALITY_BITRATES=(["low"]="2M" ["medium"]="5M" ["high"]="10M" ["veryhigh"]="20M")
    declare -A VIDEO_CODEC_MAP=(["h264"]="libx264" ["h265"]="libx265" ["vp9"]="libvpx-vp9" ["av1"]="libaom-av1")
    declare -A AUDIO_CODEC_MAP=(["vorbis"]="libvorbis" ["opus"]="libopus" ["aac"]="aac" ["mp3"]="libmp3lame" ["copy"]="copy")
    
    # Call the main processing function
    process_video "$input_file" "$output_file"
}

# Main function
main() {
    parse_args "$@"
    
    # Initialize journal if enabled
    init_journal
    
    # Create output directory if it doesn't exist
    if [[ -z "${OUTPUT_FILE:-}" ]] && [[ "$DRY_RUN" == "false" ]]; then
        mkdir -p "$OUTPUT_DIR"
    fi
    
    # Check for parallel dependency if needed
    if [[ "$PARALLEL_JOBS" -gt 1 ]]; then
        check_parallel
    fi
    
    # Prepare job list for processing
    local job_list=()
    local failed=0
    local skipped=0
    
    for input_file in "${INPUT_FILES[@]}"; do
        # Check if input file exists
        if [[ ! -f "$input_file" ]]; then
            error "Input file not found: $input_file"
            ((failed++))
            continue
        fi
        
        # Determine output filename
        local output_file
        if [[ -n "${OUTPUT_FILE:-}" ]]; then
            output_file="$OUTPUT_FILE"
        else
            local basename="$(basename "$input_file")"
            local name="${basename%.*}"
            output_file="${OUTPUT_DIR}/${name}.${OUTPUT_FORMAT}"
        fi
        
        # Check if already converted (for counting)
        if is_converted "$input_file" "$output_file"; then
            ((skipped++))
        else
            # Add to job list for processing
            job_list+=("$input_file|$output_file")
        fi
    done
    
    # Process videos
    if [[ ${#job_list[@]} -gt 0 ]]; then
        if [[ "$PARALLEL_JOBS" -gt 1 ]] && [[ "$PARALLEL_CHILD" == "false" ]]; then
            # Use parallel processing
            log "Processing ${#job_list[@]} files with $PARALLEL_JOBS parallel jobs..."
            
            # Export the wrapper function and variables for parallel
            export -f process_video_wrapper
            export QUALITY CUSTOM_CRF VIDEO_CODEC AUDIO_CODEC OUTPUT_FORMAT USE_HWACCEL PREFER_VULKAN
            export PREFER_SOFTWARE CONTAINER_IMAGE HWACCEL_DEVICE VERBOSE DRY_RUN USE_JOURNAL 
            export JOURNAL_FILE FORCE_RECONVERT RESOLUTION BITRATE FFMPEG_PRESET PARALLEL_TYPE
            
            # Process jobs in parallel
            local parallel_failed=0
            
            if [[ "$PARALLEL_TYPE" == "gnu" ]]; then
                # GNU parallel syntax
                printf '%s\n' "${job_list[@]}" | parallel -j "$PARALLEL_JOBS" --colsep '|' \
                    'if ! process_video_wrapper "{1}" "{2}"; then exit 1; fi' || parallel_failed=$?
            else
                # moreutils parallel syntax is simpler but less flexible
                # We need to create a wrapper that can be called with our job format
                
                # Build the command with all our current options
                local cmd_args=()
                [[ -n "$CUSTOM_CRF" ]] && cmd_args+=("--crf" "$CUSTOM_CRF")
                [[ "$QUALITY" != "medium" ]] && cmd_args+=("--quality" "$QUALITY")
                [[ "$VIDEO_CODEC" != "h265" ]] && cmd_args+=("--video-codec" "$VIDEO_CODEC")
                [[ "$AUDIO_CODEC" != "vorbis" ]] && cmd_args+=("--audio-codec" "$AUDIO_CODEC")
                [[ "$OUTPUT_FORMAT" != "mkv" ]] && cmd_args+=("--format" "$OUTPUT_FORMAT")
                [[ "$OUTPUT_DIR" != "output" ]] && cmd_args+=("--output-dir" "$OUTPUT_DIR")
                [[ "$USE_HWACCEL" == "no" ]] && cmd_args+=("--no-hwaccel")
                [[ "$USE_HWACCEL" == "force" ]] && cmd_args+=("--force-hwaccel")
                [[ "$PREFER_VULKAN" == "true" ]] && cmd_args+=("--vulkan")
                [[ "$PREFER_SOFTWARE" == "true" ]] && cmd_args+=("--prefer-software")
                [[ -n "${RESOLUTION:-}" ]] && cmd_args+=("--resolution" "$RESOLUTION")
                [[ -n "${BITRATE:-}" ]] && cmd_args+=("--bitrate" "$BITRATE")
                [[ -n "${FFMPEG_PRESET:-}" ]] && cmd_args+=("--preset" "$FFMPEG_PRESET")
                [[ "$VERBOSE" == "true" ]] && cmd_args+=("--verbose")
                [[ "$DRY_RUN" == "true" ]] && cmd_args+=("--dry-run")
                [[ "$USE_JOURNAL" == "true" ]] && cmd_args+=("--journal")
                [[ -n "$JOURNAL_FILE" ]] && [[ "$JOURNAL_FILE" != "./compress_video_journal.md" ]] && cmd_args+=("--journal-file" "$JOURNAL_FILE")
                [[ "$FORCE_RECONVERT" == "true" ]] && cmd_args+=("--force-reconvert")
                
                # Process files one by one in parallel using moreutils syntax
                # Extract just the input files from job_list
                local input_files=()
                for job in "${job_list[@]}"; do
                    IFS='|' read -r input_file output_file <<< "$job"
                    input_files+=("$input_file")
                done
                
                # Use moreutils parallel with simple syntax: parallel -j N command args -- file1 file2 ...
                debug "Executing moreutils parallel with ${#input_files[@]} files"
                debug "Command: parallel -j $PARALLEL_JOBS $0 --parallel-child ${cmd_args[*]} -- ${input_files[*]}"
                
                # moreutils parallel expects files after -- separator
                parallel -j "$PARALLEL_JOBS" "$0" --parallel-child "${cmd_args[@]}" -- "${input_files[@]}" || parallel_failed=$?
            fi
                
            # Count failures (parallel doesn't give us exact count, so we estimate)
            if [[ $parallel_failed -ne 0 ]]; then
                error "Some parallel jobs failed"
                failed=$parallel_failed
            fi
        else
            # Sequential processing
            for job in "${job_list[@]}"; do
                IFS='|' read -r input_file output_file <<< "$job"
                if ! process_video "$input_file" "$output_file"; then
                    ((failed++))
                fi
            done
        fi
    fi
    
    # Summary
    if [[ ${#INPUT_FILES[@]} -gt 1 ]]; then
        local processed=$((${#INPUT_FILES[@]} - failed - skipped))
        log "Summary: Processed $processed, Skipped $skipped, Failed $failed (Total: ${#INPUT_FILES[@]})"
        if [[ "$USE_JOURNAL" == "true" ]]; then
            log "Journal file: $JOURNAL_FILE"
        fi
    fi
    
    # Exit with error if any files failed
    if [[ $failed -gt 0 ]]; then
        exit 1
    fi
}

# Run main function
main "$@"