#!/usr/bin/python3
"""
md_table_pivot - Create pivot tables from markdown tables

Usage:
  md_table_pivot --rows category --cols month --values sales
  md_table_pivot --rows dept --values salary --agg mean
  cat data.md | md_table_pivot --rows region --cols quarter --values revenue --agg sum
  
Pivot table functionality:
  --rows COLUMN(S)       Column(s) to use as row index (comma-separated for multiple)
  --cols COLUMN(S)       Column(s) to use as column headers (comma-separated for multiple) 
  --values COLUMN        Column containing values to aggregate
  --agg FUNCTION         Aggregation function: sum, mean, count, min, max, std, var (default: sum)
  --fill VALUE           Fill missing values with this value (default: 0 for numeric, '' for text)
  --margins              Include row/column totals
  --sort-rows            Sort row labels alphabetically
  --sort-cols            Sort column labels alphabetically
  
Options:
  --input FILE           Input markdown file (default: stdin)
  --output FILE          Output markdown file (default: stdout)
  --format wide|long     Output format: wide (pivot) or long (melted) table
  --transpose            Transpose final result (swap rows/columns)

Examples:
  # Basic pivot: sales by category and month
  md_table_pivot --rows category --cols month --values sales
  
  # Average salary by department  
  md_table_pivot --rows department --values salary --agg mean
  
  # Multi-level pivot with totals
  md_table_pivot --rows region,category --cols quarter --values revenue --margins
  
  # Count occurrences (no values column needed)
  md_table_pivot --rows status --cols priority --agg count
  
  # Custom fill value and sorting
  md_table_pivot --rows product --cols store --values units --fill 0 --sort-rows --sort-cols
"""

from os import environ
from subprocess import run
from sys import argv, exit

ctr_id: str|None = ""
if ("CONTAINER_ID" in environ):
    ctr_id = environ.get("CONTAINER_ID")

# Check if distrobox check should be skipped
no_dbox_check = environ.get("NO_DBOX_CHECK", "").lower() in ("1", "true")

# if we are not in the 'dev' distrobox re-exec the script  
# inside of the 'dev' distrobox
if not no_dbox_check and ("dev" != ctr_id):
    cmd: list[str] = [
        "distrobox",
        "enter",
        "dev",
        "--",
        *argv
    ]
    run(cmd)
    exit(0)

import argparse
import re
import sys
from pathlib import Path
from typing import List, Dict, Any, Optional, Union

# Try to import pandas with helpful error message
try:
    import pandas as pd
    import numpy as np
except ImportError:
    print("Error: Required dependencies not installed.", file=sys.stderr)
    print("Install with: pip install pandas numpy", file=sys.stderr)
    print("Or in distrobox: distrobox enter dev -- pip install pandas numpy", file=sys.stderr)
    sys.exit(1)

def parse_markdown_table(content: str) -> Optional[pd.DataFrame]:
    """Parse markdown table content into pandas DataFrame"""
    lines = [line.strip() for line in content.split('\n') if line.strip()]
    
    if not lines:
        return None
    
    # Find table lines (start with |)
    table_lines = [line for line in lines if line.startswith('|') and line.endswith('|')]
    
    if len(table_lines) < 2:
        return None
    
    # Parse header row
    header_line = table_lines[0]
    headers = [cell.strip() for cell in header_line.split('|')[1:-1]]  # Remove first/last empty
    
    # Find separator row (contains dashes)
    separator_idx = None
    for i, line in enumerate(table_lines[1:], 1):
        if re.match(r'^\|[\s\-\|]+\|$', line):
            separator_idx = i
            break
    
    if separator_idx is None:
        # No separator found, treat first row as data
        data_lines = table_lines
        headers = [f"Column{i+1}" for i in range(len(headers))]
        data_start = 0
    else:
        # Skip separator row
        data_lines = table_lines[separator_idx + 1:]
        data_start = separator_idx + 1
    
    if not data_lines:
        # Only headers, create empty DataFrame
        return pd.DataFrame(columns=headers)
    
    # Parse data rows
    data = []
    for line in data_lines:
        cells = [cell.strip() for cell in line.split('|')[1:-1]]  # Remove first/last empty
        
        # Pad or trim cells to match header count
        while len(cells) < len(headers):
            cells.append('')
        cells = cells[:len(headers)]
        
        # Unescape pipes in cell content
        cells = [cell.replace('\\|', '|') for cell in cells]
        
        data.append(cells)
    
    # Create DataFrame
    df = pd.DataFrame(data, columns=headers)
    
    # Try to convert numeric columns
    for col in df.columns:
        # Try to convert to numeric, but keep as string if it fails  
        numeric_series = pd.to_numeric(df[col], errors='coerce')
        # If more than 50% of values are numeric, convert the column
        if numeric_series.notna().sum() / len(df) > 0.5:
            df[col] = numeric_series
    
    return df

def dataframe_to_markdown(df: pd.DataFrame, include_header: bool = True) -> str:
    """Convert pandas DataFrame to markdown table"""
    if df.empty:
        return "| (empty table) |\n|----------------|\n"
    
    lines = []
    
    # Handle multi-level index/columns by flattening them
    if isinstance(df.index, pd.MultiIndex):
        # Flatten multi-level index
        df_copy = df.copy()
        df_copy.index = [' / '.join(map(str, idx)) if isinstance(idx, tuple) else str(idx) for idx in df.index]
        df = df_copy
    
    if isinstance(df.columns, pd.MultiIndex):
        # Flatten multi-level columns
        df_copy = df.copy()
        df_copy.columns = [' / '.join(map(str, col)) if isinstance(col, tuple) else str(col) for col in df.columns]
        df = df_copy
    
    # Reset index to include it as a regular column
    df_with_index = df.reset_index()
    
    # Add header row if requested
    if include_header:
        headers = [str(col) for col in df_with_index.columns]
        lines.append("| " + " | ".join(headers) + " |")
        lines.append("|" + "|".join(["-" * (len(h) + 2) for h in headers]) + "|")
    
    # Add data rows
    for _, row in df_with_index.iterrows():
        row_data = []
        for val in row:
            # Handle different data types
            if pd.isna(val):
                row_data.append("")
            elif isinstance(val, (int, float)):
                if pd.isna(val):
                    row_data.append("")
                elif isinstance(val, float) and val.is_integer():
                    row_data.append(str(int(val)))
                else:
                    row_data.append(str(val))
            else:
                # Escape pipes in cell content
                cell_content = str(val).replace("|", "\\|")
                row_data.append(cell_content)
        
        lines.append("| " + " | ".join(row_data) + " |")
    
    return "\n".join(lines) + "\n"

def validate_columns(df: pd.DataFrame, row_cols: List[str], col_cols: List[str], value_col: str = None) -> None:
    """Validate that specified columns exist in the DataFrame"""
    all_cols = set(row_cols + col_cols)
    if value_col:
        all_cols.add(value_col)
    
    missing_cols = all_cols - set(df.columns)
    if missing_cols:
        available = ', '.join(df.columns)
        raise ValueError(f"Columns not found: {', '.join(missing_cols)}. Available columns: {available}")

def create_pivot_table(df: pd.DataFrame, row_cols: List[str], col_cols: List[str] = None, 
                      value_col: str = None, agg_func: str = 'sum', fill_value: Any = None, 
                      margins: bool = False, sort_rows: bool = False, sort_cols: bool = False) -> pd.DataFrame:
    """Create pivot table from DataFrame"""
    
    # Validate columns
    validate_columns(df, row_cols, col_cols or [], value_col)
    
    # Handle case where no value column is specified (use count)
    if value_col is None or agg_func == 'count':
        # Create a dummy column for counting
        df = df.copy()
        df['__count__'] = 1
        value_col = '__count__'
        if agg_func != 'count':
            agg_func = 'count'
    
    # Convert aggregation function name to pandas function
    agg_funcs = {
        'sum': 'sum',
        'mean': 'mean', 
        'average': 'mean',
        'avg': 'mean',
        'count': 'count',
        'size': 'size',
        'min': 'min',
        'max': 'max',
        'std': 'std',
        'var': 'var',
        'median': 'median',
        'first': 'first',
        'last': 'last'
    }
    
    if agg_func not in agg_funcs:
        raise ValueError(f"Unsupported aggregation function: {agg_func}. Supported: {', '.join(agg_funcs.keys())}")
    
    pandas_agg_func = agg_funcs[agg_func]
    
    # Determine default fill value based on aggregation function
    if fill_value is None:
        if agg_func in ['count', 'size']:
            fill_value = 0
        elif agg_func in ['sum', 'mean', 'min', 'max', 'std', 'var', 'median']:
            # Check if value column is numeric
            if pd.api.types.is_numeric_dtype(df[value_col]):
                fill_value = 0
            else:
                fill_value = ''
        else:
            fill_value = ''
    
    try:
        # Create pivot table
        if col_cols:
            pivot = pd.pivot_table(
                df, 
                values=value_col, 
                index=row_cols, 
                columns=col_cols,
                aggfunc=pandas_agg_func,
                fill_value=fill_value,
                margins=margins
            )
        else:
            # No column grouping, just aggregate by row columns
            if len(row_cols) == 1:
                pivot = df.groupby(row_cols[0])[value_col].agg(pandas_agg_func).to_frame()
                pivot.columns = [f'{agg_func}({value_col})']
            else:
                pivot = df.groupby(row_cols)[value_col].agg(pandas_agg_func).to_frame()
                pivot.columns = [f'{agg_func}({value_col})']
        
        # Sort if requested
        if sort_rows:
            pivot = pivot.sort_index()
        
        if sort_cols and col_cols:
            pivot = pivot.sort_index(axis=1)
        
        return pivot
        
    except Exception as e:
        raise ValueError(f"Error creating pivot table: {e}")

def melt_pivot_table(pivot_df: pd.DataFrame) -> pd.DataFrame:
    """Convert wide pivot table to long format"""
    # Reset index to make row labels into columns
    melted = pivot_df.reset_index()
    
    # Get the index column names (these were the original grouping columns)
    index_cols = [col for col in melted.columns if col not in pivot_df.columns]
    
    # Melt the DataFrame
    melted = pd.melt(
        melted,
        id_vars=index_cols,
        var_name='Column',
        value_name='Value'
    )
    
    return melted

def main():
    parser = argparse.ArgumentParser(
        description='Create pivot tables from markdown tables',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic pivot table
  md_table_pivot --rows category --cols month --values sales
  
  # Average values instead of sum
  md_table_pivot --rows department --values salary --agg mean
  
  # Count occurrences (no values column needed)
  md_table_pivot --rows status --cols priority --agg count
  
  # Multi-level grouping with margins
  md_table_pivot --rows region,product --cols quarter --values revenue --margins
  
  # Custom fill and sorting
  md_table_pivot --rows item --cols store --values quantity --fill 0 --sort-rows --sort-cols
  
  # Output in long format
  md_table_pivot --rows category --cols month --values sales --format long
        """
    )
    
    # Input/output options
    parser.add_argument('--input', '-i', help='Input markdown file (default: stdin)')
    parser.add_argument('--output', '-o', help='Output markdown file (default: stdout)')
    parser.add_argument('--format', choices=['wide', 'long'], default='wide',
                       help='Output format: wide (pivot table) or long (melted) format')
    
    # Pivot configuration (required)
    parser.add_argument('--rows', '-r', required=True,
                       help='Column(s) for row index (comma-separated for multiple)')
    parser.add_argument('--cols', '-c', 
                       help='Column(s) for column headers (comma-separated for multiple)')
    parser.add_argument('--values', '-v',
                       help='Column containing values to aggregate (required unless using count)')
    
    # Aggregation options
    parser.add_argument('--agg', '-a', default='sum',
                       choices=['sum', 'mean', 'average', 'avg', 'count', 'size', 'min', 'max', 'std', 'var', 'median', 'first', 'last'],
                       help='Aggregation function (default: sum)')
    parser.add_argument('--fill', help='Fill value for missing data (default: 0 for numeric, empty for text)')
    
    # Display options
    parser.add_argument('--margins', action='store_true', help='Include row and column totals')
    parser.add_argument('--sort-rows', action='store_true', help='Sort row labels alphabetically')
    parser.add_argument('--sort-cols', action='store_true', help='Sort column labels alphabetically')
    parser.add_argument('--transpose', action='store_true', help='Transpose the result (swap rows and columns)')
    
    args = parser.parse_args()
    
    # Validate arguments
    if args.agg != 'count' and not args.values:
        parser.error("--values is required unless using --agg count")
    
    try:
        # Read input
        if args.input:
            with open(args.input, 'r', encoding='utf-8') as f:
                content = f.read()
        else:
            content = sys.stdin.read()
        
        if not content.strip():
            print("Error: No input data provided", file=sys.stderr)
            sys.exit(1)
        
        # Parse markdown table
        df = parse_markdown_table(content)
        
        if df is None or df.empty:
            print("Error: No valid markdown table found in input", file=sys.stderr)
            sys.exit(1)
        
        print(f"Loaded table with {len(df)} rows and {len(df.columns)} columns", file=sys.stderr)
        
        # Parse column specifications
        row_cols = [col.strip() for col in args.rows.split(',')]
        col_cols = [col.strip() for col in args.cols.split(',')] if args.cols else None
        
        # Parse fill value
        fill_value = None
        if args.fill is not None:
            # Try to convert to number if possible
            try:
                fill_value = float(args.fill)
                if fill_value.is_integer():
                    fill_value = int(fill_value)
            except ValueError:
                fill_value = args.fill
        
        # Create pivot table
        pivot_result = create_pivot_table(
            df=df,
            row_cols=row_cols,
            col_cols=col_cols,
            value_col=args.values,
            agg_func=args.agg,
            fill_value=fill_value,
            margins=args.margins,
            sort_rows=args.sort_rows,
            sort_cols=args.sort_cols
        )
        
        # Transpose if requested
        if args.transpose:
            pivot_result = pivot_result.T
        
        # Convert to long format if requested
        if args.format == 'long':
            pivot_result = melt_pivot_table(pivot_result)
        
        # Convert to markdown
        markdown_output = dataframe_to_markdown(pivot_result)
        
        # Write output
        if args.output:
            with open(args.output, 'w', encoding='utf-8') as f:
                f.write(markdown_output)
            print(f"Pivot table written to: {args.output}", file=sys.stderr)
            
            # Print summary
            if args.format == 'wide':
                print(f"Created pivot table: {pivot_result.shape[0]} rows Ã— {pivot_result.shape[1]} columns", file=sys.stderr)
            else:
                print(f"Created long-format table: {len(pivot_result)} rows", file=sys.stderr)
        else:
            print(markdown_output, end='')
        
    except KeyboardInterrupt:
        sys.exit(1)
    except FileNotFoundError as e:
        print(f"Error: File not found: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()