#!/bin/bash
# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail

# Canary marker to prevent duplicate summaries (shared with append_summary)
CANARY='<!-- APPEND_SUMMARY_CANARY_7f3a9b2c -->'

show_help () {
	cat <<EOF
prepend_summary - Prepend AI-generated summary to content

USAGE:
    cat file.txt | prepend_summary [OPTIONS] [-- AI_OPTIONS...]
    prepend_summary -f FILE [OPTIONS] [-- AI_OPTIONS...]

DESCRIPTION:
    Prepends an AI-generated summary to input content with smart markdown-aware
    insertion. Always outputs the result to stdout unless --write-back is used.

    Smart insertion logic for markdown content:
      1. Skips frontmatter (if present)
      2. Finds the first # or ## heading after frontmatter
      3. Inserts summary as a subsection (## under #, ### under ##)
      4. Falls back to prepending at top if no heading found

    For non-markdown content, blindly prepends ## Summary at the top.

    With -f/--file, reads from the specified file instead of stdin.
    With --write-back, writes the result directly back to the file.

    Uses the same canary marker as append_summary to prevent duplicate
    summaries from either script.

OPTIONS:
    -f, --file FILE     Read content from FILE instead of stdin
    -w, --write-back    Write result back to the file (requires -f)
    --force             Bypass canary check and prepend anyway
    -h, --help          Show this help message
    --license           Show AGPLv3 license information

    All other options are forwarded to ai_summary_as_markdown.
    Common forwarded options include:
        --type TYPE         Content type (meeting, lecture, youtube, etc.)
        --reading-level LVL Target reading level (elementary, middle, high, etc.)
        --style STYLE       Tone (personal, academic, business, casual)
        --length LEN        Summary depth (brief, standard, detailed)

EXAMPLES:
    # Stdin mode (vim filter)
    cat meeting.txt | prepend_summary --type meeting

    # Vim :% filter
    :%!prepend_summary --type meeting

    # File mode (output to stdout)
    prepend_summary -f meeting.txt --type meeting

    # File mode with write-back (modifies the file)
    prepend_summary -f meeting.txt --write-back --type meeting

    # Force prepend even if summary already exists
    prepend_summary -f meeting.txt --force --type meeting

    # With additional options forwarded to ai_summary_as_markdown
    cat notes.txt | prepend_summary --type lecture --reading-level middle

EOF
}

show_license () {
	cat <<EOF
prepend_summary - Part of dotfiles
Copyright (C) 2025  Zach Podbielniak

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
EOF
}

# Variables
file_path=""
write_back=false
force=false
forward_args=()

# Parse arguments - separate our args from ai_summary_as_markdown args
while [[ $# -gt 0 ]]
do
	case "${1}" in
		-h|--help)
			show_help
			exit 0
			;;
		--license)
			show_license
			exit 0
			;;
		-f|--file)
			if [[ -z "${2:-}" ]]
			then
				echo "Error: --file requires a file path argument" >&2
				exit 1
			fi
			file_path="${2}"
			shift 2
			;;
		-w|--write-back)
			write_back=true
			shift
			;;
		--force)
			force=true
			shift
			;;
		--)
			# Everything after -- goes to ai_summary_as_markdown
			shift
			forward_args+=("$@")
			break
			;;
		*)
			# Forward unknown args to ai_summary_as_markdown
			forward_args+=("${1}")
			shift
			;;
	esac
done

# Check that ai_summary_as_markdown is available
if ! command -v ai_summary_as_markdown &>/dev/null
then
	echo "Error: ai_summary_as_markdown not found in PATH" >&2
	exit 1
fi

# Validate --write-back requires --file
if [[ "${write_back}" == true ]] && [[ -z "${file_path}" ]]
then
	echo "Error: --write-back requires -f/--file to be specified" >&2
	exit 1
fi

# Read content from file or stdin
if [[ -n "${file_path}" ]]
then
	if [[ ! -f "${file_path}" ]]
	then
		echo "Error: File not found: ${file_path}" >&2
		exit 1
	fi

	if [[ ! -r "${file_path}" ]]
	then
		echo "Error: Cannot read file: ${file_path}" >&2
		exit 1
	fi

	# Check write permission only if write-back is requested
	if [[ "${write_back}" == true ]] && [[ ! -w "${file_path}" ]]
	then
		echo "Error: Cannot write to file: ${file_path}" >&2
		exit 1
	fi

	content="$(cat "${file_path}")"
else
	content="$(cat)"
fi

# Check for canary (unless --force is used)
if [[ "${force}" == false ]] && [[ "${content}" == *"${CANARY}"* ]]
then
	echo "Error: Content already contains a summary (canary detected)" >&2
	echo "Use --force to prepend another summary anyway" >&2
	exit 1
fi

# Generate summary (handle empty forward_args array)
if [[ ${#forward_args[@]} -gt 0 ]]
then
	summary="$(echo "${content}" | ai_summary_as_markdown "${forward_args[@]}")"
else
	summary="$(echo "${content}" | ai_summary_as_markdown)"
fi

# -----------------------------------------------------------------------------
# Smart insertion logic for markdown
# -----------------------------------------------------------------------------

# Detect frontmatter: content starts with ---
has_frontmatter=false
frontmatter_end_line=0

if [[ "${content}" =~ ^--- ]]
then
	# Find the closing --- (starting search from line 2)
	# grep -n gives us "line_num:content", we want the first match
	closing_line=$(echo "${content}" | tail -n +2 | grep -n "^---$" | head -1 | cut -d: -f1)
	if [[ -n "${closing_line}" ]]
	then
		has_frontmatter=true
		# frontmatter_end_line is the actual line number in the original content
		# closing_line is relative to line 2, so add 1 to get absolute line number
		frontmatter_end_line=$((closing_line + 1))
	fi
fi

# Get content after frontmatter for heading detection
if [[ "${has_frontmatter}" == true ]]
then
	after_frontmatter=$(echo "${content}" | tail -n +"$((frontmatter_end_line + 1))")
else
	after_frontmatter="${content}"
fi

# Find first heading (# or ##) in content after frontmatter
# We look for # first, then ## if # not found
heading_level=0
heading_line_num=0
heading_line_relative=0

# Find first # heading
first_h1=$(echo "${after_frontmatter}" | grep -n "^# " | head -1 || true)
# Find first ## heading
first_h2=$(echo "${after_frontmatter}" | grep -n "^## " | head -1 || true)

if [[ -n "${first_h1}" ]]
then
	heading_level=1
	heading_line_relative=$(echo "${first_h1}" | cut -d: -f1)
elif [[ -n "${first_h2}" ]]
then
	heading_level=2
	heading_line_relative=$(echo "${first_h2}" | cut -d: -f1)
fi

# Calculate absolute line number of heading
if [[ "${heading_level}" -gt 0 ]]
then
	if [[ "${has_frontmatter}" == true ]]
	then
		heading_line_num=$((frontmatter_end_line + heading_line_relative))
	else
		heading_line_num="${heading_line_relative}"
	fi
fi

# Determine summary heading level (one deeper than main heading)
if [[ "${heading_level}" -eq 1 ]]
then
	summary_heading="## Summary"
elif [[ "${heading_level}" -eq 2 ]]
then
	summary_heading="### Summary"
else
	# No heading found - use ## Summary as default
	summary_heading="## Summary"
fi

# Build the summary block with canary
summary_block="${CANARY}"$'\n\n'"${summary_heading}"$'\n\n'"${summary}"$'\n'

# Build output based on content structure
if [[ "${heading_level}" -gt 0 ]]
then
	# Insert summary after the heading line
	# Get content before and including heading line
	before_and_heading=$(echo "${content}" | head -n "${heading_line_num}")
	# Get content after heading line
	after_heading=$(echo "${content}" | tail -n +"$((heading_line_num + 1))")

	# Combine: before+heading, blank line, summary block, rest of content
	output="${before_and_heading}"$'\n\n'"${summary_block}"$'\n'"${after_heading}"
elif [[ "${has_frontmatter}" == true ]]
then
	# No heading but has frontmatter - insert after frontmatter
	frontmatter=$(echo "${content}" | head -n "${frontmatter_end_line}")
	rest=$(echo "${content}" | tail -n +"$((frontmatter_end_line + 1))")

	output="${frontmatter}"$'\n\n'"${summary_block}"$'\n'"${rest}"
else
	# No heading, no frontmatter - prepend at top
	output="${summary_block}"$'\n'"${content}"
fi

# Output or write back
if [[ "${write_back}" == true ]]
then
	# Write result to file
	printf '%s' "${output}" > "${file_path}"
	echo "Summary prepended to ${file_path}" >&2
else
	# Output to stdout
	printf '%s' "${output}"
fi
