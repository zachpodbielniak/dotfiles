#!/usr/bin/python3

# Container check for distrobox - do this BEFORE any other imports
import os
import subprocess
import sys

ctr_id = os.environ.get("CONTAINER_ID", "")
no_dbox_check = os.environ.get("NO_DBOX_CHECK", "").lower() in ("1", "true")
if not no_dbox_check and ctr_id != "dev":
    cmd = ["distrobox", "enter", "dev", "--", *sys.argv]
    subprocess.run(cmd)
    sys.exit(0)

# Now import everything else inside the dev container
import argparse
import asyncio
import json
import re
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional, Any

# Try to import database dependencies
try:
    import psycopg2
    import psycopg2.extras
    from psycopg2.extras import RealDictCursor
    DB_AVAILABLE = True
except ImportError:
    print("Error: psycopg2 is required for notes-serve", file=sys.stderr)
    print("Install with: pip install psycopg2-binary", file=sys.stderr)
    sys.exit(1)

# Try to import web server dependencies
try:
    from quart import Quart, render_template_string, request, jsonify, redirect, url_for, make_response
    from quart_cors import cors
    import markdown
except ImportError:
    print("Error: Quart, quart-cors and markdown are required for notes-serve", file=sys.stderr)
    print("Install with: pip install quart quart-cors markdown", file=sys.stderr)
    sys.exit(1)

# Try to import MCP SDK
try:
    from mcp.server.models import InitializationOptions
    from mcp.server import NotificationOptions, Server
    from mcp.server.stdio import stdio_server
    from mcp.types import Tool, TextContent, ImageContent, EmbeddedResource
    MCP_AVAILABLE = True
except ImportError:
    MCP_AVAILABLE = False
    print("Warning: MCP SDK not available. Install with: pip install mcp", file=sys.stderr)

# Database configuration for notes storage
NOTES_DB_CONFIG = {
    'host': os.environ.get('NOTES_DB_HOST', '127.0.0.1'),
    'port': int(os.environ.get('NOTES_DB_PORT', '5432')),
    'database': os.environ.get('NOTES_DB_NAME', 'notes'),
    'user': os.environ.get('NOTES_DB_USER', 'postgres'),
    'password': os.environ.get('NOTES_DB_PASSWORD', '')
}

# Default notes directory
DEFAULT_NOTES_DIR = os.environ.get('NOTES_DIR', '/var/home/zach/Documents/notes')

# PARA categories mapping
PARA_CATEGORIES = {
    'inbox': '00_inbox',
    'projects': '01_projects',
    'areas': '02_areas',
    'resources': '03_resources',
    'archives': '04_archives'
}

# Create Quart app
app = Quart(__name__)
app = cors(app, allow_origin="*")

# HTML template for the web interface
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notes Server</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 300px;
            background: #2c3e50;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }
        
        .sidebar h2 {
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .tree-view {
            list-style: none;
        }
        
        .tree-item {
            padding: 5px 0;
            cursor: pointer;
            user-select: none;
        }
        
        .tree-item:hover {
            background: rgba(255, 255, 255, 0.1);
            padding-left: 5px;
        }
        
        .tree-folder {
            font-weight: bold;
            color: #3498db;
        }
        
        .tree-folder::before {
            content: "üìÅ ";
        }
        
        .tree-folder.open::before {
            content: "üìÇ ";
        }
        
        .tree-file {
            color: #ecf0f1;
            padding-left: 20px;
        }
        
        .tree-file::before {
            content: "üìù ";
        }
        
        .tree-children {
            display: none;
            padding-left: 20px;
        }
        
        .tree-children.open {
            display: block;
        }
        
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .search-box {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .note-header {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        
        .note-meta {
            color: #666;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .note-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .note-content h1, .note-content h2, .note-content h3,
        .note-content h4, .note-content h5, .note-content h6 {
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .note-content h1 { color: #2c3e50; }
        .note-content h2 { color: #34495e; }
        .note-content h3 { color: #7f8c8d; }
        
        .note-content pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        .note-content code {
            background: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        
        .note-content blockquote {
            border-left: 4px solid #3498db;
            padding-left: 20px;
            margin: 20px 0;
            color: #666;
            font-style: italic;
        }
        
        .note-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        
        .note-content table th,
        .note-content table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        
        .note-content table th {
            background: #f4f4f4;
            font-weight: bold;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .stat-number {
            font-size: 32px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #666;
            font-size: 14px;
        }
        
        .para-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            margin-right: 10px;
        }
        
        .para-inbox { background: #e74c3c; color: white; }
        .para-projects { background: #3498db; color: white; }
        .para-areas { background: #2ecc71; color: white; }
        .para-resources { background: #f39c12; color: white; }
        .para-archives { background: #95a5a6; color: white; }
        
        .tag {
            display: inline-block;
            padding: 2px 8px;
            background: #ecf0f1;
            border-radius: 3px;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
        }
        
        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h2>Notes</h2>
            <input type="text" class="search-box" placeholder="Search notes..." id="searchBox">
            <div id="treeView" class="tree-view">
                <div class="loading">Loading...</div>
            </div>
        </div>
        <div class="main-content">
            <div id="noteContent">
                <div class="loading">Select a note from the sidebar</div>
            </div>
        </div>
    </div>
    
    <script>
        let notesData = {};
        let currentNote = null;
        
        // Load notes tree
        async function loadNotesTree() {
            try {
                const response = await fetch('/api/notes/tree');
                const data = await response.json();
                notesData = data;
                renderTree(data.tree);
            } catch (error) {
                console.error('Error loading notes tree:', error);
                document.getElementById('treeView').innerHTML = '<div class="error">Failed to load notes</div>';
            }
        }
        
        // Render tree view
        function renderTree(tree) {
            const treeView = document.getElementById('treeView');
            treeView.innerHTML = '';
            
            // Render PARA categories
            const paraOrder = ['inbox', 'projects', 'areas', 'resources', 'archives'];
            paraOrder.forEach(para => {
                if (tree[para]) {
                    const paraElement = createTreeFolder(para.charAt(0).toUpperCase() + para.slice(1), tree[para], `para-${para}`);
                    treeView.appendChild(paraElement);
                }
            });
        }
        
        // Create tree folder element
        function createTreeFolder(name, contents, path) {
            const folder = document.createElement('div');
            folder.className = 'tree-item tree-folder';
            folder.textContent = name;
            folder.dataset.path = path;
            
            const children = document.createElement('div');
            children.className = 'tree-children';
            
            // Add subfolders
            if (contents.folders) {
                Object.keys(contents.folders).forEach(folderName => {
                    const subfolder = createTreeFolder(folderName, contents.folders[folderName], `${path}/${folderName}`);
                    children.appendChild(subfolder);
                });
            }
            
            // Add files
            if (contents.files) {
                contents.files.forEach(file => {
                    const fileElement = createTreeFile(file);
                    children.appendChild(fileElement);
                });
            }
            
            folder.addEventListener('click', (e) => {
                e.stopPropagation();
                folder.classList.toggle('open');
                children.classList.toggle('open');
            });
            
            folder.appendChild(children);
            return folder;
        }
        
        // Create tree file element
        function createTreeFile(file) {
            const fileElement = document.createElement('div');
            fileElement.className = 'tree-item tree-file';
            fileElement.textContent = file.name;
            fileElement.dataset.id = file.id;
            fileElement.dataset.path = file.path;
            
            fileElement.addEventListener('click', (e) => {
                e.stopPropagation();
                loadNote(file.id);
            });
            
            return fileElement;
        }
        
        // Load and display note
        async function loadNote(noteId) {
            try {
                const response = await fetch(`/api/notes/${noteId}`);
                const note = await response.json();
                currentNote = note;
                displayNote(note);
            } catch (error) {
                console.error('Error loading note:', error);
                document.getElementById('noteContent').innerHTML = '<div class="error">Failed to load note</div>';
            }
        }
        
        // Display note content
        function displayNote(note) {
            const content = document.getElementById('noteContent');
            
            // Create header
            const header = document.createElement('div');
            header.className = 'note-header';
            
            // Add title
            const title = document.createElement('h1');
            title.textContent = note.path.split('/').pop().replace(/\.(md|norg)$/, '');
            header.appendChild(title);
            
            // Add metadata
            const meta = document.createElement('div');
            meta.className = 'note-meta';
            
            // Add PARA badge
            const paraBadge = document.createElement('span');
            paraBadge.className = `para-badge para-${note.para}`;
            paraBadge.textContent = note.para;
            meta.appendChild(paraBadge);
            
            // Add category
            if (note.category) {
                const category = document.createElement('span');
                category.textContent = `Category: ${note.category} | `;
                meta.appendChild(category);
            }
            
            // Add dates
            const modified = new Date(note.last_modified).toLocaleString();
            const dateSpan = document.createElement('span');
            dateSpan.textContent = `Modified: ${modified}`;
            meta.appendChild(dateSpan);
            
            header.appendChild(meta);
            
            // Add tags
            if (note.tags && note.tags.length > 0) {
                const tagsDiv = document.createElement('div');
                tagsDiv.style.marginTop = '10px';
                note.tags.forEach(tag => {
                    const tagSpan = document.createElement('span');
                    tagSpan.className = 'tag';
                    tagSpan.textContent = tag;
                    tagsDiv.appendChild(tagSpan);
                });
                header.appendChild(tagsDiv);
            }
            
            // Add content
            const noteContent = document.createElement('div');
            noteContent.className = 'note-content';
            noteContent.innerHTML = note.html_content;
            
            // Clear and add new content
            content.innerHTML = '';
            content.appendChild(header);
            content.appendChild(noteContent);
            
            // Highlight code blocks
            if (window.Prism) {
                Prism.highlightAllUnder(noteContent);
            }
        }
        
        // Search functionality
        let searchTimeout;
        document.getElementById('searchBox').addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                searchNotes(e.target.value);
            }, 300);
        });
        
        async function searchNotes(query) {
            if (!query) {
                loadNotesTree();
                return;
            }
            
            try {
                const response = await fetch(`/api/notes/search?q=${encodeURIComponent(query)}`);
                const results = await response.json();
                displaySearchResults(results);
            } catch (error) {
                console.error('Error searching notes:', error);
            }
        }
        
        function displaySearchResults(results) {
            const treeView = document.getElementById('treeView');
            treeView.innerHTML = '';
            
            if (results.length === 0) {
                treeView.innerHTML = '<div class="loading">No results found</div>';
                return;
            }
            
            const resultsList = document.createElement('div');
            results.forEach(note => {
                const item = document.createElement('div');
                item.className = 'tree-item tree-file';
                item.textContent = note.path;
                item.dataset.id = note.id;
                item.addEventListener('click', () => loadNote(note.id));
                resultsList.appendChild(item);
            });
            
            treeView.appendChild(resultsList);
        }
        
        // Load tree on page load
        loadNotesTree();
        
        // Refresh tree periodically
        setInterval(loadNotesTree, 30000);
    </script>
</body>
</html>
"""

async def get_db_connection():
    """Get database connection (async wrapper for psycopg2)."""
    return psycopg2.connect(**NOTES_DB_CONFIG)

async def build_notes_tree():
    """Build a tree structure of notes from the database."""
    conn = await get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT id, path, para, category, last_modified
        FROM notes
        ORDER BY para, category, path
    """)
    
    notes = cursor.fetchall()
    cursor.close()
    conn.close()
    
    # Build tree structure
    tree = {
        'inbox': {'folders': {}, 'files': []},
        'projects': {'folders': {}, 'files': []},
        'areas': {'folders': {}, 'files': []},
        'resources': {'folders': {}, 'files': []},
        'archives': {'folders': {}, 'files': []}
    }
    
    for note in notes:
        para = note['para']
        path_parts = Path(note['path']).parts
        
        # Navigate to the correct location in tree
        current = tree[para]
        
        # Handle nested folders
        for i, part in enumerate(path_parts[:-1]):
            if part not in current['folders']:
                current['folders'][part] = {'folders': {}, 'files': []}
            current = current['folders'][part]
        
        # Add file
        file_name = path_parts[-1] if path_parts else note['path']
        current['files'].append({
            'id': str(note['id']),
            'name': file_name,
            'path': note['path'],
            'modified': note['last_modified'].isoformat() if note['last_modified'] else None
        })
    
    return {'tree': tree, 'total': len(notes)}

async def search_notes(query, limit=50):
    """Search notes in the database."""
    conn = await get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT id, path, para, category, 
               substring(content, 1, 200) as snippet,
               last_modified
        FROM notes
        WHERE to_tsvector('english', content) @@ plainto_tsquery('english', %s)
        ORDER BY ts_rank(content_vector, plainto_tsquery('english', %s)) DESC
        LIMIT %s
    """, (query, query, limit))
    
    results = cursor.fetchall()
    cursor.close()
    conn.close()
    
    # Convert datetime objects
    for result in results:
        if result['last_modified']:
            result['last_modified'] = result['last_modified'].isoformat()
        result['id'] = str(result['id'])
    
    return results

async def get_note_by_id(note_id):
    """Get a specific note by ID."""
    conn = await get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT id, path, para, category, content, 
               file_size, last_modified, created_at, accessed_at,
               metadata, tags
        FROM notes
        WHERE id = %s
    """, (note_id,))
    
    note = cursor.fetchone()
    cursor.close()
    conn.close()
    
    if note:
        # Convert content to HTML
        html_content = markdown.markdown(
            note['content'],
            extensions=['fenced_code', 'tables', 'toc', 'nl2br', 'sane_lists']
        )
        
        # Convert datetime objects
        for field in ['last_modified', 'created_at', 'accessed_at']:
            if note[field]:
                note[field] = note[field].isoformat()
        
        # Parse metadata
        if note['metadata']:
            try:
                note['metadata'] = json.loads(note['metadata'])
            except:
                note['metadata'] = {}
        
        note['id'] = str(note['id'])
        note['html_content'] = html_content
    
    return note

async def sync_notes():
    """Sync notes from filesystem to database."""
    proc = await asyncio.create_subprocess_exec(
        'python3', 'notes', 'sync', '--quiet',
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
        cwd='/var/home/zach/.dotfiles/bin/scripts'
    )
    
    stdout, stderr = await proc.communicate()
    return proc.returncode == 0

# API Routes
@app.route('/')
async def index():
    """Main web interface."""
    return HTML_TEMPLATE

@app.route('/api/notes/tree')
async def api_notes_tree():
    """Get notes tree structure."""
    tree = await build_notes_tree()
    return jsonify(tree)

@app.route('/api/notes/search')
async def api_notes_search():
    """Search notes."""
    query = request.args.get('q', '')
    limit = int(request.args.get('limit', 50))
    
    if not query:
        return jsonify([])
    
    results = await search_notes(query, limit)
    return jsonify(results)

@app.route('/api/notes/<note_id>')
async def api_get_note(note_id):
    """Get a specific note."""
    note = await get_note_by_id(note_id)
    
    if note:
        return jsonify(note)
    else:
        return jsonify({'error': 'Note not found'}), 404

@app.route('/api/notes/sync', methods=['POST'])
async def api_sync_notes():
    """Trigger notes sync."""
    success = await sync_notes()
    return jsonify({'success': success})

@app.route('/api/stats')
async def api_stats():
    """Get database statistics."""
    conn = await get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    # Get overall stats
    cursor.execute("""
        SELECT 
            COUNT(*) as total_notes,
            COUNT(DISTINCT para) as para_categories,
            COUNT(DISTINCT category) as unique_categories,
            SUM(file_size) as total_size
        FROM notes
    """)
    overall = cursor.fetchone()
    
    # Get PARA breakdown
    cursor.execute("""
        SELECT para, COUNT(*) as count
        FROM notes
        GROUP BY para
    """)
    para_breakdown = {row['para']: row['count'] for row in cursor.fetchall()}
    
    cursor.close()
    conn.close()
    
    return jsonify({
        'total_notes': overall['total_notes'],
        'total_size_mb': overall['total_size'] / 1024 / 1024 if overall['total_size'] else 0,
        'para_breakdown': para_breakdown
    })

# MCP Server Implementation
if MCP_AVAILABLE:
    mcp_server = Server("notes-server")
    
    @mcp_server.list_tools()
    async def handle_list_tools() -> list[Tool]:
        """List available MCP tools."""
        return [
            Tool(
                name="search_notes",
                description="Search notes by query, PARA category, or tags",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "query": {"type": "string", "description": "Search query"},
                        "para": {"type": "string", "enum": ["inbox", "projects", "areas", "resources", "archives"]},
                        "category": {"type": "string", "description": "Category filter"},
                        "tags": {"type": "array", "items": {"type": "string"}},
                        "limit": {"type": "integer", "default": 20}
                    }
                }
            ),
            Tool(
                name="get_note",
                description="Get the full content of a note by its path",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "path": {"type": "string", "description": "Note path relative to notes directory"}
                    },
                    "required": ["path"]
                }
            ),
            Tool(
                name="list_notes",
                description="List all notes or filter by PARA category",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "para": {"type": "string", "enum": ["inbox", "projects", "areas", "resources", "archives"]},
                        "limit": {"type": "integer", "default": 50}
                    }
                }
            )
        ]
    
    @mcp_server.call_tool()
    async def handle_call_tool(name: str, arguments: dict) -> list:
        """Handle MCP tool calls."""
        conn = await get_db_connection()
        cursor = conn.cursor(cursor_factory=RealDictCursor)
        
        if name == "search_notes":
            query = arguments.get("query", "")
            para = arguments.get("para")
            category = arguments.get("category")
            tags = arguments.get("tags")
            limit = arguments.get("limit", 20)
            
            # Build SQL query
            where_parts = []
            params = []
            
            if query:
                where_parts.append("to_tsvector('english', content) @@ plainto_tsquery('english', %s)")
                params.append(query)
            
            if para:
                where_parts.append("para = %s")
                params.append(para)
            
            if category:
                where_parts.append("category = %s")
                params.append(category)
            
            if tags:
                where_parts.append("%s::text[] && tags")
                params.append(tags)
            
            where_clause = " AND ".join(where_parts) if where_parts else "1=1"
            
            cursor.execute(f"""
                SELECT path, para, category, 
                       substring(content, 1, 500) as snippet,
                       tags
                FROM notes
                WHERE {where_clause}
                ORDER BY last_modified DESC
                LIMIT %s
            """, params + [limit])
            
            results = cursor.fetchall()
            
            # Format results
            formatted_results = []
            for note in results:
                result_text = f"Path: {note['path']}\n"
                result_text += f"PARA: {note['para']}\n"
                if note['category']:
                    result_text += f"Category: {note['category']}\n"
                if note['tags']:
                    result_text += f"Tags: {', '.join(note['tags'])}\n"
                result_text += f"\nSnippet:\n{note['snippet']}"
                formatted_results.append(TextContent(type="text", text=result_text))
            
            cursor.close()
            conn.close()
            return formatted_results
        
        elif name == "get_note":
            path = arguments["path"]
            
            cursor.execute("""
                SELECT content, para, category, tags, metadata
                FROM notes
                WHERE path = %s
            """, (path,))
            
            note = cursor.fetchone()
            cursor.close()
            conn.close()
            
            if note:
                result_text = f"Path: {path}\n"
                result_text += f"PARA: {note['para']}\n"
                if note['category']:
                    result_text += f"Category: {note['category']}\n"
                if note['tags']:
                    result_text += f"Tags: {', '.join(note['tags'])}\n"
                result_text += f"\n---\n\n{note['content']}"
                
                return [TextContent(type="text", text=result_text)]
            else:
                return [TextContent(type="text", text=f"Note not found: {path}")]
        
        elif name == "list_notes":
            para = arguments.get("para")
            limit = arguments.get("limit", 50)
            
            if para:
                cursor.execute("""
                    SELECT path, category, last_modified
                    FROM notes
                    WHERE para = %s
                    ORDER BY last_modified DESC
                    LIMIT %s
                """, (para, limit))
            else:
                cursor.execute("""
                    SELECT path, para, category, last_modified
                    FROM notes
                    ORDER BY para, last_modified DESC
                    LIMIT %s
                """, (limit,))
            
            notes = cursor.fetchall()
            cursor.close()
            conn.close()
            
            # Group by PARA if not filtered
            if not para:
                grouped = {}
                for note in notes:
                    p = note['para']
                    if p not in grouped:
                        grouped[p] = []
                    grouped[p].append(note)
                
                result_text = "Notes by PARA category:\n\n"
                for p in ['inbox', 'projects', 'areas', 'resources', 'archives']:
                    if p in grouped:
                        result_text += f"{p.upper()}:\n"
                        for note in grouped[p]:
                            cat = f" ({note['category']})" if note['category'] else ""
                            result_text += f"  - {note['path']}{cat}\n"
                        result_text += "\n"
            else:
                result_text = f"Notes in {para.upper()}:\n\n"
                for note in notes:
                    cat = f" ({note['category']})" if note['category'] else ""
                    result_text += f"- {note['path']}{cat}\n"
            
            return [TextContent(type="text", text=result_text)]
        
        else:
            return [TextContent(type="text", text=f"Unknown tool: {name}")]

async def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description='Notes web server and API')
    parser.add_argument('--host', default='127.0.0.1', help='Host to bind to')
    parser.add_argument('--port', type=int, default=5001, help='Port to bind to')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')
    parser.add_argument('--mcp', action='store_true', help='Run as MCP server')
    parser.add_argument('--sync-interval', type=int, default=300, help='Auto-sync interval in seconds')
    
    args = parser.parse_args()
    
    if args.mcp and MCP_AVAILABLE:
        # Run as MCP server
        async with stdio_server() as (read_stream, write_stream):
            await mcp_server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="notes-server",
                    server_version="1.0.0"
                )
            )
    else:
        # Run as web server
        print(f"Starting Notes Server on http://{args.host}:{args.port}")
        
        # Schedule periodic sync
        async def periodic_sync():
            while True:
                await asyncio.sleep(args.sync_interval)
                await sync_notes()
        
        # Start sync task
        asyncio.create_task(periodic_sync())
        
        # Run initial sync
        await sync_notes()
        
        # Start web server
        await app.run_task(host=args.host, port=args.port, debug=args.debug)

if __name__ == '__main__':
    asyncio.run(main())