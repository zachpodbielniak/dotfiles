#!/usr/bin/python3

# Container check for distrobox - do this BEFORE any other imports
import os
import subprocess
import sys

ctr_id = os.environ.get("CONTAINER_ID", "")
no_dbox_check = os.environ.get("NO_DBOX_CHECK", "").lower() in ("1", "true")
if not no_dbox_check and ctr_id != "dev":
    cmd = ["distrobox", "enter", "dev", "--", *sys.argv]
    subprocess.run(cmd)
    sys.exit(0)

# Now import everything else inside the dev container
import argparse
import asyncio
import json
import re
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Optional, Any

# Try to import database dependencies
try:
    import psycopg2
    import psycopg2.extras
    from psycopg2.extras import RealDictCursor
    DB_AVAILABLE = True
except ImportError:
    print("Error: psycopg2 is required for notes-serve", file=sys.stderr)
    print("Install with: pip install psycopg2-binary", file=sys.stderr)
    sys.exit(1)

# Try to import web server dependencies
try:
    from quart import Quart, render_template_string, request, jsonify, redirect, url_for, make_response
    from quart_cors import cors
    import markdown
except ImportError:
    print("Error: Quart, quart-cors and markdown are required for notes-serve", file=sys.stderr)
    print("Install with: pip install quart quart-cors markdown", file=sys.stderr)
    sys.exit(1)

# Try to import MCP SDK
try:
    from mcp.server.models import InitializationOptions
    from mcp.server import NotificationOptions, Server
    from mcp.server.stdio import stdio_server
    from mcp.types import Tool, TextContent, ImageContent, EmbeddedResource
    MCP_AVAILABLE = True
except ImportError:
    MCP_AVAILABLE = False
    print("Warning: MCP SDK not available. Install with: pip install mcp", file=sys.stderr)

# Database configuration for notes storage
NOTES_DB_CONFIG = {
    'host': os.environ.get('NOTES_DB_HOST', '127.0.0.1'),
    'port': int(os.environ.get('NOTES_DB_PORT', '5432')),
    'database': os.environ.get('NOTES_DB_NAME', 'notes'),
    'user': os.environ.get('NOTES_DB_USER', 'postgres'),
    'password': os.environ.get('NOTES_DB_PASSWORD', '')
}

# Default notes directory
DEFAULT_NOTES_DIR = os.environ.get('NOTES_DIR', '/var/home/zach/Documents/notes')

# PARA categories mapping
PARA_CATEGORIES = {
    'inbox': '00_inbox',
    'projects': '01_projects',
    'areas': '02_areas',
    'resources': '03_resources',
    'archives': '04_archives'
}

# Create Quart app
app = Quart(__name__)
app = cors(app, allow_origin="*")

# HTML template for the web interface
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notes Server</title>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-perl.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-haskell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-nasm.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Fira Code', 'JetBrains Mono', 'SF Mono', 'Monaco', 'Inconsolata', 'Consolas', monospace;
            background: #0c0c0c;
            color: #c9c9c9;
            line-height: 1.6;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 300px;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #333;
        }
        
        .sidebar h2 {
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .tree-view {
            list-style: none;
        }
        
        .tree-item {
            padding: 5px 0;
            cursor: pointer;
            user-select: none;
        }
        
        .tree-item:hover {
            background: rgba(0, 255, 0, 0.1);
            padding-left: 5px;
        }
        
        .tree-folder {
            font-weight: bold;
            color: #00ffff;
        }
        
        .tree-folder::before {
            content: "▶ ";
        }
        
        .tree-folder.open::before {
            content: "▼ ";
        }
        
        .tree-file {
            color: #c9c9c9;
            padding-left: 20px;
        }
        
        .tree-file::before {
            content: "• ";
        }
        
        .tree-children {
            display: none;
            padding-left: 20px;
        }
        
        .tree-children.open {
            display: block;
        }
        
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #0c0c0c;
        }
        
        .search-box {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #555;
            border-radius: 4px;
            margin-bottom: 20px;
            background: #1a1a1a;
            color: #00ff00;
            font-family: inherit;
        }
        
        .note-header {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #555;
        }
        
        .note-meta {
            color: #888;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .note-content {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #333;
            color: #c9c9c9;
        }
        
        .note-content h1, .note-content h2, .note-content h3,
        .note-content h4, .note-content h5, .note-content h6 {
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .note-content h1 { color: #00ff00; }
        .note-content h2 { color: #00ffff; }
        .note-content h3 { color: #ffff00; }
        
        .note-content pre {
            background: #0d1117 !important;
            border: 1px solid #30363d;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 15px 0;
            position: relative;
        }
        
        .note-content pre code {
            background: transparent !important;
            color: inherit !important;
            padding: 0 !important;
            border-radius: 0 !important;
            font-family: 'Fira Code', 'JetBrains Mono', 'SF Mono', 'Monaco', 'Inconsolata', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .note-content code:not(pre code) {
            background: #262c36;
            color: #f92672;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: inherit;
        }
        
        /* Override Prism theme for better terminal look */
        .note-content pre[class*="language-"] {
            background: #0d1117 !important;
            border: 1px solid #30363d !important;
        }
        
        .note-content .token.comment {
            color: #6e7681 !important;
        }
        
        .note-content .token.string {
            color: #a5d6ff !important;
        }
        
        .note-content .token.keyword {
            color: #ff7b72 !important;
        }
        
        .note-content .token.function {
            color: #d2a8ff !important;
        }
        
        .note-content .token.number {
            color: #79c0ff !important;
        }
        
        .note-content .token.operator {
            color: #ff7b72 !important;
        }
        
        .note-content blockquote {
            border-left: 4px solid #00ffff;
            padding-left: 20px;
            margin: 20px 0;
            color: #888;
            font-style: italic;
        }
        
        .note-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        
        .note-content table th,
        .note-content table td {
            border: 1px solid #555;
            padding: 8px;
            text-align: left;
        }
        
        .note-content table th {
            background: #262c36;
            font-weight: bold;
            color: #00ff00;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .stat-number {
            font-size: 32px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #666;
            font-size: 14px;
        }
        
        .para-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            margin-right: 10px;
        }
        
        .para-inbox { background: #e74c3c; color: white; }
        .para-projects { background: #3498db; color: white; }
        .para-areas { background: #2ecc71; color: white; }
        .para-resources { background: #f39c12; color: white; }
        .para-archives { background: #95a5a6; color: white; }
        
        .tag {
            display: inline-block;
            padding: 2px 8px;
            background: #ecf0f1;
            border-radius: 3px;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            color: #888;
        }
        
        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        /* Note control buttons */
        .note-buttons {
            margin: 15px 0;
            display: flex;
            gap: 10px;
        }
        
        .note-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        
        .view-raw-btn {
            background: #00ffff;
            color: #0c0c0c;
        }
        
        .view-raw-btn:hover {
            background: #33ffff;
            transform: translateY(-1px);
        }
        
        .copy-btn {
            background: #ffff00;
            color: #0c0c0c;
        }
        
        .copy-btn:hover {
            background: #ffff33;
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h2>Notes</h2>
            <input type="text" class="search-box" placeholder="Search notes..." id="searchBox">
            <div id="treeView" class="tree-view">
                <div class="loading">Loading...</div>
            </div>
        </div>
        <div class="main-content">
            <div id="noteContent">
                <div class="loading">Select a note from the sidebar</div>
            </div>
        </div>
    </div>
    
    <script>
        let notesData = {};
        let currentNote = null;
        
        // Check if Prism.js loaded
        window.addEventListener('load', () => {
            console.log('Page loaded. Prism available:', !!window.Prism);
            if (window.Prism) {
                console.log('Prism languages:', Object.keys(window.Prism.languages || {}));
            }
        });
        
        // Load notes tree
        async function loadNotesTree() {
            try {
                const response = await fetch('/api/notes/tree');
                const data = await response.json();
                notesData = data;
                renderTree(data.tree);
            } catch (error) {
                console.error('Error loading notes tree:', error);
                document.getElementById('treeView').innerHTML = '<div class="error">Failed to load notes</div>';
            }
        }
        
        // Store and restore expanded state
        function getExpandedState() {
            const expanded = new Set();
            document.querySelectorAll('.tree-folder.open').forEach(folder => {
                if (folder.dataset.path) {
                    expanded.add(folder.dataset.path);
                }
            });
            return expanded;
        }
        
        function restoreExpandedState(expandedPaths) {
            expandedPaths.forEach(path => {
                const folder = document.querySelector(`[data-path="${path}"]`);
                if (folder) {
                    folder.classList.add('open');
                    const children = folder.querySelector('.tree-children');
                    if (children) {
                        children.classList.add('open');
                    }
                }
            });
        }

        // Render tree view
        function renderTree(tree) {
            const treeView = document.getElementById('treeView');
            
            // Save expanded state
            const expandedState = getExpandedState();
            
            treeView.innerHTML = '';
            
            // Render PARA categories
            const paraMapping = {
                'inbox': '00_inbox',
                'projects': '01_projects', 
                'areas': '02_areas',
                'resources': '03_resources',
                'archives': '04_archives'
            };
            const paraOrder = ['inbox', 'projects', 'areas', 'resources', 'archives'];
            paraOrder.forEach(para => {
                if (tree[para]) {
                    const paraElement = createTreeFolder(paraMapping[para], tree[para], `para-${para}`);
                    treeView.appendChild(paraElement);
                }
            });
            
            // Restore expanded state 
            setTimeout(() => restoreExpandedState(expandedState), 0);
        }
        
        // Create tree folder element
        function createTreeFolder(name, contents, path) {
            const folder = document.createElement('div');
            folder.className = 'tree-item tree-folder';
            folder.textContent = name;
            folder.dataset.path = path;
            
            const children = document.createElement('div');
            children.className = 'tree-children';
            
            // Add subfolders
            if (contents.folders) {
                Object.keys(contents.folders).forEach(folderName => {
                    const subfolder = createTreeFolder(folderName, contents.folders[folderName], `${path}/${folderName}`);
                    children.appendChild(subfolder);
                });
            }
            
            // Add files
            if (contents.files) {
                contents.files.forEach(file => {
                    const fileElement = createTreeFile(file);
                    children.appendChild(fileElement);
                });
            }
            
            folder.addEventListener('click', (e) => {
                e.stopPropagation();
                folder.classList.toggle('open');
                children.classList.toggle('open');
            });
            
            folder.appendChild(children);
            return folder;
        }
        
        // Create tree file element
        function createTreeFile(file) {
            const fileElement = document.createElement('div');
            fileElement.className = 'tree-item tree-file';
            fileElement.textContent = file.name;
            fileElement.dataset.id = file.id;
            fileElement.dataset.path = file.path;
            
            fileElement.addEventListener('click', (e) => {
                e.stopPropagation();
                loadNote(file.id);
            });
            
            return fileElement;
        }
        
        // Load and display note
        async function loadNote(noteId, updateUrl = true) {
            try {
                const response = await fetch(`/api/notes/${noteId}`);
                const note = await response.json();
                currentNote = note;
                displayNote(note);
                
                // Update URL without triggering page reload
                if (updateUrl) {
                    const newUrl = `${window.location.origin}${window.location.pathname}#note/${noteId}`;
                    const title = note.path.split('/').pop().replace(/\\.(md|norg)$/, '');
                    window.history.pushState({noteId: noteId}, title, newUrl);
                }
            } catch (error) {
                console.error('Error loading note:', error);
                document.getElementById('noteContent').innerHTML = '<div class="error">Failed to load note</div>';
            }
        }
        
        // Display note content
        function displayNote(note) {
            const content = document.getElementById('noteContent');
            
            // Create header
            const header = document.createElement('div');
            header.className = 'note-header';
            
            // Add title
            const title = document.createElement('h1');
            title.textContent = note.path.split('/').pop().replace(/\\.(md|norg)$/, '');
            header.appendChild(title);
            
            // Add metadata
            const meta = document.createElement('div');
            meta.className = 'note-meta';
            
            // Add PARA badge
            const paraBadge = document.createElement('span');
            paraBadge.className = `para-badge para-${note.para}`;
            paraBadge.textContent = note.para;
            meta.appendChild(paraBadge);
            
            // Add category
            if (note.category) {
                const category = document.createElement('span');
                category.textContent = `Category: ${note.category} | `;
                meta.appendChild(category);
            }
            
            // Add dates
            const modified = new Date(note.last_modified).toLocaleString();
            const dateSpan = document.createElement('span');
            dateSpan.textContent = `Modified: ${modified}`;
            meta.appendChild(dateSpan);
            
            header.appendChild(meta);
            
            // Add control buttons
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'note-buttons';
            
            const viewRawBtn = document.createElement('button');
            viewRawBtn.className = 'note-btn view-raw-btn';
            viewRawBtn.textContent = 'View Raw';
            viewRawBtn.onclick = () => toggleRawView(note);
            
            const copyBtn = document.createElement('button');
            copyBtn.className = 'note-btn copy-btn';
            copyBtn.textContent = 'Copy Markdown';
            copyBtn.onclick = () => copyMarkdown(note.content);
            
            buttonContainer.appendChild(viewRawBtn);
            buttonContainer.appendChild(copyBtn);
            header.appendChild(buttonContainer);
            
            // Add tags
            if (note.tags && note.tags.length > 0) {
                const tagsDiv = document.createElement('div');
                tagsDiv.style.marginTop = '10px';
                note.tags.forEach(tag => {
                    const tagSpan = document.createElement('span');
                    tagSpan.className = 'tag';
                    tagSpan.textContent = tag;
                    tagsDiv.appendChild(tagSpan);
                });
                header.appendChild(tagsDiv);
            }
            
            // Add content
            const noteContent = document.createElement('div');
            noteContent.className = 'note-content';
            noteContent.innerHTML = note.html_content;
            
            // Clear and add new content
            content.innerHTML = '';
            content.appendChild(header);
            content.appendChild(noteContent);
            
            // Highlight code blocks
            console.log('Prism available:', !!window.Prism);
            const allCodeBlocks = noteContent.querySelectorAll('pre code');
            const languageCodeBlocks = noteContent.querySelectorAll('pre code[class*="language-"]');
            console.log('Total code blocks:', allCodeBlocks.length);
            console.log('Language code blocks:', languageCodeBlocks.length);
            
            // Log the HTML structure of first code block for debugging
            if (allCodeBlocks.length > 0) {
                console.log('First code block HTML:', allCodeBlocks[0].outerHTML.substring(0, 200));
                console.log('First code block classes:', allCodeBlocks[0].className);
            }
            
            if (window.Prism) {
                console.log('Available Prism languages:', Object.keys(window.Prism.languages || {}));
                console.log('Highlighting code blocks...');
                Prism.highlightAllUnder(noteContent);
            } else {
                console.warn('Prism.js not loaded');
            }
        }
        
        // Toggle raw markdown view
        let isRawView = false;
        function toggleRawView(note) {
            const noteContent = document.querySelector('.note-content');
            const viewRawBtn = document.querySelector('.view-raw-btn');
            
            if (!isRawView) {
                // Show raw markdown
                noteContent.innerHTML = `<pre><code>${escapeHtml(note.content)}</code></pre>`;
                viewRawBtn.textContent = 'View Rendered';
                isRawView = true;
            } else {
                // Show rendered HTML
                noteContent.innerHTML = note.html_content;
                viewRawBtn.textContent = 'View Raw';
                isRawView = false;
                
                // Re-highlight code blocks
                console.log('Re-highlighting after raw view toggle');
                if (window.Prism) {
                    Prism.highlightAllUnder(noteContent);
                } else {
                    console.warn('Prism.js not available for re-highlighting');
                }
            }
        }
        
        // Copy markdown to clipboard
        async function copyMarkdown(content) {
            try {
                await navigator.clipboard.writeText(content);
                const copyBtn = document.querySelector('.copy-btn');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                copyBtn.style.background = '#2ecc71';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy: ', err);
                alert('Failed to copy to clipboard');
            }
        }
        
        // HTML escape utility
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Search functionality
        let searchTimeout;
        document.getElementById('searchBox').addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                searchNotes(e.target.value);
            }, 300);
        });
        
        async function searchNotes(query) {
            if (!query) {
                loadNotesTree();
                return;
            }
            
            try {
                const response = await fetch(`/api/notes/search?q=${encodeURIComponent(query)}`);
                const results = await response.json();
                displaySearchResults(results);
            } catch (error) {
                console.error('Error searching notes:', error);
            }
        }
        
        function displaySearchResults(results) {
            const treeView = document.getElementById('treeView');
            treeView.innerHTML = '';
            
            if (results.length === 0) {
                treeView.innerHTML = '<div class="loading">No results found</div>';
                return;
            }
            
            const resultsList = document.createElement('div');
            results.forEach(note => {
                const item = document.createElement('div');
                item.className = 'tree-item tree-file';
                item.textContent = note.path;
                item.dataset.id = note.id;
                item.addEventListener('click', () => loadNote(note.id));
                resultsList.appendChild(item);
            });
            
            treeView.appendChild(resultsList);
        }
        
        // URL routing functions
        function parseUrlForNote() {
            const hash = window.location.hash;
            const match = hash.match(/^#note\\/(.+)$/);
            return match ? match[1] : null;
        }
        
        function handleUrlChange() {
            const noteId = parseUrlForNote();
            if (noteId && currentNote?.id !== noteId) {
                loadNote(noteId, false); // Don't update URL when loading from URL
            }
        }
        
        // Handle browser back/forward navigation
        window.addEventListener('popstate', (event) => {
            if (event.state && event.state.noteId) {
                loadNote(event.state.noteId, false);
            } else {
                // No note in URL, show default view
                document.getElementById('noteContent').innerHTML = '<div class="loading">Select a note from the sidebar</div>';
                currentNote = null;
            }
        });
        
        // Load tree on page load
        loadNotesTree();
        
        // Check URL for note to load after tree is loaded
        setTimeout(() => {
            handleUrlChange();
        }, 500);
        
        // Refresh tree periodically
        setInterval(loadNotesTree, 30000);
    </script>
</body>
</html>
"""

async def get_db_connection():
    """Get database connection (async wrapper for psycopg2)."""
    return psycopg2.connect(**NOTES_DB_CONFIG)

async def build_notes_tree():
    """Build a tree structure of notes from the database."""
    conn = await get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT id, path, para, category, last_modified
        FROM notes
        ORDER BY para, category, path
    """)
    
    notes = cursor.fetchall()
    cursor.close()
    conn.close()
    
    # Build tree structure
    tree = {
        'inbox': {'folders': {}, 'files': []},
        'projects': {'folders': {}, 'files': []},
        'areas': {'folders': {}, 'files': []},
        'resources': {'folders': {}, 'files': []},
        'archives': {'folders': {}, 'files': []}
    }
    
    for note in notes:
        para = note['para']
        path_parts = Path(note['path']).parts
        
        # Navigate to the correct location in tree
        current = tree[para]
        
        # Skip the PARA folder name (00_inbox, 01_projects, etc.) in the path
        para_folder = PARA_CATEGORIES[para]
        filtered_parts = []
        for part in path_parts[:-1]:
            if part != para_folder:
                filtered_parts.append(part)
        
        # Handle nested folders
        for i, part in enumerate(filtered_parts):
            if part not in current['folders']:
                current['folders'][part] = {'folders': {}, 'files': []}
            current = current['folders'][part]
        
        # Add file
        file_name = path_parts[-1] if path_parts else note['path']
        current['files'].append({
            'id': str(note['id']),
            'name': file_name,
            'path': note['path'],
            'modified': note['last_modified'].isoformat() if note['last_modified'] else None
        })
    
    return {'tree': tree, 'total': len(notes)}

async def search_notes(query, limit=50):
    """Search notes in the database."""
    conn = await get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT id, path, para, category, 
               substring(content, 1, 200) as snippet,
               last_modified
        FROM notes
        WHERE to_tsvector('english', content) @@ plainto_tsquery('english', %s)
        ORDER BY ts_rank(content_vector, plainto_tsquery('english', %s)) DESC
        LIMIT %s
    """, (query, query, limit))
    
    results = cursor.fetchall()
    cursor.close()
    conn.close()
    
    # Convert datetime objects
    for result in results:
        if result['last_modified']:
            result['last_modified'] = result['last_modified'].isoformat()
        result['id'] = str(result['id'])
    
    return results

async def get_note_by_id(note_id):
    """Get a specific note by ID."""
    conn = await get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    cursor.execute("""
        SELECT id, path, para, category, content, 
               file_size, last_modified, created_at, accessed_at,
               metadata, tags
        FROM notes
        WHERE id = %s
    """, (note_id,))
    
    note = cursor.fetchone()
    cursor.close()
    conn.close()
    
    if note:
        # Debug: log raw content
        print(f"DEBUG: Raw note content (first 200 chars):")
        print(repr(note['content'][:200]))
        
        # Convert content to HTML
        html_content = markdown.markdown(
            note['content'],
            extensions=['meta', 'fenced_code', 'tables', 'toc', 'nl2br', 'sane_lists']
        )
        
        # Debug: log processed HTML
        print(f"DEBUG: Processed HTML (first 200 chars):")
        print(repr(html_content[:200]))
        
        # Convert datetime objects
        for field in ['last_modified', 'created_at', 'accessed_at']:
            if note[field]:
                note[field] = note[field].isoformat()
        
        # Parse metadata
        if note['metadata']:
            try:
                note['metadata'] = json.loads(note['metadata'])
            except:
                note['metadata'] = {}
        
        note['id'] = str(note['id'])
        note['html_content'] = html_content
    
    return note

async def sync_notes():
    """Sync notes from filesystem to database."""
    proc = await asyncio.create_subprocess_exec(
        'python3', 'notes', 'sync', '--quiet',
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
        cwd='/var/home/zach/.dotfiles/bin/scripts'
    )
    
    stdout, stderr = await proc.communicate()
    return proc.returncode == 0

# API Routes
@app.route('/')
async def index():
    """Main web interface."""
    return HTML_TEMPLATE

@app.route('/api/notes/tree')
async def api_notes_tree():
    """Get notes tree structure."""
    tree = await build_notes_tree()
    return jsonify(tree)

@app.route('/api/notes/search')
async def api_notes_search():
    """Search notes."""
    query = request.args.get('q', '')
    limit = int(request.args.get('limit', 50))
    
    if not query:
        return jsonify([])
    
    results = await search_notes(query, limit)
    return jsonify(results)

@app.route('/api/notes/<note_id>')
async def api_get_note(note_id):
    """Get a specific note."""
    note = await get_note_by_id(note_id)
    
    if note:
        return jsonify(note)
    else:
        return jsonify({'error': 'Note not found'}), 404

@app.route('/api/notes/sync', methods=['POST'])
async def api_sync_notes():
    """Trigger notes sync."""
    success = await sync_notes()
    return jsonify({'success': success})

@app.route('/api/stats')
async def api_stats():
    """Get database statistics."""
    conn = await get_db_connection()
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    # Get overall stats
    cursor.execute("""
        SELECT 
            COUNT(*) as total_notes,
            COUNT(DISTINCT para) as para_categories,
            COUNT(DISTINCT category) as unique_categories,
            SUM(file_size) as total_size
        FROM notes
    """)
    overall = cursor.fetchone()
    
    # Get PARA breakdown
    cursor.execute("""
        SELECT para, COUNT(*) as count
        FROM notes
        GROUP BY para
    """)
    para_breakdown = {row['para']: row['count'] for row in cursor.fetchall()}
    
    cursor.close()
    conn.close()
    
    return jsonify({
        'total_notes': overall['total_notes'],
        'total_size_mb': overall['total_size'] / 1024 / 1024 if overall['total_size'] else 0,
        'para_breakdown': para_breakdown
    })

# MCP Server Implementation
if MCP_AVAILABLE:
    mcp_server = Server("notes-server")
    
    @mcp_server.list_tools()
    async def handle_list_tools() -> list[Tool]:
        """List available MCP tools."""
        return [
            Tool(
                name="search_notes",
                description="Search notes by query, PARA category, or tags",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "query": {"type": "string", "description": "Search query"},
                        "para": {"type": "string", "enum": ["inbox", "projects", "areas", "resources", "archives"]},
                        "category": {"type": "string", "description": "Category filter"},
                        "tags": {"type": "array", "items": {"type": "string"}},
                        "limit": {"type": "integer", "default": 20}
                    }
                }
            ),
            Tool(
                name="get_note",
                description="Get the full content of a note by its path",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "path": {"type": "string", "description": "Note path relative to notes directory"}
                    },
                    "required": ["path"]
                }
            ),
            Tool(
                name="list_notes",
                description="List all notes or filter by PARA category",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "para": {"type": "string", "enum": ["inbox", "projects", "areas", "resources", "archives"]},
                        "limit": {"type": "integer", "default": 50}
                    }
                }
            )
        ]
    
    @mcp_server.call_tool()
    async def handle_call_tool(name: str, arguments: dict) -> list:
        """Handle MCP tool calls."""
        conn = await get_db_connection()
        cursor = conn.cursor(cursor_factory=RealDictCursor)
        
        if name == "search_notes":
            query = arguments.get("query", "")
            para = arguments.get("para")
            category = arguments.get("category")
            tags = arguments.get("tags")
            limit = arguments.get("limit", 20)
            
            # Build SQL query
            where_parts = []
            params = []
            
            if query:
                where_parts.append("to_tsvector('english', content) @@ plainto_tsquery('english', %s)")
                params.append(query)
            
            if para:
                where_parts.append("para = %s")
                params.append(para)
            
            if category:
                where_parts.append("category = %s")
                params.append(category)
            
            if tags:
                where_parts.append("%s::text[] && tags")
                params.append(tags)
            
            where_clause = " AND ".join(where_parts) if where_parts else "1=1"
            
            cursor.execute(f"""
                SELECT path, para, category, 
                       substring(content, 1, 500) as snippet,
                       tags
                FROM notes
                WHERE {where_clause}
                ORDER BY last_modified DESC
                LIMIT %s
            """, params + [limit])
            
            results = cursor.fetchall()
            
            # Format results
            formatted_results = []
            for note in results:
                result_text = f"Path: {note['path']}\n"
                result_text += f"PARA: {note['para']}\n"
                if note['category']:
                    result_text += f"Category: {note['category']}\n"
                if note['tags']:
                    result_text += f"Tags: {', '.join(note['tags'])}\n"
                result_text += f"\nSnippet:\n{note['snippet']}"
                formatted_results.append(TextContent(type="text", text=result_text))
            
            cursor.close()
            conn.close()
            return formatted_results
        
        elif name == "get_note":
            path = arguments["path"]
            
            cursor.execute("""
                SELECT content, para, category, tags, metadata
                FROM notes
                WHERE path = %s
            """, (path,))
            
            note = cursor.fetchone()
            cursor.close()
            conn.close()
            
            if note:
                result_text = f"Path: {path}\n"
                result_text += f"PARA: {note['para']}\n"
                if note['category']:
                    result_text += f"Category: {note['category']}\n"
                if note['tags']:
                    result_text += f"Tags: {', '.join(note['tags'])}\n"
                result_text += f"\n---\n\n{note['content']}"
                
                return [TextContent(type="text", text=result_text)]
            else:
                return [TextContent(type="text", text=f"Note not found: {path}")]
        
        elif name == "list_notes":
            para = arguments.get("para")
            limit = arguments.get("limit", 50)
            
            if para:
                cursor.execute("""
                    SELECT path, category, last_modified
                    FROM notes
                    WHERE para = %s
                    ORDER BY last_modified DESC
                    LIMIT %s
                """, (para, limit))
            else:
                cursor.execute("""
                    SELECT path, para, category, last_modified
                    FROM notes
                    ORDER BY para, last_modified DESC
                    LIMIT %s
                """, (limit,))
            
            notes = cursor.fetchall()
            cursor.close()
            conn.close()
            
            # Group by PARA if not filtered
            if not para:
                grouped = {}
                for note in notes:
                    p = note['para']
                    if p not in grouped:
                        grouped[p] = []
                    grouped[p].append(note)
                
                result_text = "Notes by PARA category:\n\n"
                for p in ['inbox', 'projects', 'areas', 'resources', 'archives']:
                    if p in grouped:
                        result_text += f"{p.upper()}:\n"
                        for note in grouped[p]:
                            cat = f" ({note['category']})" if note['category'] else ""
                            result_text += f"  - {note['path']}{cat}\n"
                        result_text += "\n"
            else:
                result_text = f"Notes in {para.upper()}:\n\n"
                for note in notes:
                    cat = f" ({note['category']})" if note['category'] else ""
                    result_text += f"- {note['path']}{cat}\n"
            
            return [TextContent(type="text", text=result_text)]
        
        else:
            return [TextContent(type="text", text=f"Unknown tool: {name}")]

async def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description='Notes web server and API')
    parser.add_argument('--host', default='127.0.0.1', help='Host to bind to')
    parser.add_argument('--port', type=int, default=5001, help='Port to bind to')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')
    parser.add_argument('--mcp', action='store_true', help='Run as MCP server')
    parser.add_argument('--sync-interval', type=int, default=300, help='Auto-sync interval in seconds')
    
    args = parser.parse_args()
    
    if args.mcp and MCP_AVAILABLE:
        # Run as MCP server
        async with stdio_server() as (read_stream, write_stream):
            await mcp_server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="notes-server",
                    server_version="1.0.0"
                )
            )
    else:
        # Run as web server
        print(f"Starting Notes Server on http://{args.host}:{args.port}")
        
        # Schedule periodic sync
        async def periodic_sync():
            while True:
                await asyncio.sleep(args.sync_interval)
                await sync_notes()
        
        # Start sync task
        asyncio.create_task(periodic_sync())
        
        # Run initial sync
        await sync_notes()
        
        # Start web server
        await app.run_task(host=args.host, port=args.port, debug=args.debug)

if __name__ == '__main__':
    asyncio.run(main())