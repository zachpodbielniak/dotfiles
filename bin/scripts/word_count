#!/usr/bin/bash
# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail

usage () {
	cat << 'EOF'
word_count - Detailed word statistics

USAGE:
	word_count [OPTIONS]

OPTIONS:
	-h, --help         Show this help message
	--license          Show license information
	--top N            Show top N most frequent words
	--min-length N     Minimum word length to count
	--json             Output as JSON
	--unique           Only output unique word count

EXAMPLES:
	echo "hello world hello" | word_count
	echo "hello world hello" | word_count --unique
	echo "hello world" | word_count --top 5

DESCRIPTION:
	Analyze word statistics including total words, unique words,
	and frequency distribution.

EOF
}

top=0
min_length=0
output_json=false
unique_only=false

while [[ $# -gt 0 ]]; do
	case "$1" in
		-h|--help)
			usage
			exit 0
			;;
		--license)
			echo "AGPLv3"
			exit 0
			;;
		--top)
			top="$2"
			shift 2
			;;
		--min-length)
			min_length="$2"
			shift 2
			;;
		--json)
			output_json=true
			shift
			;;
		--unique)
			unique_only=true
			shift
			;;
		*)
			echo "word_count: unknown option: $1" >&2
			exit 1
			;;
	esac
done

# Use awk to process words
if [[ "$unique_only" == "true" ]]; then
	# Just output unique word count
	tr ' ' '\n' | grep -v '^$' | sort -u | wc -l
else
	# Full statistics
	awk -v top="$top" -v min_len="$min_length" -v json="$output_json" '
		{
			for (i=1; i<=NF; i++) {
				word = tolower($i)
				gsub(/[^a-z0-9]/, "", word)
				if (length(word) >= min_len) {
					count[word]++
					total++
				}
			}
		}
		END {
			# Output statistics
			if (json) {
				printf "{"
				printf "\"total\": %d, ", total
				printf "\"unique\": %d", length(count)
				if (top > 0) {
					printf ", \"top\": ["
					n = 0
					for (word in count) {
						words[++n] = word
					}
					for (i = 1; i <= n; i++) {
						for (j = i+1; j <= n; j++) {
							if (count[words[i]] < count[words[j]]) {
								tmp = words[i]
								words[i] = words[j]
								words[j] = tmp
							}
						}
					}
					for (i = 1; i <= (top < n ? top : n); i++) {
						if (i > 1) printf ", "
						printf "{\"word\": \"%s\", \"count\": %d}", words[i], count[words[i]]
					}
					printf "]"
				}
				printf "}\n"
			} else {
				printf "Total words: %d\n", total
				printf "Unique words: %d\n", length(count)
				if (top > 0) {
					n = 0
					for (word in count) {
						words[++n] = word
					}
					for (i = 1; i <= n; i++) {
						for (j = i+1; j <= n; j++) {
							if (count[words[i]] < count[words[j]]) {
								tmp = words[i]
								words[i] = words[j]
								words[j] = tmp
							}
						}
					}
					printf "\nTop %d words:\n", (top < n ? top : n)
					for (i = 1; i <= (top < n ? top : n); i++) {
						printf "%s\t%d\n", words[i], count[words[i]]
					}
				}
			}
		}
	'
fi
