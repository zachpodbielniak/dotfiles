#!/bin/bash
#
# A tool to perform a native thread dump for a native process.
# Usecases include but not limited to:
# - Validate a perceived stuck process (alternative option/complement to strace)
# - Check for suspicious items in a thread's stack.
# - Get detailed thread names
#
#
# Examples:
# 
# - General thread dump:
#	- ./thread_dump -p 867803 -s 
#
# - Thread dump of all threads:
#	- ./thread_dump -p 867803 -s -a
#
# - Validate a process is stuck or not. The below command will recursiving run the
#   thread_dump utility, pipe the output to grep, which will look for the 'rip' register 
#   line. From here, at some point the 'rip' (instruction pointer) register value should
#   change. If it never does it means it is likely a stuck thread. *Please note* that this 
#   is essentially a race condition. thread_dump relies on the ability for gdb to attach
#   to the process to perform this there is an operation. It is entirely possible that
#   the process is not stuck, but the 'rip' register's value never changes because during
#   execution of thread_dump it never captures it.
#	- while true; do sh -c './thread_dump -p 867803 -i -s 2>/dev/null | grep rip'; done
#
# - Get detailed thread names. The below can help to show thread info and the thread names
#   and other misc. thread details.
# 	- ./thread_dump -p 867803 -t -s
#




TD_ARGS=("$@")		# Arguments
TD_VERBOSE=0		# Verbose mode. 0 is false, 1 is true.
TD_DRY_RUN=0		# Dry run mode. 0 is false, 1 is true.
TD_GDB_PARAMS=""	# GDB Parameters
TD_PID=-1		# PID to perform thread dump on
TD_ITERATOR=0		# Iterator for iterating through arguments
TD_ALL_THREADS=0	# Multi-thread dump. 0 is false, 1 is true.
TD_THREAD_DETAILS=0	# Thread detailed mode. No thread dump, just thread info.
TD_SUDO=0		# Auto prepend 'sudo'. 0 is false, 1 is true.
TD_FULL=0		# Full backtrace setting




if [ $# -lt 1 ]
then
	echo -e "Use this tool correctly"
	echo -e "See --help how to use it.\n"
	exit 1
fi




# Iterate over the args
while [ $TD_ITERATOR -lt $# ]
do
	# Get the current key
	TD_KEY=${TD_ARGS[$TD_ITERATOR]}
	
	if [ $TD_ITERATOR -lt $(( $#-1 )) ]
	then
		# Value for the "key" is the next arg
		TD_VALUE=${TD_ARGS[$(( TD_ITERATOR+1 ))]}
	else
		# At the end of the args
		TD_VALUE=""
	fi


	# Help
	if [ "--help" = "$TD_KEY" ] || [ "-h" = "$TD_KEY" ]
	then
		echo -e "thread_dump script"
		echo -e "------------------"
		echo -e "A script to aid in performing a thread dump of a native process at runtime"
		echo -e ""
		echo -e "Usage:"
		echo -e "\t-h, --help\t\t| Print this message"
		echo -e "\t-v, --verbose\t\t| Verbose mode. Print command executed before executing"
		echo -e "\t-d, --dry-run\t\t| Don't actually run the command, but print the command"
		echo -e "\t-s, --sudo\t\t| Auto sudo the gdb call. If not, then you need ptrace cap."
		echo -e "\t-p, --pid\t\t| PID to perform the thread dump on"
		echo -e "\t-P, --process\t\t| Process to perform it on (rather than PID). Uses \$(pgrep)"
		echo -e "\t-r, --registers\t\t| Print registers"
		echo -e "\t-R, --register-type\t| Prints the types of registers, ex: all, vector, mmx, general"
		echo -e "\t-i, --instruction\t| Print instruction pointer register"
		echo -e "\t-f, --full\t\t| Print a full backtrace"
		echo -e "\t-a, --all-threads\t| Perform thread dump of all threads"
		echo -e "\t-t, --thread-info\t| Get thread info. Does not perform a thread dump"
		echo ""
		exit 0
	fi
	

	# Verbose
	if [ "--verbose" = "$TD_KEY" ] || [ "-v" = "$TD_KEY" ]
	then
		TD_VERBOSE=1
	fi
	

	# Dry Run
	if [ "--dry-run" = "$TD_KEY" ] || [ "-d" = "$TD_KEY" ]
	then
		TD_DRY_RUN=1
	fi
	

	# Sudo
	if [ "--sudo" = "$TD_KEY" ] || [ "-s" = "$TD_KEY" ]
	then
		TD_SUDO=1
	fi

	
	# PID
	if [ "--pid" = "$TD_KEY" ] || [ "-p" = "$TD_KEY" ]
	then
		TD_PID="$TD_VALUE"
	fi
	

	# Process
	if [ "--process" = "$TD_KEY" ] || [ "-P" = "$TD_KEY" ]
	then
		TD_PID=$(pgrep "$TD_VALUE")
	fi
	

	# Registers
	if [ "--registers" = "$TD_KEY" ] || [ "-r" = "$TD_KEY" ]
	then
		TD_GDB_PARAMS="${TD_GDB_PARAMS}-ex 'i r' "
	fi
	

	# Register Type
	if [ "--register-type" = "$TD_KEY" ] || [ "-R" = "$TD_KEY" ]
	then
		TD_GDB_PARAMS="${TD_GDB_PARAMS}-ex 'i r $TD_VALUE' "
	fi
	

	# Instruction Pointer
	if [ "--instruction" = "$TD_KEY" ] || [ "-i" = "$TD_KEY" ]
	then
		TD_GDB_PARAMS="${TD_GDB_PARAMS}-ex 'i r rip' "
	fi
	

	# Full backtrace
	if [ "--full" = "$TD_KEY" ] || [ "-f" = "$TD_KEY" ]
	then
		TD_FULL=1
	fi
	

	# All Threads
	if [ "--all-threads" = "$TD_KEY" ] || [ "-a" = "$TD_KEY" ]
	then
		TD_ALL_THREADS=1
	fi
	

	# Thread Info
	if [ "--thread-info" = "$TD_KEY" ] || [ "-t" = "$TD_KEY" ]
	then
		TD_THREAD_DETAILS=1
	fi
	

	#Increment the iterator
	TD_ITERATOR=$(( TD_ITERATOR+1 ))
done




# Append correct thread backtrace info
if [ "1" = "$TD_ALL_THREADS" ]
then 
	if [ "1" = "$TD_FULL" ]
	then
		TD_GDB_PARAMS="${TD_GDB_PARAMS}-ex 'thread apply all bt full' "
	else
		TD_GDB_PARAMS="${TD_GDB_PARAMS}-ex 'thread apply all bt' "
	fi
else
	if [ "1" = "$TD_FULL" ]
	then
		TD_GDB_PARAMS="${TD_GDB_PARAMS}-ex 'bt full' "
	else
		TD_GDB_PARAMS="${TD_GDB_PARAMS}-ex 'bt' "
	fi
fi




# If we are in thread detail mode, set GDB params accordingly
if [ "1" = "$TD_THREAD_DETAILS" ]
then
	TD_GDB_PARAMS="-ex 'info threads' "
fi




# If dry run, just do the dry run
if [ "1" == "$TD_DRY_RUN" ]
then
	if [ "1" = "$TD_SUDO" ]
	then 
		echo -e "sudo gdb --batch -q -p $TD_PID $TD_GDB_PARAMS"
	else
		echo -e "gdb --batch -q -p $TD_PID $TD_GDB_PARAMS"
	fi 

	exit 0
fi




# If verbose, lets ask if they want to continue
if [ "1" == "$TD_VERBOSE" ]
then
	if [ "1" = "$TD_SUDO" ]
	then 
		echo -e "sudo gdb --batch -q -p $TD_PID $TD_GDB_PARAMS"
	else
		echo -e "gdb --batch -q -p $TD_PID $TD_GDB_PARAMS"
	fi 

	echo -e "Do you wish to continue? y/n: "
	read TD_CONFIRMATION

	if [ "n" = "$TD_CONFIRMATION" ] || [ "N" = "$TD_CONFIRMATION" ]
	then
		exit 0
	fi
fi




# If sudo, run the command with sudo
if [ "1" = "$TD_SUDO" ]
then 
	# The real gdb call
	sh -c "sudo gdb --batch -q -p $TD_PID $TD_GDB_PARAMS"
	exit $?
else
	# The real gdb call
	sh -c "gdb --batch -q -p $TD_PID $TD_GDB_PARAMS"
fi 




# Exit with the status from the 'sh -c' call.
exit $?

