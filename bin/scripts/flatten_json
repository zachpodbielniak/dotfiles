#!/usr/bin/env python3

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""Flatten nested JSON to dot-notation keys."""

import sys
import json
import argparse
from typing import Any, Dict, Optional


def flatten_dict(
	obj: Any,
	sep: str = ".",
	parent_key: str = "",
	max_depth: Optional[int] = None,
	current_depth: int = 0,
) -> Dict[str, Any]:
	"""Flatten a nested dictionary to dot-notation keys.

	Args:
		obj: Object to flatten
		sep: Separator between keys
		parent_key: Current parent key prefix
		max_depth: Maximum depth to flatten (None = unlimited)
		current_depth: Current recursion depth

	Returns:
		Flattened dictionary
	"""
	items: list = []

	if isinstance(obj, dict):
		for key, val in obj.items():
			new_key: str = f"{parent_key}{sep}{key}" if parent_key else key
			if max_depth is None or current_depth < max_depth:
				if isinstance(val, (dict, list)):
					items.extend(
						flatten_dict(
							val,
							sep=sep,
							parent_key=new_key,
							max_depth=max_depth,
							current_depth=current_depth + 1,
						).items()
					)
				else:
					items.append((new_key, val))
			else:
				items.append((new_key, val))

	elif isinstance(obj, list):
		for idx, item in enumerate(obj):
			new_key: str = f"{parent_key}{sep}{idx}" if parent_key else str(idx)
			if max_depth is None or current_depth < max_depth:
				if isinstance(item, (dict, list)):
					items.extend(
						flatten_dict(
							item,
							sep=sep,
							parent_key=new_key,
							max_depth=max_depth,
							current_depth=current_depth + 1,
						).items()
					)
				else:
					items.append((new_key, item))
			else:
				items.append((new_key, item))

	else:
		return {parent_key: obj} if parent_key else {}

	return dict(items)


def main() -> int:
	"""Main function."""
	parser = argparse.ArgumentParser(
		prog="flatten_json",
		description="Flatten nested JSON to dot-notation keys",
	)
	parser.add_argument(
		"--separator",
		default=".",
		help="Key separator (default: .)",
	)
	parser.add_argument(
		"--max-depth",
		type=int,
		default=None,
		help="Maximum depth to flatten",
	)
	parser.add_argument(
		"--license",
		action="store_true",
		help="Show license information",
	)

	args = parser.parse_args()

	if args.license:
		print("AGPLv3")
		return 0

	try:
		# Read JSON from stdin
		json_input: str = sys.stdin.read()
		data: Any = json.loads(json_input)

		# Flatten the data
		flattened: Dict[str, Any] = flatten_dict(
			data,
			sep=args.separator,
			max_depth=args.max_depth,
		)

		# Output as JSON
		json_output: str = json.dumps(flattened)
		sys.stdout.write(json_output + "\n")

		return 0

	except json.JSONDecodeError as e:
		print(f"Error: Invalid JSON input: {e}", file=sys.stderr)
		return 1
	except Exception as e:
		print(f"Error: {e}", file=sys.stderr)
		return 1


if __name__ == "__main__":
	sys.exit(main())
