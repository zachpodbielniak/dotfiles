#!/usr/bin/python3

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import argparse
import sys
import yaml
import re
from pathlib import Path
from typing import Any, Dict, List, Optional


class MarkdownParser:
    """Parse markdown content into a structured dictionary."""

    def __init__(self):
        self.lines: List[str] = []
        self.index: int = 0

    def parse(self, content: str) -> Dict[str, Any]:
        """Parse markdown content into structured dictionary."""
        self.lines = content.split('\n')
        self.index = 0
        section = self._parse_section(0)
        return section

    def _parse_section(self, min_level: int) -> Dict[str, Any]:
        """Parse a section (content at a given nesting level)."""
        section: Dict[str, Any] = {}
        content: List[Dict[str, Any]] = []

        while self.index < len(self.lines):
            self._skip_empty_lines()

            if self.index >= len(self.lines):
                break

            line = self._get_current_line()
            if line is None:
                break

            # Check for heading
            heading_match = re.match(r'^(#{1,6})\s+(.+)$', line)
            if heading_match:
                level = len(heading_match.group(1))

                # If heading level <= min_level, it's not our content
                if level <= min_level:
                    break

                title = heading_match.group(2).strip()
                heading_key = title.lower().replace(' ', '_')

                self._consume_line()

                # If content list is not empty, save it before processing subsection
                if content:
                    section['content'] = content
                    content = []

                # Parse subsection
                subsection = self._parse_section(level)
                section[heading_key] = subsection
                continue

            # Try to parse different content types
            parsed = self._try_parse_content_item()
            if parsed:
                content.append(parsed)
            else:
                # Skip line if we can't parse it
                self._consume_line()

        # Add remaining content
        if content:
            section['content'] = content

        return section

    def _try_parse_content_item(self) -> Optional[Dict[str, Any]]:
        """Try to parse a content item (paragraph, list, code, etc)."""
        line = self._get_current_line()
        if not line:
            return None

        stripped = line.strip()

        # Empty line
        if not stripped:
            return None

        # Code block (must check before list/paragraph)
        if stripped.startswith('```'):
            code = self._parse_code_block()
            return {'type': 'code', 'value': code}

        # Ordered or unordered list
        if re.match(r'^(\s*)[-*+]\s+', line):
            items = self._parse_list()
            return {'type': 'list', 'values': items}

        # Ordered list (numbered)
        if re.match(r'^(\s*)\d+\.\s+', line):
            items = self._parse_ordered_list()
            return {'type': 'ordered_list', 'values': items}

        # Blockquote
        if stripped.startswith('>'):
            quote = self._parse_blockquote()
            return {'type': 'blockquote', 'value': quote}

        # Paragraph (fallback)
        para = self._parse_paragraph()
        if para:
            return {'type': 'paragraph', 'value': para}

        return None

    def _parse_paragraph(self) -> Optional[str]:
        """Parse a paragraph (one or more lines until blank line or special element)."""
        para_lines = []

        while self.index < len(self.lines):
            line = self.lines[self.index]
            stripped = line.strip()

            # Stop on empty line
            if not stripped:
                break

            # Stop on heading, list, code block, blockquote
            if re.match(r'^#{1,6}\s+', line) or \
               re.match(r'^(\s*)[-*+]\s+', line) or \
               re.match(r'^(\s*)\d+\.\s+', line) or \
               stripped.startswith('```') or \
               stripped.startswith('>'):
                break

            para_lines.append(stripped)
            self.index += 1

        if para_lines:
            return ' '.join(para_lines)

        return None

    def _parse_list(self) -> List[str]:
        """Parse an unordered/mixed list (-, *, +)."""
        items = []
        base_indent = None

        while self.index < len(self.lines):
            line = self.lines[self.index]
            list_match = re.match(r'^(\s*)[-*+]\s+(.+)$', line)

            if not list_match:
                break

            indent = len(list_match.group(1))
            item_text = list_match.group(2).strip()

            if base_indent is None:
                base_indent = indent

            if indent != base_indent:
                break

            items.append(item_text)
            self.index += 1

        return items

    def _parse_ordered_list(self) -> List[str]:
        """Parse an ordered list (1., 2., etc.)."""
        items = []
        base_indent = None

        while self.index < len(self.lines):
            line = self.lines[self.index]
            list_match = re.match(r'^(\s*)\d+\.\s+(.+)$', line)

            if not list_match:
                break

            indent = len(list_match.group(1))
            item_text = list_match.group(2).strip()

            if base_indent is None:
                base_indent = indent

            if indent != base_indent:
                break

            items.append(item_text)
            self.index += 1

        return items

    def _parse_blockquote(self) -> str:
        """Parse a blockquote."""
        quote_lines = []

        while self.index < len(self.lines):
            line = self.lines[self.index]
            stripped = line.strip()

            if not stripped.startswith('>'):
                break

            # Remove '>' and leading space
            quote_text = stripped[1:].strip()
            quote_lines.append(quote_text)
            self.index += 1

        return '\n'.join(quote_lines)

    def _parse_code_block(self) -> str:
        """Parse a code block (triple backticks)."""
        self._consume_line()  # Consume opening ```

        code_lines = []

        while self.index < len(self.lines):
            line = self.lines[self.index]
            if line.strip().startswith('```'):
                self._consume_line()  # Consume closing ```
                break
            code_lines.append(line)
            self.index += 1

        return '\n'.join(code_lines).rstrip()

    def _skip_empty_lines(self) -> None:
        """Skip empty lines."""
        while self.index < len(self.lines) and not self.lines[self.index].strip():
            self.index += 1

    def _get_current_line(self) -> Optional[str]:
        """Peek at current line without consuming it."""
        if self.index < len(self.lines):
            return self.lines[self.index]
        return None

    def _consume_line(self) -> Optional[str]:
        """Consume and return current line."""
        if self.index < len(self.lines):
            line = self.lines[self.index]
            self.index += 1
            return line
        return None


def process_file(filepath: str) -> tuple:
    """Process a markdown file and return filename and parsed content."""
    path = Path(filepath)
    filename = path.stem  # Remove extension

    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        raise FileNotFoundError(f"File not found: {filepath}")
    except IOError as e:
        raise IOError(f"Error reading file '{filepath}': {e}")

    parser = MarkdownParser()
    parsed = parser.parse(content)

    return filename, {filename: parsed}


def main() -> None:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        prog='md_to_yaml',
        description='Convert markdown files to YAML format',
        epilog='''Examples:
  md_to_yaml -f file.md
  md_to_yaml -f file1.md -f file2.md -o output.yaml
  cat file.md | md_to_yaml
  md_to_yaml < file.md -o output.yaml''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument(
        '-f', '--file',
        dest='files',
        action='append',
        help='Markdown file(s) to convert (can be used multiple times)'
    )
    parser.add_argument(
        '-o', '--output',
        dest='output',
        help='Output YAML file (default: stdout)'
    )

    args = parser.parse_args()

    output_data: Dict[str, Any] = {}

    try:
        if args.files:
            for filepath in args.files:
                filename, parsed = process_file(filepath)
                output_data.update(parsed)
        else:
            # Read from stdin
            content = sys.stdin.read()
            parser_obj = MarkdownParser()
            parsed = parser_obj.parse(content)
            output_data['stdin'] = parsed

        # Convert to YAML with nice formatting
        yaml_output = yaml.dump(
            output_data,
            default_flow_style=False,
            allow_unicode=True,
            sort_keys=False,
            width=1000  # Prevent line wrapping
        )

        if args.output:
            try:
                with open(args.output, 'w', encoding='utf-8') as f:
                    f.write(yaml_output)
                print(f"âœ“ Output written to {args.output}", file=sys.stderr)
            except IOError as e:
                print(f"Error: Cannot write to '{args.output}': {e}", file=sys.stderr)
                sys.exit(1)
        else:
            print(yaml_output, end='')

    except FileNotFoundError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
