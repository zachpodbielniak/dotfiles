#!/bin/bash
# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail

SCRIPT_NAME="$(basename "${0}")"

usage () {
    cat <<EOF
${SCRIPT_NAME} - Add git blame info to selected lines

USAGE:
    ${SCRIPT_NAME} [OPTIONS] FILE [START_LINE] [END_LINE]

DESCRIPTION:
    Runs git blame on the specified file and line range, outputting
    each line prefixed with blame information (commit, author, date).

    Note: This filter requires the FILE argument since git blame needs
    to know which file to blame. Use in neovim with the current file.

OPTIONS:
    -h, --help          Show this help message and exit
    -s, --short         Show short format (hash + date only)
    -a, --author        Include author name
    --license           Show the license (AGPLv3) and exit

ARGUMENTS:
    FILE            File to run git blame on (required)
    START_LINE      Starting line number (optional)
    END_LINE        Ending line number (optional)

EXAMPLES:
    # Blame entire file
    ${SCRIPT_NAME} src/main.c

    # Blame lines 10-20
    ${SCRIPT_NAME} src/main.c 10 20

    # In neovim, blame visual selection (assuming file is saved):
    :'<,'>!${SCRIPT_NAME} -s % '<,'> 

    # More practical neovim usage:
    :!${SCRIPT_NAME} % \$(line("'<")) \$(line("'>"))

EOF
}

main () {
    local short_format=0
    local show_author=0
    local file_path=""
    local start_line=""
    local end_line=""
    local positional=()

    while [[ $# -gt 0 ]]; do
        case "${1}" in
            -h|--help)
                usage
                exit 0
                ;;
            -s|--short)
                short_format=1
                ;;
            -a|--author)
                show_author=1
                ;;
            --license)
                echo "AGPLv3 - See source file for full license."
                exit 0
                ;;
            -*)
                echo "Error: Unknown option '${1}'" >&2
                exit 1
                ;;
            *)
                positional+=("${1}")
                ;;
        esac
        shift
    done

    if [[ ${#positional[@]} -lt 1 ]]; then
        echo "Error: FILE argument required" >&2
        echo "Use '${SCRIPT_NAME} --help' for usage." >&2
        exit 1
    fi

    file_path="${positional[0]}"
    if [[ ${#positional[@]} -ge 2 ]]; then
        start_line="${positional[1]}"
    fi
    if [[ ${#positional[@]} -ge 3 ]]; then
        end_line="${positional[2]}"
    fi

    if [[ ! -f "${file_path}" ]]; then
        echo "Error: File '${file_path}' not found" >&2
        exit 1
    fi

    # Build git blame command
    local blame_opts=()
    
    if [[ ${short_format} -eq 1 ]]; then
        blame_opts+=("--date=short")
    fi

    if [[ -n "${start_line}" ]] && [[ -n "${end_line}" ]]; then
        blame_opts+=("-L" "${start_line},${end_line}")
    elif [[ -n "${start_line}" ]]; then
        blame_opts+=("-L" "${start_line},")
    fi

    # Run git blame
    if [[ ${short_format} -eq 1 ]]; then
        git blame "${blame_opts[@]}" -- "${file_path}" 2>/dev/null | \
            awk '{
                hash = substr($1, 1, 8);
                # Find the date (YYYY-MM-DD format)
                for (i=2; i<=NF; i++) {
                    if ($i ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) {
                        date = $i;
                        # Rest is the code
                        code = "";
                        for (j=i+2; j<=NF; j++) code = code " " $j;
                        printf "%s %s |%s\n", hash, date, code;
                        break;
                    }
                }
            }'
    else
        git blame "${blame_opts[@]}" -- "${file_path}" 2>/dev/null
    fi
}

main "$@"
