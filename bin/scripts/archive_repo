#!/usr/bin/python3

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import argparse
import json
import os
import re
import subprocess
import sys
from urllib.parse import urlparse
import traceback

# Gitea server configuration - CHANGE THIS TO YOUR GITEA INSTANCE
GITEA_SERVER_URL = 'http://localhost:3000'

# Gitea API base URL (constructed from server URL)
GITEA_API_BASE = f'{GITEA_SERVER_URL}/api/v1'

# Service type mappings
SERVICE_TYPES = {
    'github': 'github',
    'gitlab': 'gitlab',
    'gitea': 'gitea',
    'forgejo': 'forgejo',
    'gogs': 'gogs',
    'onedev': 'onedev',
    'gitbucket': 'gitbucket',
    'codebase': 'codebase'
}

def debug_log(message, debug=False):
    """Print debug messages if debug mode is enabled."""
    if debug:
        print(f"[DEBUG] {message}", file=sys.stderr)

def run_curl(url, method='GET', data=None, token=None, debug=False):
    """Run curl command and return response."""
    cmd = ['curl', '-s']
    
    if debug:
        cmd.extend(['-v'])
    
    cmd.extend(['-X', method])
    
    if token:
        cmd.extend(['-H', f'Authorization: token {token}'])
    
    if data:
        cmd.extend(['-H', 'Content-Type: application/json'])
        cmd.extend(['-d', json.dumps(data)])
    
    cmd.append(url)
    
    debug_log(f"Running: {' '.join(cmd)}", debug)
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            debug_log(f"Curl failed with code {result.returncode}: {result.stderr}", debug)
            return None
        
        if result.stdout:
            try:
                return json.loads(result.stdout)
            except json.JSONDecodeError:
                debug_log(f"Failed to parse JSON response: {result.stdout}", debug)
                return None
        return {}
    except Exception as e:
        debug_log(f"Error running curl: {e}", debug)
        return None

def detect_service(url, debug=False):
    """Detect the git service from URL."""
    parsed = urlparse(url)
    hostname = parsed.hostname or parsed.path
    
    debug_log(f"Detecting service for hostname: {hostname}", debug)
    
    if 'github.com' in hostname:
        return 'github'
    elif 'gitlab.com' in hostname:
        return 'gitlab'
    elif 'gitea' in hostname:
        return 'gitea'
    elif 'gogs' in hostname:
        return 'gogs'
    elif 'bitbucket' in hostname:
        return 'gitbucket'
    elif 'codeberg.org' in hostname:
        return 'forgejo'
    
    return None

def is_org_or_user_url(url, debug=False):
    """Check if URL points to an org/user rather than a specific repo."""
    # Remove trailing slash
    url = url.rstrip('/')
    
    # Count path segments after domain
    parsed = urlparse(url)
    path = parsed.path.strip('/')
    
    if not path:
        return False
    
    segments = path.split('/')
    
    # Org/user URLs typically have 1 segment, repo URLs have 2+
    is_org = len(segments) == 1
    debug_log(f"URL segments: {segments}, is_org/user: {is_org}", debug)
    return is_org

def list_github_repos(owner, debug=False):
    """List all repositories for a GitHub user/org."""
    repos = []
    page = 1
    per_page = 100
    
    while True:
        # Try user endpoint first
        url = f"https://api.github.com/users/{owner}/repos?per_page={per_page}&page={page}"
        debug_log(f"Fetching GitHub repos from: {url}", debug)
        
        response = run_curl(url, debug=debug)
        
        if response is None:
            # Try org endpoint
            url = f"https://api.github.com/orgs/{owner}/repos?per_page={per_page}&page={page}"
            debug_log(f"Trying org endpoint: {url}", debug)
            response = run_curl(url, debug=debug)
        
        if response is None or not isinstance(response, list):
            break
        
        if len(response) == 0:
            break
        
        for repo in response:
            if isinstance(repo, dict) and 'clone_url' in repo:
                repos.append(repo['clone_url'])
                debug_log(f"Found repo: {repo['clone_url']}", debug)
        
        if len(response) < per_page:
            break
        
        page += 1
    
    return repos

def list_gitlab_repos(owner, debug=False):
    """List all repositories for a GitLab user/group."""
    repos = []
    page = 1
    per_page = 100
    
    # Try user projects
    url = f"https://gitlab.com/api/v4/users/{owner}/projects?per_page={per_page}&page={page}"
    debug_log(f"Fetching GitLab repos from: {url}", debug)
    
    response = run_curl(url, debug=debug)
    
    if response and isinstance(response, list):
        for repo in response:
            if isinstance(repo, dict) and 'http_url_to_repo' in repo:
                repos.append(repo['http_url_to_repo'])
                debug_log(f"Found repo: {repo['http_url_to_repo']}", debug)
    else:
        # Try group projects
        url = f"https://gitlab.com/api/v4/groups/{owner}/projects?per_page={per_page}&page={page}"
        debug_log(f"Trying group endpoint: {url}", debug)
        response = run_curl(url, debug=debug)
        
        if response and isinstance(response, list):
            for repo in response:
                if isinstance(repo, dict) and 'http_url_to_repo' in repo:
                    repos.append(repo['http_url_to_repo'])
                    debug_log(f"Found repo: {repo['http_url_to_repo']}", debug)
    
    return repos

def list_repos_for_service(service_url, service, owner, debug=False):
    """List all repositories for a given service and owner."""
    debug_log(f"Listing repos for {service}:{owner}", debug)
    
    if service == 'github':
        return list_github_repos(owner, debug)
    elif service == 'gitlab':
        return list_gitlab_repos(owner, debug)
    else:
        debug_log(f"Repository listing not implemented for service: {service}", debug)
        return []

def parse_repo_info(url, debug=False):
    """Extract repo owner and name from URL."""
    # Remove .git suffix if present
    url = url.rstrip('.git')
    
    # Handle various URL formats
    patterns = [
        r'(?:https?://|git@)(?:[^/:]+)[:/]([^/]+)/([^/]+?)(?:\.git)?$',
        r'(?:ssh://)?git@([^:]+):([^/]+)/([^/]+?)(?:\.git)?$',
    ]
    
    for pattern in patterns:
        match = re.search(pattern, url)
        if match:
            if len(match.groups()) == 3:
                # SSH format with host
                owner = match.group(2)
                repo = match.group(3)
            else:
                # HTTPS format
                owner = match.group(1)
                repo = match.group(2)
            
            debug_log(f"Parsed repo info - owner: {owner}, repo: {repo}", debug)
            return owner, repo
    
    debug_log(f"Failed to parse repo info from URL: {url}", debug)
    return None, None

def get_organizations(token, debug=False):
    """Get list of organizations from Gitea."""
    url = f"{GITEA_API_BASE}/user/orgs"
    debug_log(f"Fetching organizations from: {url}", debug)
    
    response = run_curl(url, token=token, debug=debug)
    if response is None:
        return []
    
    if isinstance(response, list):
        org_names = [org.get('username', '') for org in response]
        debug_log(f"Found organizations: {org_names}", debug)
        return org_names
    
    return []

def create_organization(org_name, token, debug=False):
    """Create a new organization in Gitea."""
    url = f"{GITEA_API_BASE}/orgs"
    data = {
        'username': org_name,
        'full_name': org_name,
        'description': f'Archived repositories under {org_name}',
        'visibility': 'public'
    }
    
    debug_log(f"Creating organization: {org_name}", debug)
    response = run_curl(url, method='POST', data=data, token=token, debug=debug)
    
    if response and 'id' in response:
        debug_log(f"Successfully created organization: {org_name}", debug)
        return True
    
    debug_log(f"Failed to create organization: {response}", debug)
    return False

def check_repository_exists(repo_owner, repo_name, token, debug=False):
    """Check if a repository already exists in Gitea."""
    url = f"{GITEA_API_BASE}/repos/{repo_owner}/{repo_name}"
    debug_log(f"Checking if repository exists: {repo_owner}/{repo_name}", debug)
    
    response = run_curl(url, token=token, debug=debug)
    
    if response and 'id' in response:
        debug_log(f"Repository already exists: {repo_owner}/{repo_name}", debug)
        return True
    
    return False

def migrate_repository(repo_url, service, repo_owner, repo_name, token, debug=False):
    """Migrate a repository to Gitea."""
    # First check if repository already exists
    if check_repository_exists(repo_owner, repo_name, token, debug):
        debug_log(f"Repository {repo_owner}/{repo_name} already exists, skipping migration", debug)
        return True  # Success - already exists
    
    url = f"{GITEA_API_BASE}/repos/migrate"
    
    data = {
        'clone_addr': repo_url,
        'repo_name': repo_name,
        'repo_owner': repo_owner,
        'service': service,
        'mirror': True,
        'private': False,
        'issues': True,
        'labels': True,
        'milestones': True,
        'pull_requests': True,
        'releases': True,
        'wiki': True
    }
    
    debug_log(f"Migrating repository: {repo_url} -> {repo_owner}/{repo_name}", debug)
    debug_log(f"Migration data: {json.dumps(data, indent=2)}", debug)
    
    response = run_curl(url, method='POST', data=data, token=token, debug=debug)
    
    if response and 'id' in response:
        debug_log(f"Successfully migrated repository: {response.get('full_name')}", debug)
        return True
    
    if response and 'message' in response:
        error_msg = response['message']
        debug_log(f"Migration failed: {error_msg}", debug)
        
        # Check if it's a duplicate error (shouldn't happen now but keep as fallback)
        if 'already exists' in error_msg.lower():
            debug_log("Repository already exists in Gitea (caught in error)", debug)
            return True  # Consider it a success if already archived
    
    debug_log(f"Migration failed with response: {response}", debug)
    return False

def main():
    parser = argparse.ArgumentParser(
        description='Archive remote git repositories to local Gitea instance',
        epilog='''Examples:
  # Archive a single repository
  archive_repo https://github.com/user/repo.git
  
  # Archive all repositories from a user/org
  archive_repo https://github.com/torvalds
  archive_repo https://gitlab.com/gitlab-org
  
  # Specify service explicitly
  archive_repo https://git.example.com/user --service gitlab
  
  # Override organization in Gitea
  archive_repo https://github.com/user/repo.git --org my-archives
  
  # Debug mode
  archive_repo https://github.com/user --debug
''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('url', help='URL of repository, user, or organization to archive')
    parser.add_argument('--service', choices=list(SERVICE_TYPES.keys()),
                      help='Git service type (auto-detected if not specified)')
    parser.add_argument('--org', help='Override organization/owner name in Gitea')
    parser.add_argument('--debug', action='store_true', help='Enable debug output')
    
    args = parser.parse_args()
    
    # Check for API token
    token = os.environ.get('GITEA_TOKEN')
    if not token:
        if not args.debug:
            sys.exit(1)
        print("Error: GITEA_TOKEN environment variable not set", file=sys.stderr)
        sys.exit(1)
    
    try:
        # Detect or validate service type
        if args.service:
            service = SERVICE_TYPES[args.service]
            debug_log(f"Using specified service: {service}", args.debug)
        else:
            service = detect_service(args.url, args.debug)
            if not service:
                print("Error: Cannot detect service type from URL. Please specify with --service", file=sys.stderr)
                sys.exit(1)
            debug_log(f"Auto-detected service: {service}", args.debug)
        
        # Determine if this is an org/user URL or a specific repo
        if is_org_or_user_url(args.url, args.debug):
            # Extract owner from URL
            parsed = urlparse(args.url)
            owner = parsed.path.strip('/').split('/')[0]
            
            if not owner:
                print("Error: Cannot extract owner from URL", file=sys.stderr)
                sys.exit(1)
            
            debug_log(f"Detected org/user URL for: {owner}", args.debug)
            
            # List all repositories
            repo_urls = list_repos_for_service(args.url, service, owner, args.debug)
            
            if not repo_urls:
                print(f"Warning: No repositories found for {owner}", file=sys.stderr)
                sys.exit(0)
            
            debug_log(f"Found {len(repo_urls)} repositories to archive", args.debug)
            
            # Archive each repository
            success_count = 0
            failed_repos = []
            
            for repo_url in repo_urls:
                default_owner, repo_name = parse_repo_info(repo_url, args.debug)
                if not repo_name:
                    debug_log(f"Skipping invalid repo URL: {repo_url}", args.debug)
                    continue
                
                # Determine repo owner for Gitea
                repo_owner = args.org if args.org else default_owner
                
                debug_log(f"Archiving {repo_owner}/{repo_name} from {repo_url}", args.debug)
                
                # Ensure organization exists
                orgs = get_organizations(token, args.debug)
                if repo_owner not in orgs:
                    debug_log(f"Creating organization: {repo_owner}", args.debug)
                    if not create_organization(repo_owner, token, args.debug):
                        debug_log(f"Failed to create organization: {repo_owner}", args.debug)
                        failed_repos.append(repo_url)
                        continue
                
                # Migrate the repository
                if migrate_repository(repo_url, service, repo_owner, repo_name, token, args.debug):
                    success_count += 1
                    debug_log(f"Successfully archived: {repo_owner}/{repo_name}", args.debug)
                else:
                    failed_repos.append(repo_url)
                    debug_log(f"Failed to archive: {repo_owner}/{repo_name}", args.debug)
            
            # Report results
            if args.debug:
                print(f"\nArchiving complete: {success_count}/{len(repo_urls)} repositories archived successfully", file=sys.stderr)
                if failed_repos:
                    print(f"Failed repositories:", file=sys.stderr)
                    for repo in failed_repos:
                        print(f"  - {repo}", file=sys.stderr)
            
            sys.exit(0 if success_count > 0 else 1)
            
        else:
            # Single repository mode
            # Parse repository information
            default_owner, repo_name = parse_repo_info(args.url, args.debug)
            if not repo_name:
                print("Error: Cannot parse repository name from URL", file=sys.stderr)
                sys.exit(1)
            
            # Determine repo owner
            repo_owner = args.org if args.org else default_owner
            if not repo_owner:
                print("Error: Cannot determine repository owner. Please specify with --org", file=sys.stderr)
                sys.exit(1)
            
            debug_log(f"Repository details - Service: {service}, Owner: {repo_owner}, Name: {repo_name}", args.debug)
            
            # Check if organization exists
            orgs = get_organizations(token, args.debug)
            if repo_owner not in orgs:
                debug_log(f"Organization '{repo_owner}' not found, creating it", args.debug)
                if not create_organization(repo_owner, token, args.debug):
                    print(f"Error: Failed to create organization: {repo_owner}", file=sys.stderr)
                    sys.exit(1)
            else:
                debug_log(f"Organization '{repo_owner}' already exists", args.debug)
            
            # Migrate the repository
            success = migrate_repository(args.url, service, repo_owner, repo_name, token, args.debug)
            
            if success:
                debug_log("Repository archived successfully", args.debug)
                sys.exit(0)
            else:
                print("Error: Failed to migrate repository", file=sys.stderr)
                sys.exit(1)
            
    except Exception as e:
        if args.debug:
            print(f"Error: {e}", file=sys.stderr)
            traceback.print_exc()
        else:
            print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
