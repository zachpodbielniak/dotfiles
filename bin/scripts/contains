#!/usr/bin/bash
# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail

usage () {
	cat << 'EOF'
contains - Check if stdin contains a pattern

USAGE:
	contains [OPTIONS] PATTERN

OPTIONS:
	-h, --help           Show this help message
	--license            Show license information
	-i, --ignore-case    Case-insensitive matching
	-v, --invert         Exit 0 if pattern is NOT found
	-w, --word           Match whole words only
	-r, --regex          Treat pattern as regular expression

EXAMPLES:
	echo "hello world" | contains "world" && echo "Found"
	echo "Hello World" | contains -i "world" && echo "Found (case insensitive)"
	echo "hello world" | contains -v "foo" && echo "Not found"
	echo "hello world" | contains -w "wor" || echo "Not a whole word"
	echo "hello123" | contains -r "hello[0-9]+" && echo "Regex match"

DESCRIPTION:
	Exit code 0 if pattern is found in stdin.
	Exit code 1 if pattern is NOT found.

EOF
}

if [[ $# -lt 1 ]]; then
	usage >&2
	exit 1
fi

ignore_case=false
invert=false
word_boundary=false
use_regex=false
pattern=""

# Parse options
while [[ $# -gt 0 ]]; do
	case "$1" in
		-h|--help)
			usage
			exit 0
			;;
		--license)
			echo "AGPLv3"
			exit 0
			;;
		-i|--ignore-case)
			ignore_case=true
			shift
			;;
		-v|--invert)
			invert=true
			shift
			;;
		-w|--word)
			word_boundary=true
			shift
			;;
		-r|--regex)
			use_regex=true
			shift
			;;
		-*)
			echo "contains: unknown option: $1" >&2
			exit 1
			;;
		*)
			pattern="$1"
			shift
			;;
	esac
done

if [[ -z "$pattern" ]]; then
	echo "contains: pattern required" >&2
	exit 1
fi

# Read all stdin
content=$(cat 2>/dev/null)

found=false

if [[ "$use_regex" == "true" ]]; then
	# Use regex matching
	if [[ "$ignore_case" == "true" ]]; then
		[[ "$content" =~ ^(.*)${pattern}(.*)$ ]] && found=true || true
	else
		[[ "$content" =~ ^(.*)${pattern}(.*)$ ]] && found=true || true
	fi
else
	# Use literal matching
	if [[ "$word_boundary" == "true" ]]; then
		# Word boundary: use grep -w
		if [[ "$ignore_case" == "true" ]]; then
			echo "$content" | grep -qiw "$pattern" && found=true || true
		else
			echo "$content" | grep -qw "$pattern" && found=true || true
		fi
	else
		# Literal substring matching
		if [[ "$ignore_case" == "true" ]]; then
			# Case insensitive: convert to lowercase and search
			[[ "${content,,}" == *"${pattern,,}"* ]] && found=true || true
		else
			[[ "$content" == *"$pattern"* ]] && found=true || true
		fi
	fi
fi

# Apply invert flag
if [[ "$invert" == "true" ]]; then
	if [[ "$found" == "false" ]]; then
		exit 0
	else
		exit 1
	fi
else
	if [[ "$found" == "true" ]]; then
		exit 0
	else
		exit 1
	fi
fi
