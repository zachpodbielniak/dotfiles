#!/usr/bin/python3

from os import environ
from subprocess import run
from sys import argv, exit, stdin, stderr
import argparse
import json
import requests
import sys


ctr_id: str|None = ""
api_key: str|None = ""

if ("CONTAINER_ID" in environ):
    ctr_id = environ.get("CONTAINER_ID")

# if we are not in the 'dev' distrobox re-exec the script
# inside of the 'dev' distrobox
if ("dev" != ctr_id):
    cmd: list[str] = [
        "distrobox",
        "enter",
        "dev",
        "--",
        *argv
    ]

    run(cmd)
    exit(0)

if ("CLAUDE_API_KEY" in environ):
    api_key = environ.get("CLAUDE_API_KEY")
else:
    print("CLAUDE_API_KEY is not set")
    exit(1)

# Parse arguments
parser = argparse.ArgumentParser(description="Query Claude API")
parser.add_argument("--prompt", help="Prompt to prepend to the input")
parser.add_argument("--model", default="claude-sonnet-4-20250514",
                    help="Model to use (default: claude-sonnet-4-20250514). Available models: claude-opus-4-20250514, claude-sonnet-4-20250514, claude-sonnet-4-0, claude-opus-4-0, claude-3-7-sonnet-latest, claude-3-5-sonnet-latest, claude-3-5-haiku-latest, claude-3-opus-latest, claude-3-sonnet-20240229, claude-3-haiku-20240307")
parser.add_argument("--debug", action="store_true", help="Enable debug mode (shows request details)")
parser.add_argument("--json", action="store_true", help="Return a clean JSON response without streaming")
parser.add_argument("--embedding", action="store_true", help="Generate an embedding vector instead of a text response")
args = parser.parse_args()

# Since outside of the distrobox we may not have these modules
# quietly ignore the fact that they may not exist
try:
    # Read from standard input
    query = stdin.read()

    # Prepend prompt if provided
    if args.prompt:
        if query:
            query = f"{args.prompt}\n\n{query}"
        else:
            query = args.prompt

    # Set up API call
    headers = {
        "x-api-key": api_key,
        "anthropic-version": "2023-06-01",
        "content-type": "application/json"
    }

    # Set the API endpoint based on the request type
    if args.embedding:
        # Use the embeddings API for Claude
        url = "https://api.anthropic.com/v1/embeddings"
        data = {
            "model": "claude-3-haiku-20240307", # Claude embedding model
            "input": query,
            "encoding_format": "float"
        }
    else:
        # Use the messages API for regular requests
        url = "https://api.anthropic.com/v1/messages"
        data = {
            "model": args.model,
            "max_tokens": 4096,
            "messages": [
                {
                    "role": "user",
                    "content": query
                }
            ],
            # Stream if not in JSON mode
            "stream": not args.json
        }

    # Print debug info if requested
    if args.debug:
        print(f"Debug: API URL: {url}", file=sys.stderr)
        print(f"Debug: Headers (API key partially hidden): {{'x-api-key': '{api_key[:5]}...{api_key[-4:]}', 'anthropic-version': '2023-06-01', 'content-type': 'application/json'}}", file=sys.stderr)
        print(f"Debug: Data: {json.dumps(data)}", file=sys.stderr)

    # Send request to Claude API
    response = requests.post(url, headers=headers, json=data, stream=data.get("stream", False))

    if response.status_code != 200:
        print(f"Error: {response.status_code}")
        print(response.text)
        exit(1)
    
    # Handle the response based on request type
    if args.embedding:
        # Process embeddings response (never streamed)
        response_data = response.json()
        if "embedding" in response_data:
            # Extract and output just the embedding vector in JSON format
            embedding = response_data["embedding"]
            print(json.dumps({"embedding": embedding}))
        else:
            print(json.dumps(response_data))
    elif args.json:
        # Process standard JSON response (not streamed)
        response_data = response.json()
        # Extract the message content
        if "content" in response_data and len(response_data["content"]) > 0:
            for block in response_data["content"]:
                if block["type"] == "text":
                    print(block["text"])
        else:
            # Just print the raw response as fallback
            print(json.dumps(response_data))
    else:
        # Process streaming response
        for line in response.iter_lines():
            if line:
                line_text = line.decode('utf-8')
                if line_text.startswith("data: "):
                    line_json = line_text[6:]
                    
                    # The last message is usually "data: [DONE]"
                    if line_json == "[DONE]":
                        break
                        
                    try:
                        event = json.loads(line_json)
                        # Extract content delta if it exists
                        if "delta" in event and "text" in event["delta"]:
                            print(event["delta"]["text"], end="", flush=True)
                    except json.JSONDecodeError:
                        continue

except (ImportError, Exception) as e:
    print(f"Error: {e}")
    exit(1)