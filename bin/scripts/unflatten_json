#!/usr/bin/env python3

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""Unflatten JSON from dot-notation keys to nested structures."""

import sys
import json
import argparse
from typing import Any, Dict, Union


def unflatten_dict(flat: Dict[str, Any], sep: str = ".") -> Dict[str, Any]:
	"""Unflatten a dictionary with dot-notation keys to nested structure.

	Args:
		flat: Flattened dictionary with dot-notation keys
		sep: Separator used in keys

	Returns:
		Nested dictionary/array structure
	"""
	result: Union[Dict[str, Any], list] = {}

	for key, value in flat.items():
		parts: list[str] = key.split(sep)
		current: Union[Dict[str, Any], list] = result

		for i, part in enumerate(parts[:-1]):
			# Check if this part is numeric (array index)
			is_numeric: bool = part.isdigit()

			if is_numeric:
				# Convert current dict to list if needed
				if isinstance(current, dict):
					# Try to convert dict to array
					if not current:  # Empty dict
						current = []
						# Update parent reference
						parent_key: str = parts[i - 1] if i > 0 else None
						if parent_key:
							# Find parent and update
							parent: Union[Dict[str, Any], list] = result
							for p in parts[:i-1]:
								if isinstance(parent, list):
									parent = parent[int(p)]
								else:
									parent = parent[p]
							if isinstance(parent, dict):
								parent[parent_key] = current
					else:
						current = list(current.values())

				# Ensure list is large enough
				idx: int = int(part)
				if isinstance(current, list):
					while len(current) <= idx:
						current.append({})
					if isinstance(current[idx], dict) and not current[idx]:
						# Keep as dict unless we know it's an array
						pass
					current = current[idx]
				else:
					if part not in current:
						current[part] = {}
					current = current[part]
			else:
				# Non-numeric key (object property)
				if isinstance(current, list):
					# Shouldn't happen in well-formed flat dicts
					pass
				elif part not in current:
					# Decide if next level should be array or object
					next_part: str = parts[i + 1] if i + 1 < len(parts) - 1 else None
					if next_part and next_part.isdigit():
						current[part] = []
					else:
						current[part] = {}
				current = current[part]

		# Set the final value
		final_key: str = parts[-1]
		if isinstance(current, list):
			idx: int = int(final_key)
			while len(current) <= idx:
				current.append(None)
			current[idx] = value
		else:
			current[final_key] = value

	return result


def main() -> int:
	"""Main function."""
	parser = argparse.ArgumentParser(
		prog="unflatten_json",
		description="Unflatten JSON from dot-notation keys to nested structure",
	)
	parser.add_argument(
		"--separator",
		default=".",
		help="Key separator (default: .)",
	)
	parser.add_argument(
		"--license",
		action="store_true",
		help="Show license information",
	)

	args = parser.parse_args()

	if args.license:
		print("AGPLv3")
		return 0

	try:
		# Read JSON from stdin
		json_input: str = sys.stdin.read()
		data: Dict[str, Any] = json.loads(json_input)

		# Unflatten the data
		unflattened: Dict[str, Any] = unflatten_dict(data, sep=args.separator)

		# Output as JSON
		json_output: str = json.dumps(unflattened)
		sys.stdout.write(json_output + "\n")

		return 0

	except json.JSONDecodeError as e:
		print(f"Error: Invalid JSON input: {e}", file=sys.stderr)
		return 1
	except Exception as e:
		print(f"Error: {e}", file=sys.stderr)
		return 1


if __name__ == "__main__":
	sys.exit(main())
