#!/bin/bash
set -euo pipefail

#------------------------------------------------------------------------------
# ntom - Neorg to Markdown converter
#------------------------------------------------------------------------------
# 
# This script converts Neorg formatted text to Markdown format.
# It processes input line by line and handles various Neorg elements,
# converting them to their Markdown equivalents.
#
# Features:
# - Headers: Converts * headers to # headers (Markdown format)
# - Lists: Keeps - lists, converts # lists to 1. lists
# - Task Lists: Converts ( ) and (x) to [ ] and [x]
# - Code Blocks: Converts @code lang and @end to triple backtick blocks
# - Block Quotes: Converts @quote blocks to > text
# - Tables: Passes tables through with appropriate wrapping
# - Inline formatting: *bold* -> **bold**, /italic/ -> *italic*
# - Links: {(url)}[text] -> [text](url)
# - Images: {(url)}[image: alt] -> ![alt](url)
# - Horizontal Rules: --- -> ---
#
# Known bugs:
# - Complex nested formatting might not always convert correctly
# - Links may have issues with proper URL formatting
# - Bold and italic formatting conversions might not be consistent
# - Regular expressions for pattern matching are limited in handling edge cases

usage() {
    # Display usage information and exit
    echo "Usage: $(basename "$0") [OPTIONS]"
    echo "Convert Neorg to Markdown format"
    echo ""
    echo "Options:"
    echo "  -i, --input FILE   Read input from FILE (default: stdin)"
    echo "  -o, --output FILE  Write output to FILE (default: stdout)"
    echo "  -h, --help         Display this help message and exit"
    echo ""
    echo "Examples:"
    echo "  $(basename "$0") -i input.norg -o output.md"
    echo "  cat input.norg | $(basename "$0") > output.md"
    echo "  $(basename "$0") < input.norg > output.md"
    exit 1
}

#------------------------------------------------------------------------------
# Command line arguments parsing
#------------------------------------------------------------------------------
# Initialize variables for input and output files
input=""
output=""

# Process command-line options
while [[ $# -gt 0 ]]; do
    case "$1" in
        -i|--input)
            # Handle input file parameter
            if [[ -n "${2:-}" ]]; then
                input="$2"
                shift 2
            else
                echo "Error: Argument for $1 is missing" >&2
                usage
            fi
            ;;
        -o|--output)
            # Handle output file parameter
            if [[ -n "${2:-}" ]]; then
                output="$2"
                shift 2
            else
                echo "Error: Argument for $1 is missing" >&2
                usage
            fi
            ;;
        -h|--help)
            # Show help and exit
            usage
            ;;
        *)
            # Catch any unrecognized options
            echo "Error: Unknown option: $1" >&2
            usage
            ;;
    esac
done

#------------------------------------------------------------------------------
# Main conversion function
#------------------------------------------------------------------------------
neorg_to_markdown() {
    # This function processes Neorg input line by line, converting each element
    # to its Markdown equivalent. It handles block elements (headers, lists, code blocks,
    # quotes, tables) and inline formatting (bold, italic, links, images).
    
    # State tracking variables for multi-line blocks
    local in_code_block=0  # Flag: currently inside a code block (0=no, 1=yes)
    local in_quote_block=0 # Flag: currently inside a blockquote (0=no, 1=yes)
    local in_table=0       # Flag: currently inside a table (0=no, 1=yes)
    local code_lang=""     # Store language of current code block if any
    local list_count=0     # Counter for converting # lists to numbered lists
    local list_indent=""   # Track indentation for lists
    
    # Main processing loop - reads input line by line with proper EOF handling
    # The || [[ -n "$line" ]] part ensures the last line is processed even without a newline
    while IFS= read -r line || [[ -n "$line" ]]; do
        #----------------------------------------------------------------------
        # Block Tag Processing
        #----------------------------------------------------------------------
        # Handle Neorg block tags (@code, @quote, @table, @end)
        
        # Code block start: @code [lang]
        if [[ "$line" =~ ^[[:space:]]*@code ]]; then
            # Extract language if present
            code_lang=$(echo "$line" | sed -E 's/^[[:space:]]*@code[[:space:]]*([^[:space:]]*).*/\1/')
            if [[ -n "$code_lang" ]]; then
                printf '```%s\n' "$code_lang"
            else
                printf '```\n'
            fi
            in_code_block=1
            continue
        fi
        
        # Quote block start: @quote
        if [[ "$line" =~ ^[[:space:]]*@quote[[:space:]]*$ ]]; then
            in_quote_block=1
            continue
        fi
        
        # Table block start: @table
        if [[ "$line" =~ ^[[:space:]]*@table[[:space:]]*$ ]]; then
            in_table=1
            continue
        fi
        
        # Block end: @end
        if [[ "$line" =~ ^[[:space:]]*@end[[:space:]]*$ ]]; then
            if [[ $in_code_block -eq 1 ]]; then
                printf '```\n'
                in_code_block=0
                code_lang=""
            elif [[ $in_quote_block -eq 1 ]]; then
                in_quote_block=0
            elif [[ $in_table -eq 1 ]]; then
                in_table=0
            fi
            continue
        fi
        
        # If inside a code block, pass content through unchanged
        if [[ $in_code_block -eq 1 ]]; then
            echo "$line"
            continue
        fi
        
        # If inside a quote block, prefix with >
        if [[ $in_quote_block -eq 1 ]]; then
            echo "> $line"
            continue
        fi
        
        # If inside a table, pass content through unchanged
        if [[ $in_table -eq 1 ]]; then
            echo "$line"
            continue
        fi
        
        #----------------------------------------------------------------------
        # Header Processing
        #----------------------------------------------------------------------
        # Convert Neorg headers (* Style) to Markdown headers (# Style)
        # The number of * or # indicates the heading level
        
        # We need to match patterns like "* Heading", "** Heading", etc.
        # Check for headings from most specific (most asterisks) to least
        if [[ "$line" =~ ^[[:space:]]*\*{6}[[:space:]] ]]; then
            # Level 6 heading: ****** Heading -> ###### Heading
            local content="${line#*\*\*\*\*\*\* }"
            echo "###### $content"
            continue
        elif [[ "$line" =~ ^[[:space:]]*\*{5}[[:space:]] ]]; then
            # Level 5 heading: ***** Heading -> ##### Heading
            local content="${line#*\*\*\*\*\* }"
            echo "##### $content"
            continue
        elif [[ "$line" =~ ^[[:space:]]*\*{4}[[:space:]] ]]; then
            # Level 4 heading: **** Heading -> #### Heading
            local content="${line#*\*\*\*\* }"
            echo "#### $content"
            continue
        elif [[ "$line" =~ ^[[:space:]]*\*{3}[[:space:]] ]]; then
            # Level 3 heading: *** Heading -> ### Heading
            local content="${line#*\*\*\* }"
            echo "### $content"
            continue
        elif [[ "$line" =~ ^[[:space:]]*\*{2}[[:space:]] ]]; then
            # Level 2 heading: ** Heading -> ## Heading
            local content="${line#*\*\* }"
            echo "## $content"
            continue
        elif [[ "$line" =~ ^[[:space:]]*\*{1}[[:space:]] ]]; then
            # Level 1 heading: * Heading -> # Heading (Markdown format)
            local content="${line#*\* }"
            echo "# $content"
            continue
        fi
        
        #----------------------------------------------------------------------
        # Task List Processing
        #----------------------------------------------------------------------
        # Convert Neorg task list items to Markdown format
        # Neorg: - ( ) Task Item -> Markdown: - [ ] Task Item
        # Neorg: - (x) Task Item -> Markdown: - [x] Task Item
        if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*\([[:space:]]\)[[:space:]] ]]; then
            # Unchecked task: - ( ) Task -> - [ ] Task
            local indent=$(echo "$line" | sed -E 's/^([[:space:]]*)-.*/\1/')
            local content=$(echo "$line" | sed -E 's/^[[:space:]]*-[[:space:]]*\([[:space:]]\)[[:space:]]*(.*)/\1/')
            echo "${indent}- [ ] ${content}"
            continue
        elif [[ "$line" =~ ^[[:space:]]*-[[:space:]]*\(x\)[[:space:]] ]]; then
            # Checked task: - (x) Task -> - [x] Task
            local indent=$(echo "$line" | sed -E 's/^([[:space:]]*)-.*/\1/')
            local content=$(echo "$line" | sed -E 's/^[[:space:]]*-[[:space:]]*\(x\)[[:space:]]*(.*)/\1/')
            echo "${indent}- [x] ${content}"
            continue
        fi
        
        #----------------------------------------------------------------------
        # List Processing
        #----------------------------------------------------------------------
        # Handle both unordered (-) and ordered (# lists)
        if [[ "$line" =~ ^[[:space:]]*-[[:space:]] ]]; then
            # Unordered list items: Neorg uses -, Markdown also uses -
            # Pass unordered list items through unchanged
            echo "$line"
            continue
        elif [[ "$line" =~ ^[[:space:]]*#[[:space:]] ]]; then
            # Ordered list items: # Item -> 1. Item (Markdown format)
            local indent=$(echo "$line" | sed -E 's/^([[:space:]]*).*$/\1/')
            local content=$(echo "$line" | sed -E 's/^[[:space:]]*#[[:space:]]*(.*)/\1/')
            
            # Handle list numbers - track by indentation level
            if [[ "$indent" != "$list_indent" ]]; then
                # Reset counter for new indentation level
                list_count=1
                list_indent="$indent"
            else
                ((list_count++))
            fi
            
            # Output in Markdown format
            echo "${indent}${list_count}. ${content}"
            continue
        fi
        
        #----------------------------------------------------------------------
        # Horizontal Rule - pass through unchanged
        #----------------------------------------------------------------------
        if [[ "$line" =~ ^[[:space:]]*---+[[:space:]]*$ ]]; then
            echo "---"
            continue
        fi
        
        #----------------------------------------------------------------------
        # Empty Line Handling
        #----------------------------------------------------------------------
        # Pass empty lines through unchanged - both formats use empty lines similarly
        if [[ -z "$line" ]]; then
            echo ""
            continue
        fi
        
        # Process inline formatting with a more reliable approach
        processed_line="$line"
        
        # Links: {(url)}[text] -> [text](url)
        processed_line=$(echo "$processed_line" | sed 's/{(\([^)]*\))}\[\([^]]*\)\]/[\2](\1)/g')
        
        # Handle image links
        processed_line=$(echo "$processed_line" | sed 's/!{(\([^)]*\))}\[\([^]]*\)\]/![\2](\1)/g')
        
        # Bold and italic combined: */text/* -> ***text***
        processed_line=$(echo "$processed_line" | sed 's/\*\/\([^*]*\)\/\*/***\1***/g')
        
        # Bold: *text* -> **text**
        processed_line=$(echo "$processed_line" | sed 's/\*\([^*/][^*]*\)\*/\*\*\1\*\*/g')
        
        # Italic: /text/ -> *text*
        processed_line=$(echo "$processed_line" | sed 's/\/\([^/]*\)\//\*\1\*/g')
        
        # Strikethrough: -text- -> ~~text~~
        processed_line=$(echo "$processed_line" | sed 's/-\([^-]*\)-/~~\1~~/g')
        
        echo "$processed_line"
    done
}

#------------------------------------------------------------------------------
# Main Program Execution
#------------------------------------------------------------------------------
# Handle the four possible combinations of input/output:
# 1. Input file → Output file
# 2. Input file → Stdout
# 3. Stdin → Output file
# 4. Stdin → Stdout

if [[ -n "$input" ]]; then
    # Input from file
    if [[ ! -f "$input" ]]; then
        # Error handling: Ensure input file exists
        echo "Error: Input file '$input' does not exist" >&2
        exit 1
    fi
    
    if [[ -n "$output" ]]; then
        # Case 1: Input file → Output file
        cat "$input" | neorg_to_markdown > "$output"
    else
        # Case 2: Input file → Stdout
        cat "$input" | neorg_to_markdown
    fi
else
    # Input from stdin
    if [[ -n "$output" ]]; then
        # Case 3: Stdin → Output file
        neorg_to_markdown > "$output"
    else
        # Case 4: Stdin → Stdout
        neorg_to_markdown
    fi
fi

# Exit with success status
exit 0