#!/usr/bin/env perl

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;

#------------------------------------------------------------------------------
# ntom_ast - AST-based Neorg to Markdown converter
#------------------------------------------------------------------------------
# 
# This script converts Neorg formatted text to Markdown format.
# It uses a block-by-block approach to handle Neorg structures.

# Options
my $input_file = '';
my $output_file = '';
my $help = 0;
my $debug = 0;

# Process command line arguments
GetOptions(
    "input|i=s" => \$input_file,
    "output|o=s" => \$output_file,
    "help|h" => \$help,
    "debug|d" => \$debug
) or pod2usage(1);

pod2usage(1) if $help;

# Set up input/output filehandles
my $input_fh = $input_file ? do { open my $fh, '<', $input_file or die "Can't open $input_file: $!"; $fh } : \*STDIN;
my $output_fh = $output_file ? do { open my $fh, '>', $output_file or die "Can't open $output_file for writing: $!"; $fh } : \*STDOUT;

# Read the entire input
my $input = do { local $/; <$input_fh> };

# Parse blocks
my @blocks = split_into_blocks($input);
my $output = '';

foreach my $block (@blocks) {
    $output .= process_block($block);
}

# Write output
print $output_fh $output;

# Close filehandles
close($input_fh) if $input_file;
close($output_fh) if $output_file;

exit 0;

#------------------------------------------------------------------------------
# Parsing Functions
#------------------------------------------------------------------------------
sub split_into_blocks {
    my ($text) = @_;
    my @blocks;
    my $current_block = '';
    my $in_tag_block = 0;
    my $current_tag = '';
    
    # Extract document metadata if present
    my $metadata = '';
    if ($text =~ s/^(\@document\.meta(?:.*?)^\@end)//ms) {
        $metadata = $1;
        push @blocks, $metadata;
    }
    
    # Normalize line endings
    $text =~ s/\r\n/\n/g;
    $text =~ s/\r/\n/g;
    
    foreach my $line (split /\n/, $text) {
        # Handle tagged blocks like @code, @quote, etc.
        if ($line =~ /^\@(\w+)(?:\s+(.*))?$/ && !$in_tag_block) {
            # Start of a tagged block
            push @blocks, $current_block if $current_block =~ /\S/;
            $current_block = $line . "\n";
            $in_tag_block = 1;
            $current_tag = $1;
            next;
        }
        
        # End of tagged block
        if ($line =~ /^\@end/ && $in_tag_block) {
            $current_block .= $line . "\n";
            push @blocks, $current_block;
            $current_block = '';
            $in_tag_block = 0;
            $current_tag = '';
            next;
        }
        
        # Inside tagged block - collect lines
        if ($in_tag_block) {
            $current_block .= $line . "\n";
            next;
        }
        
        # Headers (*, **, etc.)
        if ($line =~ /^(\*+)\s+(.+)$/) {
            push @blocks, $current_block if $current_block =~ /\S/;
            $current_block = $line . "\n";
            push @blocks, $current_block;
            $current_block = '';
            next;
        }
        
        # Empty line - end current block
        if ($line =~ /^\s*$/) {
            push @blocks, $current_block if $current_block =~ /\S/;
            $current_block = '';
            next;
        }
        
        # List detection - group consecutive list items
        if ($line =~ /^(\s*)(?:-|\#)\s+/) {
            my $indent = $1 || '';
            # If current block is not a list or has different indentation, start new block
            if ($current_block !~ /^(\s*)(?:-|\#)\s+/ || length($1 || '') != length($indent)) {
                push @blocks, $current_block if $current_block =~ /\S/;
                $current_block = $line . "\n";
            } else {
                # Continue the list
                $current_block .= $line . "\n";
            }
            next;
        }
        
        # Definition list term
        if ($line =~ /^\$\s+/) {
            push @blocks, $current_block if $current_block =~ /\S/;
            $current_block = $line . "\n";
            next;
        }
        
        # Definition list content (indented lines after a term)
        if ($line =~ /^\s+\S/ && $current_block =~ /^\$\s+/) {
            $current_block .= $line . "\n";
            next;
        }
        
        # Horizontal rule
        if ($line =~ /^---+$/) {
            push @blocks, $current_block if $current_block =~ /\S/;
            $current_block = $line . "\n";
            push @blocks, $current_block;
            $current_block = '';
            next;
        }
        
        # Add to current block for regular paragraphs
        if ($current_block =~ /\S/ && $current_block !~ /^\s*$/) {
            $current_block .= $line . "\n";
        } else {
            $current_block = $line . "\n";
        }
    }
    
    # Add the last block if any
    push @blocks, $current_block if $current_block =~ /\S/;
    
    return @blocks;
}

sub process_block {
    my ($block) = @_;
    my $result = '';
    
    # Trim trailing newlines
    $block =~ s/\n+$//;
    
    # Document metadata
    if ($block =~ /^\@document\.meta(.*?)^\@end$/ms) {
        my $meta = $1;
        $result = "---\n";
        
        # Extract and format key fields for Markdown frontmatter
        if ($meta =~ /title:\s*(.+?)$/m) {
            my $value = $1;
            # Quote value if it contains special characters
            $value = "\"$value\"" if $value =~ /[:"'!@#\$%^&*(){}[\]]/;
            $result .= "title: $value\n";
        }
        
        if ($meta =~ /description:\s*(.+?)$/m) {
            my $value = $1;
            # Quote value if it contains special characters
            $value = "\"$value\"" if $value =~ /[:"'!@#\$%^&*(){}[\]]/;
            $result .= "description: $value\n";
        }
        
        # Handle authors field - convert to singular 'author' for Markdown
        if ($meta =~ /authors?:\s*(.+?)$/m) {
            my $value = $1;
            # Quote value if it contains special characters
            $value = "\"$value\"" if $value =~ /[:"'!@#\$%^&*(){}[\]]/;
            $result .= "author: $value\n";
        }
        
        # Handle categories/tags
        if ($meta =~ /categories:\s*(.+?)$/m) {
            my $value = $1;
            if ($value =~ /,/) {
                # Convert comma-separated list to YAML array
                my @categories = split(/\s*,\s*/, $value);
                $result .= "tags:\n";
                foreach my $cat (@categories) {
                    $result .= "  - $cat\n";
                }
            } else {
                $result .= "tags: [$value]\n";
            }
        }
        
        # Convert created to date for Markdown
        if ($meta =~ /created:\s*(.+?)$/m) {
            my $value = $1;
            $result .= "date: $value\n";
        }
        
        # Handle any version field
        if ($meta =~ /version:\s*(.+?)$/m) {
            my $value = $1;
            $result .= "version: $value\n";
        }
        
        # Handle any additional fields
        $meta =~ s/(title|description|authors?|categories|created|version):\s*.+?$//mg;
        while ($meta =~ /\s*(\w+):\s*(.+?)$/mg) {
            my $key = $1;
            my $value = $2;
            # Quote value if it contains special characters
            $value = "\"$value\"" if $value =~ /[:"'!@#\$%^&*(){}[\]]/;
            $result .= "$key: $value\n";
        }
        
        $result .= "---\n\n";
    }
    # Code blocks
    elsif ($block =~ /^\@code(?:\s+(.+?))?$(.*?)^\@end$/ms) {
        my $lang = $1 || '';
        my $code = $2;
        $code =~ s/^\n//; # Remove leading newline
        $code =~ s/\n$//; # Remove trailing newline
        $result = "```$lang\n$code\n```\n\n";
    }
    # Quotes
    elsif ($block =~ /^\@quote$(.*?)^\@end$/ms) {
        my $content = $1;
        $content =~ s/^\n//; # Remove leading newline
        
        my @lines = split(/\n/, $content);
        foreach my $line (@lines) {
            $result .= "> " . process_inline($line) . "\n";
        }
        $result .= "\n";
    }
    # Tables
    elsif ($block =~ /^\@table$(.*?)^\@end$/ms) {
        my $table_content = $1;
        $table_content =~ s/^\n//; # Remove leading newline
        $table_content =~ s/\n$//; # Remove trailing newline
        $result = "$table_content\n\n";
    }
    # Headings
    elsif ($block =~ /^(\*+)\s+(.+)$/) {
        my $level = length($1);
        my $content = $2;
        $result = ('#' x $level) . ' ' . process_inline($content) . "\n\n";
    }
    # List blocks
    elsif ($block =~ /^(\s*)[-#]/) {
        my @lines = split(/\n/, $block);
        foreach my $line (@lines) {
            # Task list items
            if ($line =~ /^(\s*)-\s+\(([ xX])\)\s+(.+)$/) {
                my $indent = $1 || '';
                my $status = $2 eq 'x' ? 'x' : ' ';
                my $content = $3;
                $result .= "$indent- [$status] " . process_inline($content) . "\n";
            }
            # Unordered list items
            elsif ($line =~ /^(\s*)-\s+(?!\()(.+)$/) {
                my $indent = $1 || '';
                my $content = $2;
                $result .= "$indent- " . process_inline($content) . "\n";
            }
            # Ordered list items
            elsif ($line =~ /^(\s*)#\s+(.+)$/) {
                my $indent = $1 || '';
                my $content = $2;
                $result .= "${indent}1. " . process_inline($content) . "\n";
            }
        }
        $result .= "\n";
    }
    # Definition lists
    elsif ($block =~ /^\$\s+(.+)(?:\n\s+.+)*$/) {
        my @lines = split(/\n/, $block);
        my $term = shift @lines;
        $term =~ s/^\$\s+//;
        $result = "**" . process_inline($term) . "**:\n";
        
        foreach my $line (@lines) {
            if ($line =~ /^\s+(.+)$/) {
                $result .= process_inline($1) . "\n";
            }
        }
        $result .= "\n";
    }
    # Horizontal rule
    elsif ($block =~ /^---+$/) {
        $result = "---\n\n";
    }
    # Default - paragraph
    else {
        $result = process_inline($block) . "\n\n";
    }
    
    return $result;
}

sub process_inline {
    my ($text) = @_;
    
    # Protect and store code spans
    my @code_spans;
    $text =~ s/`([^`]+)`/push @code_spans, $1; "CODE_SPAN_" . $#code_spans . "_"/ge;
    
    # Find and store Neorg links with a custom non-greedy pattern
    my @neorg_links;
    $text =~ s/\{\(([^{}]*(?:\([^()]*\)[^{}]*)*)\)\}\[([^\[\]]*(?:\[[^\[\]]*\][^\[\]]*)*)\]/
        my $url = $1;
        my $desc = $2;
        push @neorg_links, {url => $url, desc => $desc};
        "NEORG_LINK_" . $#neorg_links . "_"
    /ge;
    
    # Bold+Italic: */text/* -> ***text***
    $text =~ s/\*\/([^*\/]+?)\/\*/***$1***/g;
    
    # Bold: *text* -> **text**
    $text =~ s/\*([^*]+?)\*/**$1**/g;
    
    # Italic: /text/ -> *text*
    $text =~ s/\/([^\/]+?)\//\*$1\*/g;
    
    # Strikethrough: -text- -> ~~text~~
    $text =~ s/\-([^\-]+?)\-/~~$1~~/g;
    
    # Footnotes: ^[id] -> [^id]
    $text =~ s/\^\[([^\]]+?)\]/[^$1]/g;
    
    # Restore links
    $text =~ s/NEORG_LINK_(\d+)_/handle_link($neorg_links[$1]->{url}, $neorg_links[$1]->{desc})/ge;
    
    # Restore code spans
    $text =~ s/CODE_SPAN_(\d+)_/"`" . $code_spans[$1] . "`"/ge;
    
    return $text;
}

sub handle_link {
    my ($url, $text) = @_;
    
    # Handle image links: {(url)}[image: alt]
    if ($text =~ /^image:\s*(.+)/) {
        return "![$1]($url)";
    }
    
    # Regular links: {(url)}[text]
    return "[$text]($url)";
}

sub debug_print {
    my ($message) = @_;
    print STDERR "DEBUG: $message\n" if $debug;
}

__END__

=head1 NAME

ntom_ast - AST-based Neorg to Markdown converter

=head1 SYNOPSIS

ntom_ast [options]

 Options:
   -i, --input FILE    Read input from FILE (default: stdin)
   -o, --output FILE   Write output to FILE (default: stdout)
   -h, --help          Display this help message and exit
   -d, --debug         Enable debug output for diagnostics

 Examples:
   ntom_ast -i input.norg -o output.md
   cat input.norg | ntom_ast > output.md
   ntom_ast < input.norg > output.md

=head1 DESCRIPTION

This script converts Neorg formatted text to Markdown format.
It uses a block-based approach to handle Neorg structures.

Features:
 - Headers: Converts * headers to # headers (Markdown format)
 - Lists: Converts # lists to 1. lists, and keeps - lists unchanged
 - Task Lists: Converts ( ) and (x) to [ ] and [x]
 - Code Blocks: Converts @code lang...@end to ```lang...```
 - Block Quotes: Converts @quote...@end to > text
 - Tables: Preserves table formatting
 - Inline formatting: *bold* -> **bold**, /italic/ -> *italic*
 - Links: {(url)}[text] -> [text](url)
 - Images: {(url)}[image: alt] -> ![alt](url)
 - Footnotes: ^[id] -> [^id]
 - Horizontal Rules: preserved as is
 - Document metadata: Converts to YAML frontmatter

=head1 AUTHOR

Zach Podbielniak

=cut
