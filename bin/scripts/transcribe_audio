#!/usr/bin/python3

import os
import sys
import subprocess
from pathlib import Path

# Container check for distrobox - do this BEFORE any other imports
# Check if we need psycopg2 (not using --no-store-db)
if '--no-store-db' not in sys.argv:
    ctr_id = os.environ.get("CONTAINER_ID", "")
    no_dbox_check = os.environ.get("NO_DBOX_CHECK", "").lower() in ("1", "true")
    if not no_dbox_check and ctr_id != "dev":
        cmd = ["distrobox", "enter", "dev", "--", *sys.argv]
        subprocess.run(cmd)
        sys.exit(0)

# Now import everything else
try:
    import argparse
    import hashlib
    import json
    import tempfile
    from datetime import datetime
    import yaml
    from typing import Optional, List, Tuple
    import uuid
    
    # Only import psycopg2 if we're going to use the database
    if '--no-store-db' not in sys.argv:
        import psycopg2
        from psycopg2.extras import Json, execute_values
except ImportError as e:
    # We're inside dev container but missing dependencies
    print(f"Error: Missing required Python module: {e}", file=sys.stderr)
    print("Please install the required dependencies:", file=sys.stderr)
    print("  pip install psycopg2-binary pyyaml", file=sys.stderr)
    sys.exit(1)

# Configuration file path
CONFIG_FILE = Path.home() / ".config/transcription_db/config.yaml"

# Default configuration
DEFAULT_CONFIG = {
    'database': {
        'host': '127.0.0.1',
        'port': 5432,
        'name': 'transcriptions',
        'user': 'postgres',
        'password': ''
    },
    'transcription': {
        'chunk_size': 1048576,
        'whisper_model_path': str(Path.home() / "Source/Public/whisper.cpp/models"),
        'whisper_bin_path': str(Path.home() / "Source/Public/whisper.cpp/build/bin/whisper-cli")
    }
}

# Deep merge function to handle nested configs
def deep_merge(default, override):
    """Recursively merge override dict into default dict"""
    result = default.copy()
    for key, value in override.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = deep_merge(result[key], value)
        else:
            result[key] = value
    return result

# Load configuration
config = DEFAULT_CONFIG.copy()

# Load from YAML config if available
if CONFIG_FILE.exists():
    try:
        with open(CONFIG_FILE, 'r') as f:
            loaded_config = yaml.safe_load(f)
            if loaded_config:
                config = deep_merge(config, loaded_config)
    except Exception:
        pass  # Use defaults if config can't be loaded

# Environment variables override config
DB_CONFIG = {
    'host': os.environ.get('TRANSCRIPTION_DB_HOST', config.get('database', {}).get('host', '127.0.0.1')),
    'port': int(os.environ.get('TRANSCRIPTION_DB_PORT', config.get('database', {}).get('port', 5432))),
    'database': os.environ.get('TRANSCRIPTION_DB_NAME', config.get('database', {}).get('name', 'transcriptions')),
    'user': os.environ.get('TRANSCRIPTION_DB_USER', config.get('database', {}).get('user', 'postgres')),
    'password': os.environ.get('TRANSCRIPTION_DB_PASSWORD', config.get('database', {}).get('password', ''))
}

CHUNK_SIZE = int(os.environ.get('TRANSCRIPTION_CHUNK_SIZE', config.get('transcription', {}).get('chunk_size', 1048576)))
WHISPER_MODEL_PATH = os.path.expandvars(config.get('transcription', {}).get('whisper_model_path', str(Path.home() / "Source/Public/whisper.cpp/models")))
WHISPER_BIN = os.path.expandvars(config.get('transcription', {}).get('whisper_bin_path', str(Path.home() / "Source/Public/whisper.cpp/build/bin/whisper-cli")))


class TranscriptionProcessor:
    def __init__(self):
        self.conn = None
        self.cursor = None
        
    def connect_db(self):
        """Establish database connection"""
        try:
            self.conn = psycopg2.connect(**DB_CONFIG)
            self.cursor = self.conn.cursor()
            return True
        except psycopg2.Error as e:
            print(f"Database connection failed: {e}", file=sys.stderr)
            return False
    
    def disconnect_db(self):
        """Close database connection"""
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()
    
    def calculate_file_hash(self, filepath: str) -> str:
        """Calculate SHA256 hash of file"""
        sha256_hash = hashlib.sha256()
        with open(filepath, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
    
    def get_audio_duration(self, filepath: str) -> int:
        """Get audio duration in seconds using ffprobe"""
        try:
            result = subprocess.run(
                ['ffprobe', '-v', 'error', '-show_entries', 'format=duration',
                 '-of', 'default=noprint_wrappers=1:nokey=1', filepath],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                return int(float(result.stdout.strip()))
        except Exception:
            pass
        return 0
    
    def transcription_exists(self, file_hash: str) -> Optional[str]:
        """Check if transcription already exists, return UUID if it does"""
        try:
            self.cursor.execute(
                "SELECT id FROM transcriptions WHERE file_hash = %s",
                (file_hash,)
            )
            result = self.cursor.fetchone()
            return str(result[0]) if result else None
        except psycopg2.Error:
            return None
    
    def split_into_chunks(self, text: str) -> List[str]:
        """Split text into chunks efficiently, preserving timestamped lines"""
        chunks = []
        lines = text.split('\n')
        
        current_chunk = ""
        current_size = 0
        
        for line in lines:
            line_size = len(line) + 1  # +1 for newline
            
            # Check if this line starts with a timestamp pattern [HH:MM:SS
            is_timestamp_line = line.strip().startswith('[') and '-->' in line
            
            # If adding this line would exceed chunk size and we have content
            if current_size + line_size > CHUNK_SIZE and current_chunk:
                # Only split at timestamp boundaries to preserve structure
                if is_timestamp_line:
                    chunks.append(current_chunk.rstrip())
                    current_chunk = line
                    current_size = line_size
                else:
                    # If not a timestamp line, keep adding to preserve context
                    if current_chunk:
                        current_chunk += "\n" + line
                    else:
                        current_chunk = line
                    current_size += line_size
            else:
                if current_chunk:
                    current_chunk += "\n" + line
                else:
                    current_chunk = line
                current_size += line_size
        
        if current_chunk:
            chunks.append(current_chunk.rstrip())
        
        return chunks
    
    def insert_transcription(self, filename: str, file_path: str, file_hash: str,
                           content: str, duration: int, model: str, language: str,
                           type_: Optional[str], tags: Optional[str]) -> Optional[str]:
        """Insert transcription with optimized chunk insertion"""
        try:
            if args.verbose:
                print(f"Inserting transcription: {filename}")
                print(f"Content length: {len(content)} characters")
                print(f"First 100 chars: {content[:100]}...")
            
            # Build metadata
            metadata = {}
            if type_:
                metadata['type'] = type_
            if tags:
                metadata['tags'] = [tag.strip() for tag in tags.split(',')]
            
            # Add source script if called from another script
            parent = psutil.Process(os.getppid()).name() if 'psutil' in sys.modules else None
            if parent and parent != 'bash':
                metadata['source_script'] = parent
            
            # Insert main transcription record
            self.cursor.execute("""
                INSERT INTO transcriptions 
                (filename, file_path, file_hash, duration_seconds, model_used, language, metadata)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
                RETURNING id
            """, (filename, file_path, file_hash, duration, model, language, Json(metadata)))
            
            transcription_id = self.cursor.fetchone()[0]
            
            # Split content into chunks
            chunks = self.split_into_chunks(content)
            
            if args.verbose:
                print(f"Split into {len(chunks)} chunks")
            
            # Prepare chunk data for batch insert
            chunk_data = []
            for i, chunk in enumerate(chunks, 1):
                # Clean chunk content
                chunk_clean = chunk.replace('\x00', '')  # Remove NULL bytes
                chunk_data.append((
                    transcription_id,
                    i,
                    chunk_clean,
                    len(chunk_clean)
                ))
                
                if args.verbose and i == 1:
                    print(f"First chunk length: {len(chunk_clean)}")
                    print(f"First chunk preview: {chunk_clean[:100]}...")
            
            # Batch insert all chunks at once - MUCH faster than individual inserts
            from psycopg2.extras import execute_values
            execute_values(
                self.cursor,
                """
                INSERT INTO transcription_chunks 
                (transcription_id, chunk_number, content, character_count)
                VALUES %s
                """,
                chunk_data
            )
            
            if args.verbose:
                print(f"Successfully inserted {len(chunk_data)} chunks")
            
            self.conn.commit()
            return str(transcription_id)
            
        except psycopg2.Error as e:
            self.conn.rollback()
            print(f"Error inserting transcription: {e}", file=sys.stderr)
            return None
    
    def update_transcription(self, file_hash: str, type_: Optional[str], 
                           tags: Optional[str]) -> Optional[str]:
        """Update existing transcription metadata"""
        try:
            # Get existing transcription
            self.cursor.execute(
                "SELECT id, metadata FROM transcriptions WHERE file_hash = %s",
                (file_hash,)
            )
            result = self.cursor.fetchone()
            if not result:
                print(f"Error: No transcription found with file hash {file_hash}", file=sys.stderr)
                return None
            
            transcription_id, existing_metadata = result
            metadata = existing_metadata or {}
            
            # Update metadata
            if type_:
                metadata['type'] = type_
            if tags:
                metadata['tags'] = [tag.strip() for tag in tags.split(',')]
            
            self.cursor.execute("""
                UPDATE transcriptions 
                SET metadata = %s, updated_at = CURRENT_TIMESTAMP
                WHERE id = %s
            """, (Json(metadata), transcription_id))
            
            self.conn.commit()
            return str(transcription_id)
            
        except psycopg2.Error as e:
            self.conn.rollback()
            print(f"Error updating transcription: {e}", file=sys.stderr)
            return None
    
    def transcribe_file(self, input_file: str, output_dir: Optional[str] = None) -> Optional[str]:
        """Transcribe audio file using whisper, capturing both timestamped and plain text"""
        # Whisper creates output file as input_file + .txt in the same directory
        expected_output = f"{input_file}.txt"
        
        # Run whisper transcription
        cmd = [
            'distrobox', 'enter', 'whisper', '--',
            WHISPER_BIN,
            '-m', f"{WHISPER_MODEL_PATH}/{args.model}",
            '-f', input_file,
            '-otxt'
        ]
        
        try:
            if args.verbose:
                print(f"Running command: {' '.join(cmd)}")
            
            # Capture stdout for timestamped content
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode != 0:
                print("Error: Transcription failed", file=sys.stderr)
                if args.verbose:
                    print(f"Command stderr: {result.stderr}", file=sys.stderr)
                    print(f"Command stdout: {result.stdout}", file=sys.stderr)
                return None
            
            # Extract timestamped content from stdout
            timestamped_content = ""
            for line in result.stdout.split('\n'):
                # Look for lines that start with timestamps like [00:00:00.000 --> 00:00:03.360]
                if line.strip().startswith('[') and '-->' in line and line.strip().endswith(']'):
                    timestamped_content += line + '\n'
            
            # Wait a moment for file to be written
            import time
            time.sleep(0.5)
            
            # Read the plain text transcription result from where whisper puts it
            plain_content = ""
            if os.path.exists(expected_output):
                with open(expected_output, 'r', encoding='utf-8') as f:
                    plain_content = f.read()
                    
                if args.verbose:
                    print(f"Read {len(plain_content)} characters from {expected_output}")
                    print(f"Captured {len(timestamped_content)} characters of timestamped content")
                
                # If output_dir specified, copy to that location
                if output_dir and plain_content:
                    final_output = os.path.join(output_dir, f"{os.path.basename(input_file)}.txt")
                    with open(final_output, 'w', encoding='utf-8') as f:
                        f.write(plain_content)
                
                # Combine both formats: timestamped followed by plain text
                combined_content = ""
                if timestamped_content:
                    combined_content = timestamped_content
                    if plain_content:
                        combined_content += "\n\n--- PLAIN TEXT ---\n\n" + plain_content
                else:
                    # No timestamps captured, just use plain content
                    combined_content = plain_content
                
                return combined_content
            else:
                print(f"Error: Transcription output file not found: {expected_output}", file=sys.stderr)
                # List files in directory for debugging
                if args.verbose:
                    dir_path = os.path.dirname(input_file)
                    print(f"Files in {dir_path}:", file=sys.stderr)
                    for f in os.listdir(dir_path):
                        print(f"  {f}", file=sys.stderr)
                return None
                
        except Exception as e:
            print(f"Error running transcription: {e}", file=sys.stderr)
            return None


def main():
    global args
    
    parser = argparse.ArgumentParser(
        description='Transcribe audio files using Whisper with optional PostgreSQL storage',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ENVIRONMENT VARIABLES:
    TRANSCRIPTION_DB_HOST     Database host (default: 127.0.0.1)
    TRANSCRIPTION_DB_PORT     Database port (default: 5432)
    TRANSCRIPTION_DB_NAME     Database name (default: transcriptions)
    TRANSCRIPTION_DB_USER     Database user (default: postgres)
    TRANSCRIPTION_DB_PASSWORD Database password (default: none)

EXAMPLES:
    # Basic transcription with database storage
    transcribe_audio-ng audio.mp3
    
    # Transcribe with metadata
    transcribe_audio-ng --type meeting --tags "team,standup,2024-q1" audio.mp3
    
    # Skip database storage (legacy mode)
    transcribe_audio-ng --no-store-db audio.mp3
    
    # Update existing transcription metadata
    transcribe_audio-ng --update-db --tags "reviewed,important" audio.mp3
    
    # Database only (no file output)
    transcribe_audio-ng --db-only --type interview candidate.mp3

NOTES:
    - Transcriptions are stored in PostgreSQL by default
    - Use 'local_postgres setup' to initialize the database
    - Large transcriptions are automatically split into chunks
    - Duplicate files (by hash) are detected and skipped
"""
    )
    
    parser.add_argument('audio_file', help='Audio file to transcribe')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('--no-store-db', action='store_true', 
                       help='Do not store transcription in database (default: store)')
    parser.add_argument('--db-only', action='store_true',
                       help='Only store in database, skip file output')
    parser.add_argument('--update-db', action='store_true',
                       help='Update existing transcription metadata')
    parser.add_argument('--type', help='Categorize transcription (e.g., meeting, interview, lecture)')
    parser.add_argument('--tags', help='Comma-separated tags (e.g., "important,client-x,2024-q1")')
    parser.add_argument('--model', default='ggml-base.en.bin',
                       help='Whisper model to use (default: ggml-base.en.bin)')
    parser.add_argument('--output-dir', help='Output directory for transcription files')
    parser.add_argument('--show-only-uuid', action='store_true',
                       help='Output only the transcription UUID (implies --db-only)')
    
    args = parser.parse_args()
    
    # --show-only-uuid implies --db-only
    if args.show_only_uuid:
        args.db_only = True
    
    # Validate input file
    if not os.path.exists(args.audio_file):
        print(f"Error: File not found: {args.audio_file}", file=sys.stderr)
        sys.exit(1)
    
    # Get absolute path
    abs_path = os.path.abspath(args.audio_file)
    basename = os.path.basename(args.audio_file)
    
    # Initialize processor
    processor = TranscriptionProcessor()
    
    # Calculate file hash
    file_hash = processor.calculate_file_hash(abs_path)
    if args.verbose and not args.show_only_uuid:
        print(f"File hash: {file_hash}")
    
    # Check database operations
    db_available = False
    if not args.no_store_db:
        db_available = processor.connect_db()
    
    if db_available:
        # For update mode, just update metadata
        if args.update_db:
            if not args.show_only_uuid:
                print("Updating transcription metadata...")
            transcription_id = processor.update_transcription(file_hash, args.type, args.tags)
            if transcription_id:
                if args.show_only_uuid:
                    print(transcription_id)
                else:
                    print(f"Transcription updated: {transcription_id}")
            processor.disconnect_db()
            sys.exit(0 if transcription_id else 1)
        
        # Check if transcription already exists
        existing_id = processor.transcription_exists(file_hash)
        if existing_id:
            if args.show_only_uuid:
                print(existing_id)
                processor.disconnect_db()
                sys.exit(0)
            else:
                print("Transcription already exists in database for this file")
                print(f"Transcription ID: {existing_id}")
                
                # If db-only mode, we're done
                if args.db_only:
                    processor.disconnect_db()
                    sys.exit(0)
                
                # Otherwise, still generate the file output
                print("Generating file output...")
    
    # Perform transcription
    if not args.show_only_uuid:
        print(f"Transcribing: {basename}")
    
    transcription = processor.transcribe_file(abs_path, args.output_dir)
    if not transcription:
        if not args.show_only_uuid:
            print("Error: Transcription produced no output", file=sys.stderr)
        sys.exit(1)
    
    # Output to file unless in db-only mode
    if not args.db_only:
        output_file = f"{abs_path}.txt"
        if args.output_dir:
            output_file = os.path.join(args.output_dir, f"{basename}.txt")
        
        # Ensure the transcription is saved
        if not os.path.exists(output_file):
            with open(output_file, 'w') as f:
                f.write(transcription)
        
        if not args.show_only_uuid:
            print(f"Transcription saved to: {output_file}")
    
    # Store in database if enabled
    if db_available:
        # Check again if transcription was added while we were transcribing
        existing_id = processor.transcription_exists(file_hash)
        if existing_id:
            if args.show_only_uuid:
                print(existing_id)
            else:
                print("Transcription already exists in database")
                print(f"Transcription ID: {existing_id}")
        else:
            if not args.show_only_uuid:
                print("Storing transcription in database...")
            
            # Get audio duration
            duration = processor.get_audio_duration(abs_path)
            
            # Insert into database
            transcription_id = processor.insert_transcription(
                basename,
                abs_path,
                file_hash,
                transcription,
                duration,
                args.model,
                'en',  # Language hardcoded as 'en' like original
                args.type,
                args.tags
            )
            
            if transcription_id:
                if args.show_only_uuid:
                    print(transcription_id)
                else:
                    print("Transcription stored in database")
                    print(f"Transcription ID: {transcription_id}")
            else:
                if not args.show_only_uuid:
                    print("Warning: Failed to store transcription in database", file=sys.stderr)
                if args.show_only_uuid:
                    sys.exit(1)  # Exit with error if UUID was expected
        
        processor.disconnect_db()
    
    if not args.show_only_uuid:
        print("Transcription completed")


if __name__ == '__main__':
    # Try to import psutil for parent process detection (optional)
    try:
        import psutil
    except ImportError:
        pass
    
    main()