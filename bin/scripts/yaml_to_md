#!/usr/bin/python3

# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import argparse
import sys
import yaml
from pathlib import Path
from typing import Any, Dict, List, Optional, Union


class YamlToMarkdownConverter:
    """Convert any YAML structure to markdown.

    Supports both:
    1. md_to_yaml format (with 'content' and 'type' fields)
    2. Arbitrary YAML structures (booleans, lists, dicts, primitives)
    """

    def __init__(self):
        self.output: List[str] = []
        self.in_table: bool = False

    def convert(self, data: Any) -> str:
        """Convert YAML data to markdown string."""
        self.output = []
        self.in_table = False

        if not isinstance(data, dict):
            # Handle non-dict root (shouldn't happen with proper YAML, but be safe)
            self._render_value(data, level=0)
        else:
            # Process root keys
            for doc_name, doc_content in data.items():
                self._process_node(doc_name, doc_content, level=1)

        # Join output and clean up trailing whitespace
        markdown = '\n'.join(self.output).rstrip()
        return markdown

    def _process_node(self, key: str, value: Any, level: int) -> None:
        """Process a key-value pair, determining how to render based on value type."""

        # Special handling for md_to_yaml format
        if isinstance(value, dict) and 'content' in value and isinstance(value['content'], list):
            # This is md_to_yaml format
            self._process_md_yaml_section(key, value, level)
            return

        # General YAML handling
        if isinstance(value, dict):
            # Heading + nested content
            self._add_heading(key, level)
            self._process_dict(value, level + 1)
        elif isinstance(value, list):
            # List of items
            self._add_heading(key, level)
            self._process_list(value)
        else:
            # Scalar value - render as key: value
            self._add_key_value(key, value)

    def _process_md_yaml_section(self, section_name: str, section_data: Dict[str, Any], level: int) -> None:
        """Process sections in md_to_yaml format (with 'content' key)."""
        self._add_heading(section_name, level)

        # Process content list
        if 'content' in section_data:
            content_list = section_data['content']
            if isinstance(content_list, list):
                for item in content_list:
                    if isinstance(item, dict):
                        self._process_content_item(item)

        # Process subsections (other keys that are dicts)
        for key, value in section_data.items():
            if key != 'content':
                if isinstance(value, dict) and 'content' in value:
                    self._process_md_yaml_section(key, value, level + 1)
                elif isinstance(value, dict):
                    self._process_node(key, value, level + 1)

    def _process_dict(self, data: Dict[str, Any], level: int) -> None:
        """Process a dictionary at a given nesting level."""
        for key, value in data.items():
            self._process_node(key, value, level)

    def _process_list(self, items: List[Any]) -> None:
        """Process a list of items."""
        # Check if list contains dicts with 'type' (md_to_yaml content format)
        if items and isinstance(items[0], dict) and 'type' in items[0]:
            for item in items:
                if isinstance(item, dict):
                    self._process_content_item(item)
        else:
            # Regular list
            self._add_unordered_list(items)

    def _process_content_item(self, item: Dict[str, Any]) -> None:
        """Process a single content item based on its type (md_to_yaml format)."""
        item_type = item.get('type', 'unknown')

        if item_type == 'paragraph':
            self._add_paragraph(item.get('value', ''))
        elif item_type == 'list':
            self._add_unordered_list(item.get('values', []))
        elif item_type == 'ordered_list':
            self._add_ordered_list(item.get('values', []))
        elif item_type == 'code':
            code_value = item.get('value', '')
            language = item.get('language', '')
            self._add_code_block(code_value, language)
        elif item_type == 'blockquote':
            self._add_blockquote(item.get('value', ''))
        else:
            # Unknown type, render value if present
            if 'value' in item:
                self._add_paragraph(str(item['value']))

    def _render_value(self, value: Any, level: int = 0) -> str:
        """Convert a YAML value to markdown representation."""
        if value is None:
            return 'null'
        elif isinstance(value, bool):
            return 'true' if value else 'false'
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, str):
            return value
        elif isinstance(value, list):
            return self._format_list(value)
        elif isinstance(value, dict):
            return self._format_dict(value)
        else:
            return str(value)

    def _format_list(self, items: List[Any]) -> str:
        """Format a list as inline markdown."""
        if not items:
            return '[]'
        # For short lists, render inline
        if len(items) <= 3 and all(isinstance(i, (str, int, float, bool)) or i is None for i in items):
            formatted = [self._render_value(item) for item in items]
            return '[' + ', '.join(formatted) + ']'
        return str(items)

    def _format_dict(self, d: Dict[str, Any]) -> str:
        """Format a dict as inline representation."""
        if not d:
            return '{}'
        return '{...}'  # Complex dict, show placeholder

    def _add_heading(self, text: str, level: int) -> None:
        """Add a markdown heading."""
        title = self._key_to_title(text)
        heading = '#' * level + ' ' + title
        self.output.append(heading)
        self.output.append('')

    def _add_paragraph(self, text: str) -> None:
        """Add a paragraph."""
        if text.strip():
            self.output.append(str(text))
            self.output.append('')

    def _add_key_value(self, key: str, value: Any) -> None:
        """Add a key-value pair as markdown."""
        title = self._key_to_title(key)
        rendered_value = self._render_value(value)
        self.output.append(f'**{title}:** {rendered_value}')
        self.output.append('')

    def _add_unordered_list(self, items: Union[List[Any], List[str]]) -> None:
        """Add an unordered list."""
        if not items:
            return
        for item in items:
            if isinstance(item, (dict, list)):
                # Complex item
                self.output.append(f'- {self._render_value(item)}')
            else:
                self.output.append(f'- {self._render_value(item)}')
        self.output.append('')

    def _add_ordered_list(self, items: Union[List[Any], List[str]]) -> None:
        """Add an ordered list."""
        if not items:
            return
        for i, item in enumerate(items, 1):
            if isinstance(item, (dict, list)):
                self.output.append(f'{i}. {self._render_value(item)}')
            else:
                self.output.append(f'{i}. {self._render_value(item)}')
        self.output.append('')

    def _add_code_block(self, code: str, language: str = '') -> None:
        """Add a code block."""
        self.output.append(f'```{language}')
        self.output.append(str(code))
        self.output.append('```')
        self.output.append('')

    def _add_blockquote(self, text: str) -> None:
        """Add a blockquote."""
        lines = str(text).split('\n')
        for line in lines:
            if line.strip():
                self.output.append(f'> {line}')
            else:
                self.output.append('>')
        self.output.append('')

    @staticmethod
    def _key_to_title(key: str) -> str:
        """Convert key to title case.

        Examples:
            'my_title' -> 'My Title'
            'enable_starship' -> 'Enable Starship'
        """
        return key.replace('_', ' ').replace('-', ' ').title()


def process_file(filepath: str) -> tuple:
    """Load and parse a YAML file."""
    path = Path(filepath)

    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"File not found: {filepath}")
    except yaml.YAMLError as e:
        raise ValueError(f"Invalid YAML in '{filepath}': {e}")
    except IOError as e:
        raise IOError(f"Error reading file '{filepath}': {e}")

    if not isinstance(data, dict):
        raise ValueError(f"YAML must contain a dictionary structure, got {type(data).__name__}")

    return data


def main() -> None:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        prog='yaml_to_md',
        description='Convert YAML files back to markdown format',
        epilog='''Examples:
  yaml_to_md -f structure.yaml
  yaml_to_md -f structure.yaml -o output.md
  cat structure.yaml | yaml_to_md
  yaml_to_md < structure.yaml -o output.md''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument(
        '-f', '--file',
        dest='files',
        action='append',
        help='YAML file(s) to convert (can be used multiple times)'
    )
    parser.add_argument(
        '-o', '--output',
        dest='output',
        help='Output markdown file (default: stdout)'
    )

    args = parser.parse_args()

    markdown_output: List[str] = []

    try:
        if args.files:
            for filepath in args.files:
                try:
                    yaml_data = process_file(filepath)
                    converter = YamlToMarkdownConverter()
                    md = converter.convert(yaml_data)
                    markdown_output.append(md)
                except (FileNotFoundError, ValueError, IOError) as e:
                    print(f"Error: {e}", file=sys.stderr)
                    sys.exit(1)
        else:
            # Read from stdin
            try:
                yaml_content = sys.stdin.read()
                yaml_data = yaml.safe_load(yaml_content)
            except yaml.YAMLError as e:
                print(f"Error: Invalid YAML from stdin: {e}", file=sys.stderr)
                sys.exit(1)

            if not isinstance(yaml_data, dict):
                print(f"Error: YAML must contain a dictionary, got {type(yaml_data).__name__}", file=sys.stderr)
                sys.exit(1)

            converter = YamlToMarkdownConverter()
            md = converter.convert(yaml_data)
            markdown_output.append(md)

        # Combine multiple files with separator
        full_markdown = '\n\n---\n\n'.join(markdown_output)

        # Output
        if args.output:
            try:
                with open(args.output, 'w', encoding='utf-8') as f:
                    f.write(full_markdown)
                print(f"âœ“ Output written to {args.output}", file=sys.stderr)
            except IOError as e:
                print(f"Error: Cannot write to '{args.output}': {e}", file=sys.stderr)
                sys.exit(1)
        else:
            print(full_markdown)

    except KeyboardInterrupt:
        print("\nInterrupted", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
