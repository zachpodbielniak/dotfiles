#!/bin/bash
# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail

SCRIPT_NAME="$(basename "${0}")"

usage () {
    cat <<EOF
${SCRIPT_NAME} - Run shellcheck on selection and annotate issues

USAGE:
    ${SCRIPT_NAME} [OPTIONS] [FILE]

DESCRIPTION:
    Runs shellcheck on shell script content and outputs the original
    code with issue annotations as comments.

OPTIONS:
    -h, --help          Show this help message and exit
    -s, --shell SHELL   Specify shell dialect (bash, sh, dash, ksh)
    -S, --severity SEV  Minimum severity (error, warning, info, style)
    -f, --format FMT    Output format: annotate (default), gcc, json
    --license           Show the license (AGPLv3) and exit

ARGUMENTS:
    FILE            Optional file path to read content from.
                    If not provided, reads from stdin.

EXAMPLES:
    # Check bash script from stdin
    echo 'echo \$foo' | ${SCRIPT_NAME}

    # Check with specific shell
    ${SCRIPT_NAME} -s sh script.sh

    # Only show errors
    ${SCRIPT_NAME} -S error script.sh

    # Use in neovim
    :'<,'>!${SCRIPT_NAME}

EOF
}

main () {
    local shell_type=""
    local severity=""
    local format="annotate"
    local file_path=""

    while [[ $# -gt 0 ]]; do
        case "${1}" in
            -h|--help)
                usage
                exit 0
                ;;
            -s|--shell)
                shell_type="${2}"
                shift
                ;;
            -S|--severity)
                severity="${2}"
                shift
                ;;
            -f|--format)
                format="${2}"
                shift
                ;;
            --license)
                echo "AGPLv3 - See source file for full license."
                exit 0
                ;;
            -*)
                echo "Error: Unknown option '${1}'" >&2
                exit 1
                ;;
            *)
                file_path="${1}"
                ;;
        esac
        shift
    done

    # Check if shellcheck is available
    if ! command -v shellcheck &>/dev/null; then
        echo "Error: shellcheck not installed" >&2
        exit 1
    fi

    local content
    if [[ -n "${file_path}" ]]; then
        content=$(cat "${file_path}")
    else
        content=$(cat)
    fi

    # Build shellcheck options
    local sc_opts=()
    if [[ -n "${shell_type}" ]]; then
        sc_opts+=("--shell=${shell_type}")
    fi
    if [[ -n "${severity}" ]]; then
        sc_opts+=("--severity=${severity}")
    fi

    if [[ "${format}" == "annotate" ]]; then
        # Get shellcheck output in gcc format for easy parsing
        local issues
        issues=$(echo "${content}" | shellcheck "${sc_opts[@]}" --format=gcc - 2>/dev/null || true)
        
        # Create associative array of line -> issues
        declare -A line_issues
        while IFS= read -r issue; do
            if [[ "${issue}" =~ ^-:([0-9]+):[0-9]+:\ (.*)$ ]]; then
                local line_num="${BASH_REMATCH[1]}"
                local msg="${BASH_REMATCH[2]}"
                if [[ -n "${line_issues[${line_num}]:-}" ]]; then
                    line_issues[${line_num}]+=$'\n'"# SC: ${msg}"
                else
                    line_issues[${line_num}]="# SC: ${msg}"
                fi
            fi
        done <<< "${issues}"
        
        # Output content with annotations
        local line_num=0
        while IFS= read -r line; do
            ((line_num++)) || true
            echo "${line}"
            if [[ -n "${line_issues[${line_num}]:-}" ]]; then
                echo "${line_issues[${line_num}]}"
            fi
        done <<< "${content}"
        
        # Summary
        local issue_count
        issue_count=$(echo "${issues}" | grep -c '^-:' || echo 0)
        if [[ ${issue_count} -gt 0 ]]; then
            echo ""
            echo "# shellcheck: ${issue_count} issue(s) found"
        else
            echo ""
            echo "# shellcheck: no issues found âœ“"
        fi
    elif [[ "${format}" == "json" ]]; then
        echo "${content}" | shellcheck "${sc_opts[@]}" --format=json1 - 2>/dev/null || true
    else
        # gcc format or other
        echo "${content}" | shellcheck "${sc_opts[@]}" --format="${format}" - 2>/dev/null || true
    fi
}

main "$@"
