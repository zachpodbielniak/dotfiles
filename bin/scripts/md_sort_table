#!/usr/bin/env python3
# dotfiles - Personal configuration files and scripts
# Copyright (C) 2025  Zach Podbielniak
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
md_sort_table - Sort markdown table by column

Usage: md_sort_table [OPTIONS] [COLUMN] [FILE]

Sorts a markdown table by the specified column (1-indexed, default: 1).
"""

import sys
import argparse
import re


def parse_table_row(line: str) -> list[str]:
    """Parse a markdown table row into cells."""
    # Remove leading/trailing pipes and split
    line = line.strip()
    if line.startswith('|'):
        line = line[1:]
    if line.endswith('|'):
        line = line[:-1]
    return [cell.strip() for cell in line.split('|')]


def is_separator_row(line: str) -> bool:
    """Check if line is a table separator row (|---|---|)."""
    return bool(re.match(r'^\|?[\s:-]+\|[\s:|+-]+\|?$', line.strip()))


def sort_key(cell: str, numeric: bool = False, reverse: bool = False):
    """Generate sort key for a cell."""
    if numeric:
        # Try to extract numeric value
        # Handle currency ($123.45), percentages (45%), etc.
        match = re.search(r'[-+]?\d*\.?\d+', cell.replace(',', ''))
        if match:
            return float(match.group())
        return float('inf') if not reverse else float('-inf')
    return cell.lower()


def main():
    parser = argparse.ArgumentParser(
        description='Sort markdown table by column'
    )
    parser.add_argument(
        'column', 
        nargs='?', 
        type=int, 
        default=1,
        help='Column number to sort by (1-indexed, default: 1)'
    )
    parser.add_argument(
        'file',
        nargs='?',
        type=argparse.FileType('r'),
        default=sys.stdin,
        help='Input file (default: stdin)'
    )
    parser.add_argument(
        '-r', '--reverse',
        action='store_true',
        help='Sort in descending order'
    )
    parser.add_argument(
        '-n', '--numeric',
        action='store_true',
        help='Sort numerically (extracts numbers from cells)'
    )
    parser.add_argument(
        '--no-header',
        action='store_true',
        help='Table has no header row'
    )
    
    args = parser.parse_args()
    
    content = args.file.read()
    lines = content.splitlines()
    
    if not lines:
        return
    
    # Find table boundaries
    header_line = None
    separator_line = None
    data_lines = []
    pre_table = []
    post_table = []
    
    in_table = False
    table_done = False
    
    for i, line in enumerate(lines):
        if table_done:
            post_table.append(line)
            continue
            
        # Check if this looks like a table row
        if '|' in line and not table_done:
            if not in_table:
                in_table = True
                if not args.no_header:
                    header_line = line
                else:
                    data_lines.append(line)
            elif is_separator_row(line):
                separator_line = line
            else:
                data_lines.append(line)
        elif in_table:
            # End of table
            table_done = True
            post_table.append(line)
        else:
            pre_table.append(line)
    
    # Sort data lines
    col_idx = args.column - 1  # Convert to 0-indexed
    
    def get_sort_key(line):
        cells = parse_table_row(line)
        if col_idx < len(cells):
            return sort_key(cells[col_idx], args.numeric, args.reverse)
        return sort_key('', args.numeric, args.reverse)
    
    sorted_data = sorted(data_lines, key=get_sort_key, reverse=args.reverse)
    
    # Output
    for line in pre_table:
        print(line)
    
    if header_line:
        print(header_line)
    if separator_line:
        print(separator_line)
    
    for line in sorted_data:
        print(line)
    
    for line in post_table:
        print(line)


if __name__ == '__main__':
    main()
