#!/bin/bash


make_export () {
    [ "$#" != 1 ] && echo "$0 <bin>" && exit 1
    local export_dir="$HOME/bin/export"
    local bin_to_export="$1"
    mkdir -p "${export_dir}"
    if [ -f "${export_dir}/${bin_to_export}" ]; then rm "${export_dir}/${bin_to_export}"; fi
    distrobox-export --bin $(which "${bin_to_export}") --export-path "${export_dir}/"
}


make_app () {
    [ "$#" != 1 ] && echo "$0 <app>" && exit 1
    distrobox-export --app "$1"
}



function fr() {
    [ "$#" != 1 ] && echo "Usage: fr <app_name>" && exit 1
    local app="$1"

    flatpak run $(flatpak search "$app" --columns application | grep -v "Application\ ID")
}


function tm() {
    local tmux_main=$(tmux ls | grep ^main)
    if [ "$tmux_main" == "" ]
    then 
        tmux new-ses -t main
    else 
        tmux a -t main
    fi
}


in_container() {
    [ -f /run/.containerenv ] && echo 1 || echo 0
}

get_current_container_name() {
    local in_c=$(in_container)
    if [ "1" == "$in_c" ]; then
        cat /run/.containerenv | grep -i name | awk -F= '{printf "%s\n", $2}' | sed 's/\"//g'
    else
        echo "0"
    fi
}

# Useful Web Gets
get_word_def() {
    if [ $# -eq 0 ]; then
        echo "Usage: $0 <word>"
    else
        local word="$1"
        local defs=$(curl --silent "https://api.dictionaryapi.dev/api/v2/entries/en/$word" | jq .[].meanings[].definitions[].definition)
        while read -r line; do
            local quotes_removed=$(sed 's/"//g' <<<$line)
            echo "- $quotes_removed"
        done <<<"$defs"
    fi
}

get_recipe() {
    if [ $# -eq 0 ]; then
        echo "Usage: $0 <recipe_url>"
        return 1
    fi

    curl -sG "https://plainoldrecipe.com/recipe" -d "url=${1}" | pandoc -f html -t markdown
}

declare -A SWITCHES=(
    [fan-01]="b4_b0_24_29_80_df"
    [fan-02]="b4_b0_24_29_c2_2c"
    [lamp-01]="b4_b0_24_0e_09_83"
    [lamp-02]="b4_b0_24_0e_0d_c5"
    [lamp-03]="54_af_97_f4_25_28"
    [lamp-04]="28_87_ba_6a_2a_ef"
    [storage]="d8_47_32_9e_e9_15"
    [server]="6c_5a_b0_9b_38_ae"
)

toggle_switch() {
    [ $# -eq 0 ] && echo "Usage: $0 <switch>" && echo ${!SWITCHES[@]} && return 1
    if [[ -n "${SWITCHES["$1"]}" ]]; then
        local value=${SWITCHES["$1"]}
        distrobox enter dev -- hass-cli service call switch.toggle --arguments "entity_id=switch.$value" >/dev/null
    else
        echo "$1 is not a valid switch"
        echo ${!SWITCHES[@]}
        return 1
    fi
    return 0
}

ebsearch() {
    [ $# -eq 0 ] && echo "Usage: $0 <pcre_query>" && return 1
    rg -P $1 ~/Documents/E-Books/
}

function nonzero_return() {
    RETVAL=$?
    [ $RETVAL -ne 0 ] && echo "$RETVAL"
}

# get current branch in git repo
function parse_git_branch() {
    BRANCH=$(git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    if [ ! "${BRANCH}" == "" ]; then
        STAT=$(parse_git_dirty)
        echo "[${BRANCH}${STAT}]"
    else
        echo ""
    fi
}

# get current status of git repo
function parse_git_dirty {
    status=$(git status 2>&1 | tee)
    dirty=$(
        echo -n "${status}" 2>/dev/null | grep "modified:" &>/dev/null
        echo "$?"
    )
    untracked=$(
        echo -n "${status}" 2>/dev/null | grep "Untracked files" &>/dev/null
        echo "$?"
    )
    ahead=$(
        echo -n "${status}" 2>/dev/null | grep "Your branch is ahead of" &>/dev/null
        echo "$?"
    )
    newfile=$(
        echo -n "${status}" 2>/dev/null | grep "new file:" &>/dev/null
        echo "$?"
    )
    renamed=$(
        echo -n "${status}" 2>/dev/null | grep "renamed:" &>/dev/null
        echo "$?"
    )
    deleted=$(
        echo -n "${status}" 2>/dev/null | grep "deleted:" &>/dev/null
        echo "$?"
    )
    bits=''
    if [ "${renamed}" == "0" ]; then
        bits=">${bits}"
    fi
    if [ "${ahead}" == "0" ]; then
        bits="*${bits}"
    fi
    if [ "${newfile}" == "0" ]; then
        bits="+${bits}"
    fi
    if [ "${untracked}" == "0" ]; then
        bits="?${bits}"
    fi
    if [ "${deleted}" == "0" ]; then
        bits="x${bits}"
    fi
    if [ "${dirty}" == "0" ]; then
        bits="!${bits}"
    fi
    if [ ! "${bits}" == "" ]; then
        echo " ${bits}"
    else
        echo ""
    fi
}

# Power Related
function on_battery_power() {
    upower -d | grep -i on-battery | awk '{printf "%s", $2}'
}

function get_power_profile() {
    powerprofilesctl get
}

function list_power_profiles() {
    powerprofilesctl list
}

function set_power_profile() {
    local prof="$1"
    [ "" == "$prof" ] && echo "Usage: $0 <profile_name>" && exit 1
    powerprofilesctl set "$prof"
}

function set_appropriate_power_profile() {
    local power=$(on_battery_power)
    if [ "no" == "$power" ]; then
        echo "Setting power profile to performance"
        set_power_profile performance
    else
        echo "Setting power profile to power-saver"
        set_power_profile power-saver
    fi
}

function update_k8s_cluster() {
    local HOSTS=("kube-00.podbielniak.com" "kube-01.podbielniak.com" "kube-02.podbielniak.com")
    for host in ${HOSTS[@]}; do ssh $host sudo dnf update --refresh -y; done
    for host in ${HOSTS[@]}; do ssh $host sudo systemctl restart kubelet && sleep 15; done
}


function fr () {
	[ "$#" != 1 ] && echo "Usage: fr <app_name>" && exit 1
	local app="$1"

	flatpak run $(flatpak search "$app" --columns application | grep -v "Application\ ID")
}


in_container () { 
	[ -f /run/.containerenv ] && echo 1 || echo 0
}


get_current_container_name () {
	local in_c=$(in_container)
	if [ "1" == "$in_c" ] 
	then
		cat /run/.containerenv | grep -i name | awk -F= '{printf "%s\n", $2}' | sed 's/\"//g'
	else
		echo "0"
	fi
}


# 1 args: 
# key 
gsettings_to_bash_associative_array() {
    for k in $(gsettings list-keys "$1") 
    do 
        printf '[%s]="%s"\n' $k $(gsettings get "$1" $k)
    done
}


canned_response() {
    local cr_dir="$HOME/.config/canned_reponses/cr.yaml"
    yq .responses[].name < "${cr_dir}" | \
        fzf -i --height=100% --preview="yq '.responses[] | select(.name == \"{}\").text' < \"${cr_dir}\"" --tmux center | \
        sed -z 's/\n//g' | \
        xargs -0 -I % bash -c "yq '.responses[] | select(.name == \"%\").text' < ${cr_dir}" | \
        xargs -0 -I % echo -e '%' | \
        wl-copy
}

new_note() {
    shopt -s extglob
    local notes_path="$HOME/Documents/notes"
    local para_path=""
    local today="$(date +'%Y-%m-%d')"
    local full_path=""

    # If less less than 1 default to date in inbox
    if [ $# -lt 1 ]
    then 
        full_path="${notes_path}/00_inbox/$today.norg"
        bash -c "cd \"${notes_path}\" && nvim \"${full_path}\""
        return 0
    fi

    # If less than 2 default to inbox but with name
    if [ $# -lt 2 ]
    then 
        full_path="${notes_path}/00_inbox/$1.norg"
        bash -c "cd \"${notes_path}\" && nvim \"${full_path}\""
        return 0
    fi


    local nloc="$1"
    local nname="$2"
    readarray -d/ path_split <<< "$nloc"


    case "${path_split[0]/\//}" in 
        # archives must match exactly and be first
        arc*)
            para_path="04_archives"
            ;;

        # _inbox
        i*) para_path="00_inbox";;
        
        # projects
        p*)
            para_path="01_projects"
            ;;

        # areas
        a*)
            para_path="02_areas"
            ;;

        # resources
        r*)
            para_path="03_resources"
            ;;

    esac
    local new_note="$para_path/"

    for subdir in "${path_split[@]:1}"
    do 
        new_note="${new_note}${subdir}"
    done

    # Remove whitespace with xargs trick - https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
    new_note="$(echo ${new_note} | xargs echo)/${nname}.norg"

    full_path="${notes_path}/${new_note}"
    echo -e "New note can be found here:\n${full_path}"

    mkdir -p "$(dirname ${full_path})"
    # No need to touch it, since when we save it will be written
    # touch "${full_path}"

    bash -c "cd \"${notes_path}\" && nvim \"${full_path}\""
}


open_note() {
    nvim "$HOME/Documents/notes/$(bash -c 'cd $HOME/Documents/notes && fzf')"
}


norg_prefill_dir() {
    for d in ./*; do if [ -d "$d" ]; then touch "$d/00_index.norg"; fi; done
}

git_daily() {
    git commit -m "chore(daily): $(date +'%Y-%m-%d')" && git push
}

# Repurposed from https://github.com/rwxrob/dot/blob/main/scripts/toemoji
# Pipe a file into to_emoji and it will repplace the contents
